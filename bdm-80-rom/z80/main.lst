                        ; --------------------------------------
                        ; zasm: assemble "main.asm"
                        ; date: 2023-01-24 16:57:52
                        ; --------------------------------------


                        ;	MS-BASIC START UP ROUTINE
                        ;	TARGET: AKI-80
                        ;	ASSEMBLER: ARCPIT XZ80.EXE
                        ;
003F:                   RBFSIZ	EQU	3FH
8000:                   RECBUF	EQU	8000H
803F:                   RBFWTP	EQU	RECBUF+RBFSIZ
003F:                   RBFLMT	EQU	(RECBUF+RBFSIZ)&0FFH
8041:                   RBFRDP	EQU	RBFWTP+2
8043:                   RBFCNT	EQU	RBFRDP+2
8044:                   FLGBST	EQU	RBFCNT+1
80ED:                   TSTACK	EQU	80EDH
                        ;
0012:                   PCTCC2	EQU	12H
0004:                   PSIOAD  EQU 0100B
0006:                   PSIOAC  EQU 0110B
                        ;
0008:                   PIOAD EQU 01000B
000A:                   PIOAC EQU 01010B
0009:                   PIOBD EQU 01001B
000B:                   PIOBC EQU 01011B
                        ;
FFFC:                   DISPA EQU 0fffcH
FFFE:                   DISPD EQU 0fffeH
                        ;
000D:                   CR	EQU	0DH
000A:                   LF	EQU	0AH
0000:                     ORG	0000H
0000:                   ALLINIT:
0000: C3351D   [10]       JP RUNST
                        ;
                        	ORG	0003H
                        ;
                        ;	RESET VECTOR
0003: F3       [ 4]     RST00:	DI
0004: C3AA00   [14]     	JP	SINIT
                        ;
                        ;	RESTART VECTOR
0007: FF                	ORG	0008H
0008: C38F00   [10]     RST08:	JP	TXA
000B: FFFFFFFF          	ORG	0010H
000F: FF                
0010: C36C00   [10]     RST10:	JP	RXA
0013: FFFFFFFF          	ORG	0018H
0017: FF                
0018: C39A00   [10]     RST18:	JP	KBHIT
                        ;
                        ;	INTERRUPT VECTOR
001B: FFFFFFFF          	ORG	0038H
001F: FF...             
0038: 1800     [12]     RST38:	JR	INTRCV
                        ;
                        ;	SIO -> BUFFER BY INTERRUPT
003A: F5       [11]     INTRCV:	PUSH	AF
003B: E5       [22]     	PUSH	HL
003C: DB06     [33]     	IN	A,(PSIOAC)	;CHECK RECEIVE
003E: CB47     [41]     	BIT	0,A
0040: 2825     [48|53]  	JR	Z,INTEXT
0042: DB04     [59]     	IN	A,(PSIOAD)
0044: F5       [70]     	PUSH	AF
0045: 3A4380   [83]     	LD	A,(RBFCNT)	;CHECK BUFFER FULL
0048: FE3F     [90]     	CP	RBFSIZ
004A: 2003     [97|102] 	JR	NZ,NOTFUL
004C: F1       [107]    	POP	AF
004D: 1818     [119]    	JR	INTEXT
004F: 2A3F80   [16]     NOTFUL:	LD	HL,(RBFWTP)	;CHECK WRAP
0052: 23       [22]     	INC	HL
0053: 7D       [26]     	LD	A,L
0054: FE3F     [33]     	CP	RBFLMT
0056: 2003     [40|45]  	JR	NZ,NWWRAP
0058: 210080   [50]     	LD	HL,RECBUF
005B: 223F80   [16]     NWWRAP:	LD	(RBFWTP),HL
005E: F1       [26]     	POP	AF
005F: 77       [33]     	LD	(HL),A
0060: 3A4380   [46]     	LD	A,(RBFCNT)
0063: 3C       [50]     	INC	A
0064: 324380   [63]     	LD	(RBFCNT),A
0067: E1       [10]     INTEXT:	POP	HL
0068: F1       [20]     	POP	AF
0069: FB       [24]     	EI
006A: ED4D     [38]     	RETI
                        ;
                        ;	BUFFER -> A
006C: 3A4380   [13]     RXA:	LD	A,(RBFCNT)
006F: FE00     [20]     	CP	00H
0071: 28F9     [27|32]  	JR	Z,RXA
0073: E5       [38]     	PUSH	HL
0074: 2A4180   [54]     	LD	HL,(RBFRDP)
0077: 23       [60]     	INC	HL
0078: 7D       [64]     	LD	A,L
0079: FE3F     [71]     	CP	RBFLMT
007B: 2003     [78|83]  	JR	NZ,NRWRAP
007D: 210080   [88]     	LD	HL,RECBUF
0080: F3       [ 4]     NRWRAP:	DI
0081: 224180   [20]     	LD	(RBFRDP),HL
0084: 3A4380   [33]     	LD	A,(RBFCNT)
0087: 3D       [37]     	DEC	A
0088: 324380   [50]     	LD	(RBFCNT),A
008B: 7E       [57]     	LD	A,(HL)
008C: FB       [61]     	EI
008D: E1       [71]     	POP	HL
008E: C9       [81]     	RET
                        ;
                        ;	A -> SIO
008F: F5       [11]     TXA:	PUSH	AF
0090: DB06     [11]     TXLOOP:	IN	A,(PSIOAC)	;CHECK STATUS
0092: CB57     [19]     	BIT	2,A
0094: 28FA     [26|31]  	JR	Z,TXLOOP
0096: F1       [36]     	POP	AF		; TRANSFER
0097: D304     [47]     	OUT	(PSIOAD),A
0099: C9       [57]     	RET
                        ;
                        ;	CHECK RECEIVE STATUS
009A: 3A4380   [13]     KBHIT:	LD	A,(RBFCNT)
009D: FE00     [20]     	CP	00H
009F: C9       [30]     	RET
                        ;
                        ;	SIO COMMAND CHAIN
00A0:                   SIOCMD:
00A0: 0018              	DB	00H,00011000B	;RESET
00A2: 0444              	DB	04H,01000100B	;SERIAL
00A4: 0110              	DB	01H,00010000B	;INTERRUPT
00A6: 05EA              	DB	05H,11101010B	;TRANSMIT
00A8: 03C1              	DB	03H,11000001B	;RECEIVE
000A:                   SIOCML	EQU	$-SIOCMD
                        ;
                        ;	SYSTEM INITIALIZE
00AA: 31ED80   [10]     SINIT:	LD	SP,TSTACK
00AD: 210080   [20]     	LD	HL,RECBUF
00B0: 223F80   [36]     	LD	(RBFWTP),HL
00B3: 224180   [52]     	LD	(RBFRDP),HL
00B6: AF       [56]     	XOR	A
00B7: 324380   [69]     	LD	(RBFCNT),A
                        ;
                        ;	CTC INITIALIZE
00BA: 3E07     [76]     	LD	A,00000111B
00BC: D312     [87]     	OUT	(PCTCC2),A
                        ;	LD	A,4		;9.8304MHz
                        ;	LD	A,3		;7.3728MHz
                        ;	LD	A,2		;4.9152MHz
00BE: 3E01     [94]     	LD	A,1		;2.4576MHz
00C0: D312     [105]    	OUT	(PCTCC2),A
                        ;
                        ;	SIO INITIALIZE
00C2: 060A     [112]    	LD	B,SIOCML
00C4: 0E06     [119]    	LD	C,PSIOAC
00C6: 21A000   [129]    	LD	HL,SIOCMD
00C9: EDB3     [145|21] 	OTIR
                        ;
                        ;	SETUP INTERRUPT
00CB: ED56     [153]    	IM	1
00CD: FB       [157]    	EI
                        ;
                        ;	START BASIC
00CE: C3D100   [167]    	JP	COLD
                        ;
                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        ;
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        ;
                        ; GENERAL EQUATES
                        ;
0003:                   CTRLC	EQU	03H		; Control "C"
0007:                   CTRLG	EQU	07H		; Control "G"
0008:                   BKSP	EQU	08H		; Back space
000A:                   LF	EQU	0AH		; Line feed
000C:                   CS	EQU	0CH		; Clear screen
000D:                   CR	EQU	0DH		; Carriage return
000F:                   CTRLO	EQU	0FH		; Control "O"
0011:                   CTRLQ	EQU	11H		; Control "Q"
0012:                   CTRLR	EQU	12H		; Control "R"
0013:                   CTRLS	EQU	13H		; Control "S"
0015:                   CTRLU	EQU	15H		; Control "U"
001B:                   ESC	EQU	1BH		; Escape
007F:                   DEL	EQU	7FH		; Delete
                        ;
                        ; BASIC WORK SPACE LOCATIONS
                        ;
8045:                   WRKSPC	EQU	8045H		; BASIC Work space
8048:                   USR	EQU	WRKSPC+3H	; "USR (x)" jump
804B:                   OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
804C:                   OTPORT	EQU	WRKSPC+7H	; Port (p)
804E:                   DIVSUP	EQU	WRKSPC+9H	; Division support routine
804F:                   DIV1	EQU	WRKSPC+0AH	; <- Values
8053:                   DIV2	EQU	WRKSPC+0EH	; <- to
8057:                   DIV3	EQU	WRKSPC+12H	; <- be
805A:                   DIV4	EQU	WRKSPC+15H	; <- inserted
805C:                   SEED	EQU	WRKSPC+17H	; Random number seed
807F:                   LSTRND	EQU	WRKSPC+3AH	; Last random number
8083:                   INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
8084:                   INPORT	EQU	WRKSPC+3FH	; PORT (x)
8086:                   NULLS	EQU	WRKSPC+41H	; Number of nulls
8087:                   LWIDTH	EQU	WRKSPC+42H	; Terminal width
8088:                   COMMAN	EQU	WRKSPC+43H	; Width for commas
8089:                   NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
808A:                   CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
808B:                   LINESC	EQU	WRKSPC+46H	; Lines counter
808D:                   LINESN	EQU	WRKSPC+48H	; Lines number
808F:                   CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
8091:                   NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
8092:                   BRKFLG	EQU	WRKSPC+4DH	; Break flag
8093:                   RINPUT	EQU	WRKSPC+4EH	; Input reflection
8096:                   POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
8099:                   PSET	EQU	WRKSPC+54H	; "SET"	reflection
809C:                   RESET	EQU	WRKSPC+57H	; "RESET" reflection
809F:                   STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
80A1:                   LINEAT	EQU	WRKSPC+5CH	; Current line number
80A3:                   BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
80A6:                   BUFFER	EQU	WRKSPC+61H	; Input buffer
80AB:                   STACK	EQU	WRKSPC+66H	; Initial stack
80F0:                   CURPOS	EQU	WRKSPC+0ABH	; Character position on line
80F1:                   LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
80F2:                   TYPE	EQU	WRKSPC+0ADH	; Data type flag
80F3:                   DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
80F4:                   LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
80F6:                   TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
80F8:                   TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
8104:                   TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
8108:                   STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
810A:                   CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
810C:                   LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
810E:                   DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
8110:                   FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
8111:                   LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
8112:                   READFG	EQU	WRKSPC+0CDH	; Read/Input flag
8113:                   BRKLIN	EQU	WRKSPC+0CEH	; Line of break
8115:                   NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
8117:                   ERRLIN	EQU	WRKSPC+0D2H	; Line of error
8119:                   CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
811B:                   PROGND	EQU	WRKSPC+0D6H	; End of program
811D:                   VAREND	EQU	WRKSPC+0D8H	; End of variables
811F:                   ARREND	EQU	WRKSPC+0DAH	; End of arrays
8121:                   NXTDAT	EQU	WRKSPC+0DCH	; Next data item
8123:                   FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
8125:                   FNARG	EQU	WRKSPC+0E0H	; FN argument value
8129:                   FPREG	EQU	WRKSPC+0E4H	; Floating point register
812C:                   FPEXP	EQU	FPREG+3		; Floating point exponent
812D:                   SGNRES	EQU	WRKSPC+0E8H	; Sign of result
812E:                   PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
813B:                   MULVAL	EQU	WRKSPC+0F6H	; Multiplier
813E:                   PROGST	EQU	WRKSPC+0F9H	; Start of program text area
81A2:                   STLOOK	EQU	WRKSPC+15DH	; Start of memory test
                        ;
                        ; BASIC ERROR CODE VALUES
                        ;
0000:                   NF	EQU	00H		; NEXT without FOR
0002:                   SN	EQU	02H		; Syntax error
0004:                   RG	EQU	04H		; RETURN without GOSUB
0006:                   OD	EQU	06H		; Out of DATA
0008:                   FC	EQU	08H		; Function call error
000A:                   OV	EQU	0AH		; Overflow
000C:                   OM	EQU	0CH		; Out of memory
000E:                   UL	EQU	0EH		; Undefined line number
0010:                   BS	EQU	10H		; Bad subscript
0012:                   RD	EQU	12H		; Re-DIMensioned array
0014:                   DZ	EQU	14H		; Division by zero (/0)
0016:                   ID	EQU	16H		; Illegal direct
0018:                   TM	EQU	18H		; Type miss-match
001A:                   OS	EQU	1AH		; Out of string space
001C:                   LS	EQU	1CH		; String too long
001E:                   ST	EQU	1EH		; String formula too complex
0020:                   CN	EQU	20H		; Can't CONTinue
0022:                   UF	EQU	22H		; UnDEFined FN function
0024:                   MO	EQU	24H		; Missing operand
0026:                   HX	EQU	26H		; HEX error
0028:                   BN	EQU	28H		; BIN error
                        ;
00D1: C3D700   [10]     COLD:	JP	STARTB		; Jump for cold start
00D4: C34C01   [10]     WARM:	JP	WARMST		; Jump for warm start
00D7: C3DE00   [10]     STARTB: JP	CSTART		; Jump to initialise
                        ;
00DA: 8F09              	DW	DEINT		; Get integer -32768 to 32767
00DC: 0511              	DW	ABPASS		; Return integer in AB
                        ;
00DE: 214580   [10]     CSTART: LD	HL,WRKSPC	; Start of workspace RAM
00E1: F9       [16]     	LD	SP,HL		; Set up a temporary stack
00E2: C3201D   [26]     	JP	INITST		; Go to initialise
                        ;
00E5: 11B603   [10]     INIT:	LD	DE,INITAB	; Initialise workspace
00E8: 0663     [17]     	LD	B,INITBE-INITAB+3; Bytes to copy
00EA: 214580   [27]     	LD	HL,WRKSPC	; Into workspace RAM
00ED: 1A       [ 7]     COPY:	LD	A,(DE)		; Get source
00EE: 77       [14]     	LD	(HL),A		; To destination
00EF: 23       [20]     	INC	HL		; Next destination
00F0: 13       [26]     	INC	DE		; Next source
00F1: 05       [30]     	DEC	B		; Count bytes
00F2: C2ED00   [40|40]  	JP	NZ,COPY		; More to move
00F5: F9       [46]     	LD	SP,HL		; Temporary stack
00F6: CDB705   [63]     	CALL	CLREG		; Clear registers and stack
00F9: CD850B   [80]     	CALL	PRCRLF		; Output CRLF
00FC: 32EF80   [93]     	LD	(BUFFER+72+1),A	; Mark end of buffer
00FF: 323E81   [106]    	LD	(PROGST),A	; Initialise program area
0102: 21A281   [10]     MSIZE:	LD	HL,STLOOK	; Point to start of RAM
0105: 23       [ 6]     MLOOP:	INC	HL		; Next byte
0106: 7C       [10]     	LD	A,H		; Above address FFFF ?
0107: B5       [14]     	OR	L
0108: CA1401   [24|24]  	JP	Z,SETTOP	; Yes - 64K RAM
010B: 7E       [31]     	LD	A,(HL)		; Get contents
010C: 47       [35]     	LD	B,A		; Save it
010D: 2F       [39]     	CPL			; Flip all bits
010E: 77       [46]     	LD	(HL),A		; Put it back
010F: BE       [53]     	CP	(HL)		; RAM there if same
0110: 70       [60]     	LD	(HL),B		; Restore old contents
0111: CA0501   [70|70]  	JP	Z,MLOOP		; If RAM - test next byte
                        ;
0114: 2B       [ 6]     SETTOP: DEC	HL		; Back one byte
0115: 11A181   [16]     	LD	DE,STLOOK-1	; See if enough RAM
0118: CD4D07   [33]     	CALL	CPDEHL		; Compare DE with HL
011B: DA5501   [43|43]  	JP	C,NEMEM		; If not enough RAM
011E: 11CEFF   [53]     	LD	DE,0-50		; 50 Bytes string space
0121: 22F480   [69]     	LD	(LSTRAM),HL	; Save last available RAM
0124: 19       [80]     	ADD	HL,DE		; Allocate string space
0125: 229F80   [96]     	LD	(STRSPC),HL	; Save string space
0128: CD9205   [113]    	CALL	CLRPTR		; Clear program area
012B: 2A9F80   [129]    	LD	HL,(STRSPC)	; Get end of memory
012E: 11EFFF   [139]    	LD	DE,0-17		; Offset for free bytes
0131: 19       [150]    	ADD	HL,DE		; Adjust HL
0132: 113E81   [160]    	LD	DE,PROGST	; Start of program text
0135: 7D       [164]    	LD	A,L		; Get LSB
0136: 93       [168]    	SUB	E		; Adjust it
0137: 6F       [172]    	LD	L,A		; Re-save
0138: 7C       [176]    	LD	A,H		; Get MSB
0139: 9A       [180]    	SBC	A,D		; Adjust it
013A: 67       [184]    	LD	H,A		; Re-save
013B: E5       [195]    	PUSH	HL		; Save bytes free
013C: 216D01   [205]    	LD	HL,SIGNON	; Sign-on message
013F: CD2312   [222]    	CALL	PRS		; Output string
0142: E1       [232]    	POP	HL		; Get bytes free back
0143: CDC618   [249]    	CALL	PRNTHL		; Output amount of free memory
0146: 215E01   [259]    	LD	HL,BFREE	; " Bytes free" message
0149: CD2312   [276]    	CALL	PRS		; Output string
                        ;
014C: 31AB80   [10]     WARMST: LD	SP,STACK	; Temporary stack
014F: CDB705   [17]     BRKRET: CALL	CLREG		; Clear registers and stack
0152: C3D004   [27]     	JP	PRNTOK		; Go to get command line
                        ;
0155: 21A401   [10]     NEMEM:	LD	HL,MEMMSG	; Memory size not enough
0158: CD2312   [27]     	CALL	PRS		; Print it
015B: C35B01   [10]     XXXXX:	JP	XXXXX		; Stop
                        ;
015E: 20427974          BFREE:	DB	" Bytes free",CR,LF,0,0
0162: 65732066          
0166: 7265650D          
016A: 0A0000            
                        ;
016D: 5A383020          SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
0171: 42415349          
0175: 43205665          
0179: 7220342E          
017D: 37620D0A          
0181: 436F7079          	DB	"Copyright ",40,"C",41
0185: 72696768          
0189: 74202843          
018D: 29                
018E: 20313937          	DB	" 1978 by Microsoft",CR,LF,0,0
0192: 38206279          
0196: 204D6963          
019A: 726F736F          
019E: 66740D0A          
01A2: 0000              
                        ;
01A4: 4D656D6F          MEMMSG: DB	"Memory size not enough",CR,LF
01A8: 72792073          
01AC: 697A6520          
01B0: 6E6F7420          
01B4: 656E6F75          
01B8: 67680D0A          
01BC: 54686520          	DB	"The system is stopped.",CR,LF,0,0
01C0: 73797374          
01C4: 656D2069          
01C8: 73207374          
01CC: 6F707065          
01D0: 642E0D0A          
01D4: 0000              
                        ;
                        ; FUNCTION ADDRESS TABLE
                        ;
01D6: 3B17              FNCTAB: DW	SGN
01D8: FF17              	DW	INT
01DA: 5117              	DW	ABS
01DC: 4880              	DW	USR
01DE: E310              	DW	FRE
01E0: 6814              	DW	INP
01E2: 1111              	DW	POS
01E4: C519              	DW	SQR
01E6: A41A              	DW	RND
01E8: E015              	DW	LOG
01EA: 131A              	DW	EXP
01EC: 191B              	DW	COS
01EE: 1F1B              	DW	SIN
01F0: 801B              	DW	TAN
01F2: 951B              	DW	ATN
01F4: BC14              	DW	PEEK
01F6: 001C              	DW	DEEK
01F8: 9680              	DW	POINT
01FA: 9513              	DW	LEN
01FC: AD11              	DW	STR
01FE: 2F14              	DW	VAL
0200: A413              	DW	ASC
0202: B513              	DW	CHR
0204: 221C              	DW	HEX
0206: B51C              	DW	BIN
0208: C513              	DW	LEFT
020A: F513              	DW	RIGHT
020C: FF13              	DW	MID
                        ;
                        ; RESERVED WORD LIST
                        ;
020E: C54E44            WORDS:	DB	0C5H,"ND"
0211: C64F52            	DB	0C6H,"OR"
0214: CE455854          	DB	0CEH,"EXT"
0218: C4415441          	DB	0C4H,"ATA"
021C: C94E5055          	DB	0C9H,"NPUT"
0220: 54                
0221: C4494D            	DB	0C4H,"IM"
0224: D2454144          	DB	0D2H,"EAD"
0228: CC4554            	DB	0CCH,"ET"
022B: C74F544F          	DB	0C7H,"OTO"
022F: D2554E            	DB	0D2H,"UN"
0232: C946              	DB	0C9H,"F"
0234: D2455354          	DB	0D2H,"ESTORE"
0238: 4F5245            
023B: C74F5355          	DB	0C7H,"OSUB"
023F: 42                
0240: D2455455          	DB	0D2H,"ETURN"
0244: 524E              
0246: D2454D            	DB	0D2H,"EM"
0249: D3544F50          	DB	0D3H,"TOP"
024D: CF5554            	DB	0CFH,"UT"
0250: CF4E              	DB	0CFH,"N"
0252: CE554C4C          	DB	0CEH,"ULL"
0256: D7414954          	DB	0D7H,"AIT"
025A: C44546            	DB	0C4H,"EF"
025D: D04F4B45          	DB	0D0H,"OKE"
0261: C44F4B45          	DB	0C4H,"OKE"
0265: D3435245          	DB	0D3H,"CREEN"
0269: 454E              
026B: CC494E45          	DB	0CCH,"INES"
026F: 53                
0270: C34C53            	DB	0C3H,"LS"
0273: D7494454          	DB	0D7H,"IDTH"
0277: 48                
0278: CD4F4E49          	DB	0CDH,"ONITOR"
027C: 544F52            
027F: D34554            	DB	0D3H,"ET"
0282: D2455345          	DB	0D2H,"ESET"
0286: 54                
0287: D052494E          	DB	0D0H,"RINT"
028B: 54                
028C: C34F4E54          	DB	0C3H,"ONT"
0290: CC495354          	DB	0CCH,"IST"
0294: C34C4541          	DB	0C3H,"LEAR"
0298: 52                
0299: C34C4F41          	DB	0C3H,"LOAD"
029D: 44                
029E: C3534156          	DB	0C3H,"SAVE"
02A2: 45                
02A3: CE4557            	DB	0CEH,"EW"
                        ;
02A6: D4414228          	DB	0D4H,"AB("
02AA: D44F              	DB	0D4H,"O"
02AC: C64E              	DB	0C6H,"N"
02AE: D3504328          	DB	0D3H,"PC("
02B2: D448454E          	DB	0D4H,"HEN"
02B6: CE4F54            	DB	0CEH,"OT"
02B9: D3544550          	DB	0D3H,"TEP"
                        ;
02BD: AB                	DB	0ABH
02BE: AD                	DB	0ADH
02BF: AA                	DB	0AAH
02C0: AF                	DB	0AFH
02C1: DE                	DB	0DEH
02C2: C14E44            	DB	0C1H,"ND"
02C5: CF52              	DB	0CFH,"R"
02C7: BE                	DB	0BEH
02C8: BD                	DB	0BDH
02C9: BC                	DB	0BCH
                        ;
02CA: D3474E            	DB	0D3H,"GN"
02CD: C94E54            	DB	0C9H,"NT"
02D0: C14253            	DB	0C1H,"BS"
02D3: D55352            	DB	0D5H,"SR"
02D6: C65245            	DB	0C6H,"RE"
02D9: C94E50            	DB	0C9H,"NP"
02DC: D04F53            	DB	0D0H,"OS"
02DF: D35152            	DB	0D3H,"QR"
02E2: D24E44            	DB	0D2H,"ND"
02E5: CC4F47            	DB	0CCH,"OG"
02E8: C55850            	DB	0C5H,"XP"
02EB: C34F53            	DB	0C3H,"OS"
02EE: D3494E            	DB	0D3H,"IN"
02F1: D4414E            	DB	0D4H,"AN"
02F4: C1544E            	DB	0C1H,"TN"
02F7: D045454B          	DB	0D0H,"EEK"
02FB: C445454B          	DB	0C4H,"EEK"
02FF: D04F494E          	DB	0D0H,"OINT"
0303: 54                
0304: CC454E            	DB	0CCH,"EN"
0307: D3545224          	DB	0D3H,"TR$"
030B: D6414C            	DB	0D6H,"AL"
030E: C15343            	DB	0C1H,"SC"
0311: C3485224          	DB	0C3H,"HR$"
0315: C8455824          	DB	0C8H,"EX$"
0319: C2494E24          	DB	0C2H,"IN$"
031D: CC454654          	DB	0CCH,"EFT$"
0321: 24                
0322: D2494748          	DB	0D2H,"IGHT$"
0326: 5424              
0328: CD494424          	DB	0CDH,"ID$"
032C: 80                	DB	80H		; End of list marker
                        ;
                        ; KEYWORD ADDRESS TABLE
                        ;
032D: 2709              WORDTB: DW	PEND
032F: 2408              	DW	FOR
0331: FF0C              	DW	NEXT
0333: 740A              	DW	DATA
0335: 060C              	DW	INPUT
0337: 3B0F              	DW	DIM
0339: 350C              	DW	READ
033B: 8B0A              	DW	LET
033D: 310A              	DW	GOTO
033F: 140A              	DW	RUN
0341: 030B              	DW	IF
0343: ED08              	DW	RESTOR
0345: 200A              	DW	GOSUB
0347: 4F0A              	DW	RETURN
0349: 760A              	DW	REM
034B: 2509              	DW	STOP
034D: 7414              	DW	POUT
034F: E50A              	DW	ON
0351: 6609              	DW	NULL
0353: 7A14              	DW	WAIT
0355: 1911              	DW	DEF
0357: C314              	DW	POKE
0359: 0B1C              	DW	DOKE
035B: 760A              	DW	REM
035D: F11B              	DW	LINES
035F: E41B              	DW	CLS
0361: E91B              	DW	WIDTH
0363: 1D1D              	DW	MONITR
0365: 9980              	DW	PSET
0367: 9C80              	DW	RESET
0369: 270B              	DW	PRINT
036B: 5309              	DW	CONT
036D: 9907              	DW	LIST
036F: CE09              	DW	CLEAR
0371: 760A              	DW	REM
0373: 760A              	DW	REM
0375: 9105              	DW	NEW
                        ;
                        ; RESERVED WORD TOKEN VALUES
                        ;
0080:                   ZEND	EQU	080H		; END
0081:                   ZFOR	EQU	081H		; FOR
0083:                   ZDATA	EQU	083H		; DATA
0088:                   ZGOTO	EQU	088H		; GOTO
008C:                   ZGOSUB	EQU	08CH		; GOSUB
008E:                   ZREM	EQU	08EH		; REM
009E:                   ZPRINT	EQU	09EH		; PRINT
00A4:                   ZNEW	EQU	0A4H		; NEW
                        ;
00A5:                   ZTAB	EQU	0A5H		; TAB
00A6:                   ZTO	EQU	0A6H		; TO
00A7:                   ZFN	EQU	0A7H		; FN
00A8:                   ZSPC	EQU	0A8H		; SPC
00A9:                   ZTHEN	EQU	0A9H		; THEN
00AA:                   ZNOT	EQU	0AAH		; NOT
00AB:                   ZSTEP	EQU	0ABH		; STEP
                        ;
00AC:                   ZPLUS	EQU	0ACH		; +
00AD:                   ZMINUS	EQU	0ADH		; -
00AE:                   ZTIMES	EQU	0AEH		; *
00AF:                   ZDIV	EQU	0AFH		; /
00B2:                   ZOR	EQU	0B2H		; OR
00B3:                   ZGTR	EQU	0B3H		; >
00B4:                   ZEQUAL	EQU	0B4H		; M
00B5:                   ZLTH	EQU	0B5H		; <
00B6:                   ZSGN	EQU	0B6H		; SGN
00C7:                   ZPOINT	EQU	0C7H		; POINT
00CF:                   ZLEFT	EQU	0CDH +2		; LEFT$
                        ;
                        ; ARITHMETIC PRECEDENCE TABLE
                        ;
0377: 79                PRITAB: DB	79H		; Precedence value
0378: AD18              	DW	PADD		; FPREG = <last> + FPREG
                        ;
037A: 79                	DB	79H		; Precedence value
037B: E114              	DW	PSUB		; FPREG = <last> - FPREG
                        ;
037D: 7C                	DB	7CH		; Precedence value
037E: 1F16              	DW	MULT		; PPREG = <last> * FPREG
                        ;
0380: 7C                	DB	7CH		; Precedence value
0381: 8016              	DW	DIV		; FPREG = <last> / FPREG
                        ;
0383: 7F                	DB	7FH		; Precedence value
0384: CE19              	DW	POWER		; FPREG = <last> ^ FPREG
                        ;
0386: 50                	DB	50H		; Precedence value
0387: 940E              	DW	PAND		; FPREG = <last> AND FPREG
                        ;
0389: 46                	DB	46H		; Precedence value
038A: 930E              	DW	POR		; FPREG = <last> OR FPREG
                        ;
                        ; BASIC ERROR CODE LIST
                        ;
038C: 4E46              ERRORS: DB	"NF"		; NEXT without FOR
038E: 534E              	DB	"SN"		; Syntax error
0390: 5247              	DB	"RG"		; RETURN without GOSUB
0392: 4F44              	DB	"OD"		; Out of DATA
0394: 4643              	DB	"FC"		; Illegal function call
0396: 4F56              	DB	"OV"		; Overflow error
0398: 4F4D              	DB	"OM"		; Out of memory
039A: 554C              	DB	"UL"		; Undefined line
039C: 4253              	DB	"BS"		; Bad subscript
039E: 4444              	DB	"DD"		; Re-DIMensioned array
03A0: 2F30              	DB	"/0"		; Division by zero
03A2: 4944              	DB	"ID"		; Illegal direct
03A4: 544D              	DB	"TM"		; Type mis-match
03A6: 4F53              	DB	"OS"		; Out of string space
03A8: 4C53              	DB	"LS"		; String too long
03AA: 5354              	DB	"ST"		; String formula too complex
03AC: 434E              	DB	"CN"		; Can't CONTinue
03AE: 5546              	DB	"UF"		; Undefined FN function
03B0: 4D4F              	DB	"MO"		; Missing operand
03B2: 4858              	DB	"HX"		; HEX error
03B4: 424E              	DB	"BN"		; BIN error
                        ;
                        ; INITIALISATION TABLE -------------------------------------------------------
                        ;
03B6: C34C01   [10]     INITAB: JP	WARMST		; Warm start jump
03B9: C3A409   [20]     	JP	FCERR		; "USR (X)" jump (Set to Error)
03BC: D300     [31]     	OUT	(0),A		; "OUT p,n" skeleton
03BE: C9       [41]     	RET
03BF: D600     [48]     	SUB	0		; Division support routine
03C1: 6F       [52]     	LD	L,A
03C2: 7C       [56]     	LD	A,H
03C3: DE00     [63]     	SBC	A,0
03C5: 67       [67]     	LD	H,A
03C6: 78       [71]     	LD	A,B
03C7: DE00     [78]     	SBC	A,0
03C9: 47       [82]     	LD	B,A
03CA: 3E00     [89]     	LD	A,0
03CC: C9       [99]     	RET
03CD: 000000            	DB	0,0,0			; Random number seed table used by RND
03D0: 354ACA99          	DB	035H,04AH,0CAH,099H	;-2.65145E+07
03D4: 391C7698          	DB	039H,01CH,076H,098H	; 1.61291E+07
03D8: 2295B398          	DB	022H,095H,0B3H,098H	;-1.17691E+07
03DC: 0ADD4798          	DB	00AH,0DDH,047H,098H	; 1.30983E+07
03E0: 53D19999          	DB	053H,0D1H,099H,099H	;-2-01612E+07
03E4: 0A1A9F98          	DB	00AH,01AH,09FH,098H	;-1.04269E+07
03E8: 65BCCD98          	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
03EC: D6773E98          	DB	0D6H,077H,03EH,098H	; 1.24825E+07
03F0: 52C74F80          	DB	052H,0C7H,04FH,080H	; Last random number
03F4: DB00     [110]    	IN	A,(0)		; INP (x) skeleton
03F6: C9       [120]    	RET
03F7: 01                	DB	1		; POS (x) number (1)
03F8: FF                	DB	255		; Terminal width (255 = no auto CRLF)
03F9: 1C                	DB	28		; Width for commas (3 columns)
03FA: 00                	DB	0		; No nulls after input bytes
03FB: 00                	DB	0		; Output enabled (^O off)
03FC: 1400              	DW	20		; Initial lines counter
03FE: 1400              	DW	20		; Initial lines number
0400: 0000              	DW	0		; Array load/save check sum
0402: 00                	DB	0		; Break not by NMI
0403: 00                	DB	0		; Break flag
0404: C3CA06   [130]    	JP	TTYLIN		; Input reflection (set to TTY)
0407: C30300   [140]    	JP	RST00		; POINT reflection unused
040A: C30300   [150]    	JP	RST00		; SET reflection
040D: C30300   [160]    	JP	RST00			; RESET reflection
0410: A281              	DW	STLOOK		; Temp string space
0412: FEFF              	DW	-2		; Current line number (cold)
0414: 3F81              	DW	PROGST+1	; Start of program text
0416:                   INITBE:			 
                        ;
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        ;
0416: 20457272          ERRMSG: DB	" Error",0
041A: 6F7200            
041D: 20696E20          INMSG:	DB	" in ",0
0421: 00                
0421:                   ZERBYT	EQU	$-1		; A zero byte
0422: 4F6B0D0A          OKMSG:	DB	"Ok",CR,LF,0,0
0426: 0000              
0428: 42726561          BRKMSG: DB	"Break",0
042C: 6B00              
                        ;
042E: 210400   [10]     BAKSTK: LD	HL,4		; Look for "FOR" block with
0431: 39       [21]     	ADD	HL,SP		; same index as specified
0432: 7E       [ 7]     LOKFOR: LD	A,(HL)		; Get block ID
0433: 23       [13]     	INC	HL		; Point to index address
0434: FE81     [20]     	CP	ZFOR		; Is it a "FOR" token
0436: C0       [25|31]  	RET	NZ		; No - exit
0437: 4E       [32]     	LD	C,(HL)		; BC = Address of "FOR" index
0438: 23       [38]     	INC	HL
0439: 46       [45]     	LD	B,(HL)
043A: 23       [51]     	INC	HL		; Point to sign of STEP
043B: E5       [62]     	PUSH	HL		; Save pointer to sign
043C: 69       [66]     	LD	L,C		; HL = address of "FOR" index
043D: 60       [70]     	LD	H,B
043E: 7A       [74]     	LD	A,D		; See if an index was specified
043F: B3       [78]     	OR	E		; DE = 0 if no index specified
0440: EB       [82]     	EX	DE,HL		; Specified index into HL
0441: CA4804   [92|92]  	JP	Z,INDFND	; Skip if no index given
0444: EB       [96]     	EX	DE,HL		; Index back into DE
0445: CD4D07   [113]    	CALL	CPDEHL		; Compare index with one given
0448: 010D00   [10]     INDFND: LD	BC,16-3		; Offset to next block
044B: E1       [20]     	POP	HL		; Restore pointer to sign
044C: C8       [25|31]  	RET	Z		; Return if block found
044D: 09       [36]     	ADD	HL,BC		; Point to next block
044E: C33204   [46]     	JP	LOKFOR		; Keep on looking
                        ;
0451: CD6B04   [17]     MOVUP:	CALL	ENFMEM		; See if enough memory
0454: C5       [11]     MOVSTR: PUSH	BC		; Save end of source
0455: E3       [30]     	EX	(SP),HL		; Swap source and dest" end
0456: C1       [40]     	POP	BC		; Get end of destination
0457: CD4D07   [17]     MOVLP:	CALL	CPDEHL		; See if list moved
045A: 7E       [24]     	LD	A,(HL)		; Get byte
045B: 02       [31]     	LD	(BC),A		; Move it
045C: C8       [36|42]  	RET	Z		; Exit if all done
045D: 0B       [42]     	DEC	BC		; Next byte to move to
045E: 2B       [48]     	DEC	HL		; Next byte to move
045F: C35704   [58]     	JP	MOVLP		; Loop until all bytes moved
                        ;
0462: E5       [11]     CHKSTK: PUSH	HL		; Save code string address
0463: 2A1F81   [27]     	LD	HL,(ARREND)	; Lowest free memory
0466: 0600     [34]     	LD	B,0		; BC = Number of levels to test
0468: 09       [45]     	ADD	HL,BC		; 2 Bytes for each level
0469: 09       [56]     	ADD	HL,BC
046A: 3E                	DB	3EH		; Skip "PUSH HL"
046B: E5       [11]     ENFMEM: PUSH	HL		; Save code string address
046C: 3ED0     [18]     	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
046E: 95       [22]     	SUB	L
046F: 6F       [26]     	LD	L,A
0470: 3EFF     [33]     	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
0472: 9C       [37]     	SBC	A,H
0473: DA7A04   [47|47]  	JP	C,OMERR		; Not enough - ?OM Error
0476: 67       [51]     	LD	H,A
0477: 39       [62]     	ADD	HL,SP		; Test if stack is overflowed
0478: E1       [72]     	POP	HL		; Restore code string address
0479: D8       [77|83]  	RET	C		; Return if enough mmory
047A: 1E0C     [ 7]     OMERR:	LD	E,OM		; ?OM Error
047C: C39904   [17]     	JP	ERROR
                        ;
047F: 2A0E81   [16]     DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
0482: 22A180   [32]     	LD	(LINEAT),HL	; Save as current line
0485: 1E02     [ 7]     SNERR:	LD	E,SN		; ?SN Error
0487: 01                	DB	01H		; Skip "LD E,DZ"
0488: 1E14     [ 7]     DZERR:	LD	E,DZ		; ?/0 Error
048A: 01                	DB	01H		; Skip "LD E,NF"
048B: 1E00     [ 7]     NFERR:	LD	E,NF		; ?NF Error
048D: 01                	DB	01H		; Skip "LD E,RD"
048E: 1E12     [ 7]     DDERR:	LD	E,RD		; ?DD Error
0490: 01                	DB	01H		; Skip "LD E,UF"
0491: 1E22     [ 7]     UFERR:	LD	E,UF		; ?UF Error
0493: 01                	DB	01H		; Skip "LD E,OV
0494: 1E0A     [ 7]     OVERR:	LD	E,OV		; ?OV Error
0496: 01                	DB	01H		; Skip "LD E,TM"
0497: 1E18     [ 7]     TMERR:	LD	E,TM		; ?TM Error
                        ;
0499: CDB705   [17]     ERROR:	CALL	CLREG		; Clear registers and stack
049C: 328A80   [30]     	LD	(CTLOFG),A	; Enable output (A is 0)
049F: CD780B   [47]     	CALL	STTLIN		; Start new line
04A2: 218C03   [57]     	LD	HL,ERRORS	; Point to error codes
04A5: 57       [61]     	LD	D,A		; D = 0 (A is 0)
04A6: 3E3F     [68]     	LD	A,'?'
04A8: CD5E07   [85]     	CALL	OUTC		; Output '?'
04AB: 19       [96]     	ADD	HL,DE		; Offset to correct error code
04AC: 7E       [103]    	LD	A,(HL)		; First character
04AD: CD5E07   [120]    	CALL	OUTC		; Output it
04B0: CDDD08   [137]    	CALL	GETCHR		; Get next character
04B3: CD5E07   [154]    	CALL	OUTC		; Output it
04B6: 211604   [164]    	LD	HL,ERRMSG	; "Error" message
04B9: CD2312   [17]     ERRIN:	CALL	PRS		; Output message
04BC: 2AA180   [33]     	LD	HL,(LINEAT)	; Get line of error
04BF: 11FEFF   [43]     	LD	DE,-2		; Cold start error if -2
04C2: CD4D07   [60]     	CALL	CPDEHL		; See if cold start error
04C5: CADE00   [70|70]  	JP	Z,CSTART	; Cold start error - Restart
04C8: 7C       [74]     	LD	A,H		; Was it a direct error?
04C9: A5       [78]     	AND	L		; Line = -1 if direct error
04CA: 3C       [82]     	INC	A
04CB: C4BE18   [92|99]  	CALL	NZ,LINEIN	; No - output line of error
04CE: 3E                	DB	3EH		; Skip "POP BC"
04CF: C1       [10]     POPNOK: POP	BC		; Drop address in input buffer
                        ;
04D0: AF       [ 4]     PRNTOK: XOR	A		; Output "Ok" and get command
04D1: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
04D4: CD780B   [34]     	CALL	STTLIN		; Start new line
04D7: 212204   [44]     	LD	HL,OKMSG	; "Ok" message
04DA: CD2312   [61]     	CALL	PRS		; Output "Ok"
04DD: 21FFFF   [10]     GETCMD: LD	HL,-1		; Flag direct mode
04E0: 22A180   [26]     	LD	(LINEAT),HL	; Save as current line
04E3: CDCA06   [43]     	CALL	GETLIN		; Get an input line
04E6: DADD04   [53|53]  	JP	C,GETCMD	; Get line again if break
04E9: CDDD08   [70]     	CALL	GETCHR		; Get first character
04EC: 3C       [74]     	INC	A		; Test if end of line
04ED: 3D       [78]     	DEC	A		; Without affecting Carry
04EE: CADD04   [88|88]  	JP	Z,GETCMD	; Nothing entered - Get another
04F1: F5       [99]     	PUSH	AF		; Save Carry status
04F2: CDA909   [116]    	CALL	ATOH		; Get line number into DE
04F5: D5       [127]    	PUSH	DE		; Save line number
04F6: CDE105   [144]    	CALL	CRUNCH		; Tokenise rest of line
04F9: 47       [148]    	LD	B,A		; Length of tokenised line
04FA: D1       [158]    	POP	DE		; Restore line number
04FB: F1       [168]    	POP	AF		; Restore Carry
04FC: D2BD08   [178|178]	JP	NC,EXCUTE	; No line number - Direct mode
04FF: D5       [189]    	PUSH	DE		; Save line number
0500: C5       [200]    	PUSH	BC		; Save length of tokenised line
0501: AF       [204]    	XOR	A
0502: 321181   [217]    	LD	(LSTBIN),A	; Clear last byte input
0505: CDDD08   [234]    	CALL	GETCHR		; Get next character
0508: B7       [238]    	OR	A		; Set flags
0509: F5       [249]    	PUSH	AF		; And save them
050A: CD7105   [266]    	CALL	SRCHLN		; Search for line number in DE
050D: DA1605   [276|276]	JP	C,LINFND	; Jump if line found
0510: F1       [286]    	POP	AF		; Get status
0511: F5       [297]    	PUSH	AF		; And re-save
0512: CA4A0A   [307|307]	JP	Z,ULERR	; Nothing after number - Error
0515: B7       [311]    	OR	A		; Clear Carry
0516: C5       [11]     LINFND: PUSH	BC		; Save address of line in prog
0517: D22D05   [21|21]  	JP	NC,INEWLN	; Line not found - Insert new
051A: EB       [25]     	EX	DE,HL		; Next line address in DE
051B: 2A1B81   [41]     	LD	HL,(PROGND)	; End of program
051E: 1A       [ 7]     SFTPRG: LD	A,(DE)		; Shift rest of program down
051F: 02       [14]     	LD	(BC),A
0520: 03       [20]     	INC	BC		; Next destination
0521: 13       [26]     	INC	DE		; Next source
0522: CD4D07   [43]     	CALL	CPDEHL		; All done?
0525: C21E05   [53|53]  	JP	NZ,SFTPRG	; More to do
0528: 60       [57]     	LD	H,B		; HL - New end of program
0529: 69       [61]     	LD	L,C
052A: 221B81   [77]     	LD	(PROGND),HL	; Update end of program
                        ;
052D: D1       [10]     INEWLN: POP	DE		; Get address of line,
052E: F1       [20]     	POP	AF		; Get status
052F: CA5405   [30|30]  	JP	Z,SETPTR	; No text - Set up pointers
0532: 2A1B81   [46]     	LD	HL,(PROGND)	; Get end of program
0535: E3       [65]     	EX	(SP),HL		; Get length of input line
0536: C1       [75]     	POP	BC		; End of program to BC
0537: 09       [86]     	ADD	HL,BC		; Find new end
0538: E5       [97]     	PUSH	HL		; Save new end
0539: CD5104   [114]    	CALL	MOVUP		; Make space for line
053C: E1       [124]    	POP	HL		; Restore new end
053D: 221B81   [140]    	LD	(PROGND),HL	; Update end of program pointer
0540: EB       [144]    	EX	DE,HL		; Get line to move up in HL
0541: 74       [151]    	LD	(HL),H		; Save MSB
0542: D1       [161]    	POP	DE		; Get new line number
0543: 23       [167]    	INC	HL		; Skip pointer
0544: 23       [173]    	INC	HL
0545: 73       [180]    	LD	(HL),E		; Save LSB of line number
0546: 23       [186]    	INC	HL
0547: 72       [193]    	LD	(HL),D		; Save MSB of line number
0548: 23       [199]    	INC	HL		; To first byte in line
0549: 11A680   [209]    	LD	DE,BUFFER	; Copy buffer to program
054C: 1A       [ 7]     MOVBUF: LD	A,(DE)		; Get source
054D: 77       [14]     	LD	(HL),A		; Save destinations
054E: 23       [20]     	INC	HL		; Next source
054F: 13       [26]     	INC	DE		; Next destination
0550: B7       [30]     	OR	A		; Done?
0551: C24C05   [40|40]  	JP	NZ,MOVBUF	; No - Repeat
0554: CD9D05   [17]     SETPTR: CALL	RUNFST		; Set line pointers
0557: 23       [23]     	INC	HL		; To LSB of pointer
0558: EB       [27]     	EX	DE,HL		; Address to DE
0559: 62       [ 4]     PTRLP:	LD	H,D		; Address to HL
055A: 6B       [ 8]     	LD	L,E
055B: 7E       [15]     	LD	A,(HL)		; Get LSB of pointer
055C: 23       [21]     	INC	HL		; To MSB of pointer
055D: B6       [28]     	OR	(HL)		; Compare with MSB pointer
055E: CADD04   [38|38]  	JP	Z,GETCMD	; Get command line if end
0561: 23       [44]     	INC	HL		; To LSB of line number
0562: 23       [50]     	INC	HL		; Skip line number
0563: 23       [56]     	INC	HL		; Point to first byte in line
0564: AF       [60]     	XOR	A		; Looking for 00 byte
0565: BE       [ 7]     FNDEND: CP	(HL)		; Found end of line?
0566: 23       [13]     	INC	HL		; Move to next byte
0567: C26505   [23|23]  	JP	NZ,FNDEND	; No - Keep looking
056A: EB       [27]     	EX	DE,HL		; Next line address to HL
056B: 73       [34]     	LD	(HL),E		; Save LSB of pointer
056C: 23       [40]     	INC	HL
056D: 72       [47]     	LD	(HL),D		; Save MSB of pointer
056E: C35905   [57]     	JP	PTRLP		; Do next line
                        ;
0571: 2AA380   [16]     SRCHLN: LD	HL,(BASTXT)	; Start of program text
0574: 44       [ 4]     SRCHLP: LD	B,H		; BC = Address to look at
0575: 4D       [ 8]     	LD	C,L
0576: 7E       [15]     	LD	A,(HL)		; Get address of next line
0577: 23       [21]     	INC	HL
0578: B6       [28]     	OR	(HL)		; End of program found?
0579: 2B       [34]     	DEC	HL
057A: C8       [39|45]  	RET	Z		; Yes - Line not found
057B: 23       [45]     	INC	HL
057C: 23       [51]     	INC	HL
057D: 7E       [58]     	LD	A,(HL)		; Get LSB of line number
057E: 23       [64]     	INC	HL
057F: 66       [71]     	LD	H,(HL)		; Get MSB of line number
0580: 6F       [75]     	LD	L,A
0581: CD4D07   [92]     	CALL	CPDEHL		; Compare with line in DE
0584: 60       [96]     	LD	H,B		; HL = Start of this line
0585: 69       [100]    	LD	L,C
0586: 7E       [107]    	LD	A,(HL)		; Get LSB of next line address
0587: 23       [113]    	INC	HL
0588: 66       [120]    	LD	H,(HL)		; Get MSB of next line address
0589: 6F       [124]    	LD	L,A		; Next line to HL
058A: 3F       [128]    	CCF
058B: C8       [133|139]	RET	Z		; Lines found - Exit
058C: 3F       [137]    	CCF
058D: D0       [142|148]	RET	NC		; Line not found,at line after
058E: C37405   [152]    	JP	SRCHLP		; Keep looking
                        ;
0591: C0       [ 5|11]  NEW:	RET	NZ		; Return if any more on line
0592: 2AA380   [16]     CLRPTR: LD	HL,(BASTXT)	; Point to start of program
0595: AF       [20]     	XOR	A		; Set program area to empty
0596: 77       [27]     	LD	(HL),A		; Save LSB = 00
0597: 23       [33]     	INC	HL
0598: 77       [40]     	LD	(HL),A		; Save MSB = 00
0599: 23       [46]     	INC	HL
059A: 221B81   [62]     	LD	(PROGND),HL	; Set program end
                        ;
059D: 2AA380   [16]     RUNFST: LD	HL,(BASTXT)	; Clear all variables
05A0: 2B       [22]     	DEC	HL
                        ;
05A1: 221381   [16]     INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
05A4: 2AF480   [32]     	LD	HL,(LSTRAM)	; Get end of RAM
05A7: 220881   [48]     	LD	(STRBOT),HL	; Clear string space
05AA: AF       [52]     	XOR	A
05AB: CDED08   [69]     	CALL	RESTOR		; Reset DATA pointers
05AE: 2A1B81   [85]     	LD	HL,(PROGND)	; Get end of program
05B1: 221D81   [101]    	LD	(VAREND),HL	; Clear variables
05B4: 221F81   [117]    	LD	(ARREND),HL	; Clear arrays
                        ;
05B7: C1       [10]     CLREG:	POP	BC		; Save return address
05B8: 2A9F80   [26]     	LD	HL,(STRSPC)	; Get end of working RAN
05BB: F9       [32]     	LD	SP,HL		; Set stack
05BC: 21F880   [42]     	LD	HL,TMSTPL	; Temporary string pool
05BF: 22F680   [58]     	LD	(TMSTPT),HL	; Reset temporary string ptr
05C2: AF       [62]     	XOR	A		; A = 00
05C3: 6F       [66]     	LD	L,A		; HL = 0000
05C4: 67       [70]     	LD	H,A
05C5: 221981   [86]     	LD	(CONTAD),HL	; No CONTinue
05C8: 321081   [99]     	LD	(FORFLG),A	; Clear FOR flag
05CB: 222381   [115]    	LD	(FNRGNM),HL	; Clear FN argument
05CE: E5       [126]    	PUSH	HL		; HL = 0000
05CF: C5       [137]    	PUSH	BC		; Put back return
05D0: 2A1381   [16]     DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
05D3: C9       [26]     	RET			; Return to execution driver
                        ;
05D4: 3E3F     [ 7]     PROMPT: LD	A,'?'		; '?'
05D6: CD5E07   [24]     	CALL	OUTC		; Output character
05D9: 3E20     [31]     	LD	A,' '		; Space
05DB: CD5E07   [48]     	CALL	OUTC		; Output character
05DE: C39380   [58]     	JP	RINPUT		; Get input line
                        ;
05E1: AF       [ 4]     CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
05E2: 32F380   [17]     	LD	(DATFLG),A	; Reset literal flag
05E5: 0E05     [24]     	LD	C,2+3		; 2 byte number and 3 nulls
05E7: 11A680   [34]     	LD	DE,BUFFER	; Start of input buffer
05EA: 7E       [ 7]     CRNCLP: LD	A,(HL)		; Get byte
05EB: FE20     [14]     	CP	' '		; Is it a space?
05ED: CA6906   [24|24]  	JP	Z,MOVDIR	; Yes - Copy direct
05F0: 47       [28]     	LD	B,A		; Save character
05F1: FE22     [35]     	CP	'"'		; Is it a quote?
05F3: CA8906   [45|45]  	JP	Z,CPYLIT	; Yes - Copy literal string
05F6: B7       [49]     	OR	A		; Is it end of buffer?
05F7: CA9006   [59|59]  	JP	Z,ENDBUF	; Yes - End buffer
05FA: 3AF380   [72]     	LD	A,(DATFLG)	; Get data type
05FD: B7       [76]     	OR	A		; Literal?
05FE: 7E       [83]     	LD	A,(HL)		; Get byte to copy
05FF: C26906   [93|93]  	JP	NZ,MOVDIR	; Literal - Copy direct
0602: FE3F     [100]    	CP	'?'		; Is it '?' short for PRINT
0604: 3E9E     [107]    	LD	A,ZPRINT	; "PRINT" token
0606: CA6906   [117|117]	JP	Z,MOVDIR	; Yes - replace it
0609: 7E       [124]    	LD	A,(HL)		; Get byte again
060A: FE30     [131]    	CP	'0'		; Is it less than '0'
060C: DA1406   [141|141]	JP	C,FNDWRD	; Yes - Look for reserved words
060F: FE3C     [148]    	CP	60		; ";"+1; Is it "0123456789:;" ?
0611: DA6906   [158|158]	JP	C,MOVDIR	; Yes - copy it direct
0614: D5       [11]     FNDWRD: PUSH	DE		; Look for reserved words
0615: 110D02   [21]     	LD	DE,WORDS-1	; Point to table
0618: C5       [32]     	PUSH	BC		; Save count
0619: 016506   [42]     	LD	BC,RETNAD	; Where to return to
061C: C5       [53]     	PUSH	BC		; Save return address
061D: 067F     [60]     	LD	B,ZEND-1	; First token value -1
061F: 7E       [67]     	LD	A,(HL)		; Get byte
0620: FE61     [74]     	CP	'a'		; Less than 'a' ?
0622: DA2D06   [84|84]  	JP	C,SEARCH	; Yes - search for words
0625: FE7B     [91]     	CP	'z'+1		; Greater than 'z' ?
0627: D22D06   [101|101]	JP	NC,SEARCH	; Yes - search for words
062A: E65F     [108]    	AND	01011111B	; Force upper case
062C: 77       [115]    	LD	(HL),A		; Replace byte
062D: 4E       [ 7]     SEARCH: LD	C,(HL)		; Search for a word
062E: EB       [11]     	EX	DE,HL
062F: 23       [ 6]     GETNXT: INC	HL		; Get next reserved word
0630: B6       [13]     	OR	(HL)		; Start of word?
0631: F22F06   [23|23]  	JP	P,GETNXT	; No - move on
0634: 04       [27]     	INC	B		; Increment token value
0635: 7E       [34]     	LD	A, (HL)		; Get byte from table
0636: E67F     [41]     	AND	01111111B	; Strip bit 7
0638: C8       [46|52]  	RET	Z		; Return if end of list
0639: B9       [50]     	CP	C		; Same character as in buffer?
063A: C22F06   [60|60]  	JP	NZ,GETNXT	; No - get next word
063D: EB       [64]     	EX	DE,HL
063E: E5       [75]     	PUSH	HL		; Save start of word
                        ;
063F: 13       [ 6]     NXTBYT: INC	DE		; Look through rest of word
0640: 1A       [13]     	LD	A,(DE)		; Get byte from table
0641: B7       [17]     	OR	A		; End of word ?
0642: FA6106   [27|27]  	JP	M,MATCH		; Yes - Match found
0645: 4F       [31]     	LD	C,A		; Save it
0646: 78       [35]     	LD	A,B		; Get token value
0647: FE88     [42]     	CP	ZGOTO		; Is it "GOTO" token ?
0649: C25006   [52|52]  	JP	NZ,NOSPC	; No - Don't allow spaces
064C: CDDD08   [69]     	CALL	GETCHR		; Get next character
064F: 2B       [75]     	DEC	HL		; Cancel increment from GETCHR
0650: 23       [ 6]     NOSPC:	INC	HL		; Next byte
0651: 7E       [13]     	LD	A,(HL)		; Get byte
0652: FE61     [20]     	CP	'a'		; Less than 'a' ?
0654: DA5906   [30|30]  	JP	C,NOCHNG	; Yes - don't change
0657: E65F     [37]     	AND	01011111B	; Make upper case
0659: B9       [ 4]     NOCHNG: CP	C		; Same as in buffer ?
065A: CA3F06   [14|14]  	JP	Z,NXTBYT	; Yes - keep testing
065D: E1       [24]     	POP	HL		; Get back start of word
065E: C32D06   [34]     	JP	SEARCH		; Look at next word
                        ;
0661: 48       [ 4]     MATCH:	LD	C,B		; Word found - Save token value
0662: F1       [14]     	POP	AF		; Throw away return
0663: EB       [18]     	EX	DE,HL
0664: C9       [28]     	RET			; Return to "RETNAD"
0665: EB       [ 4]     RETNAD: EX	DE,HL		; Get address in string
0666: 79       [ 8]     	LD	A,C		; Get token value
0667: C1       [18]     	POP	BC		; Restore buffer length
0668: D1       [28]     	POP	DE		; Get destination address
0669: 23       [ 6]     MOVDIR: INC	HL		; Next source in buffer
066A: 12       [13]     	LD	(DE),A		; Put byte in buffer
066B: 13       [19]     	INC	DE		; Move up buffer
066C: 0C       [23]     	INC	C		; Increment length of buffer
066D: D63A     [30]     	SUB	':'		; End of statement?
066F: CA7706   [40|40]  	JP	Z,SETLIT	; Jump if multi-statement line
0672: FE49     [47]     	CP	ZDATA-3AH	; Is it DATA statement ?
0674: C27A06   [57|57]  	JP	NZ,TSTREM	; No - see if REM
0677: 32F380   [13]     SETLIT: LD	(DATFLG),A	; Set literal flag
067A: D654     [ 7]     TSTREM: SUB	ZREM-3AH	; Is it REM?
067C: C2EA05   [17|17]  	JP	NZ,CRNCLP	; No - Leave flag
067F: 47       [21]     	LD	B,A		; Copy rest of buffer
0680: 7E       [ 7]     NXTCHR: LD	A,(HL)		; Get byte
0681: B7       [11]     	OR	A		; End of line ?
0682: CA9006   [21|21]  	JP	Z,ENDBUF	; Yes - Terminate buffer
0685: B8       [25]     	CP	B		; End of statement ?
0686: CA6906   [35|35]  	JP	Z,MOVDIR	; Yes - Get next one
0689: 23       [ 6]     CPYLIT: INC	HL		; Move up source string
068A: 12       [13]     	LD	(DE),A		; Save in destination
068B: 0C       [17]     	INC	C		; Increment length
068C: 13       [23]     	INC	DE		; Move up destination
068D: C38006   [33]     	JP	NXTCHR		; Repeat
                        ;
0690: 21A580   [10]     ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
0693: 12       [17]     	LD	(DE),A		; Mark end of buffer (A = 00)
0694: 13       [23]     	INC	DE
0695: 12       [30]     	LD	(DE),A		; A = 00
0696: 13       [36]     	INC	DE
0697: 12       [43]     	LD	(DE),A		; A = 00
0698: C9       [53]     	RET
                        ;
0699: 3A8980   [13]     DODEL:	LD	A,(NULFLG)	; Get null flag status
069C: B7       [17]     	OR	A		; Is it zero?
069D: 3E00     [24]     	LD	A,0		; Zero A - Leave flags
069F: 328980   [37]     	LD	(NULFLG),A	; Zero null flag
06A2: C2AD06   [47|47]  	JP	NZ,ECHDEL	; Set - Echo it
06A5: 05       [51]     	DEC	B		; Decrement length
06A6: CACA06   [61|61]  	JP	Z,GETLIN	; Get line again if empty
06A9: CD5E07   [78]     	CALL	OUTC		; Output null character
06AC: 3E                	DB	3EH		; Skip "DEC B"
06AD: 05       [ 4]     ECHDEL: DEC	B		; Count bytes in buffer
06AE: 2B       [10]     	DEC	HL		; Back space buffer
06AF: CAC106   [20|20]  	JP	Z,OTKLN		; No buffer - Try again
06B2: 7E       [27]     	LD	A,(HL)		; Get deleted byte
06B3: CD5E07   [44]     	CALL	OUTC		; Echo it
06B6: C3D306   [54]     	JP	MORINP		; Get more input
                        ;
06B9: 05       [ 4]     DELCHR: DEC	B		; Count bytes in buffer
06BA: 2B       [10]     	DEC	HL		; Back space buffer
06BB: CD5E07   [27]     	CALL	OUTC		; Output character in A
06BE: C2D306   [37|37]  	JP	NZ,MORINP	; Not end - Get more
06C1: CD5E07   [17]     OTKLN:	CALL	OUTC		; Output character in A
06C4: CD850B   [17]     KILIN:	CALL	PRCRLF		; Output CRLF
06C7: C3CA06   [27]     	JP	TTYLIN		; Get line again
                        ;
06CA:                   GETLIN:
06CA: 21A680   [10]     TTYLIN: LD	HL,BUFFER	; Get a line by character
06CD: 0601     [17]     	LD	B,1		; Set buffer as empty
06CF: AF       [21]     	XOR	A
06D0: 328980   [34]     	LD	(NULFLG),A	; Clear null flag
06D3: CD8807   [17]     MORINP: CALL	CLOTST		; Get character and test ^O
06D6: 4F       [21]     	LD	C,A		; Save character in C
06D7: FE7F     [28]     	CP	DEL		; Delete character?
06D9: CA9906   [38|38]  	JP	Z,DODEL	; Yes - Process it
06DC: 3A8980   [51]     	LD	A,(NULFLG)	; Get null flag
06DF: B7       [55]     	OR	A		; Test null flag status
06E0: CAEC06   [65|65]  	JP	Z,PROCES	; Reset - Process character
06E3: 3E00     [72]     	LD	A,0		; Set a null
06E5: CD5E07   [89]     	CALL	OUTC		; Output null
06E8: AF       [93]     	XOR	A		; Clear A
06E9: 328980   [106]    	LD	(NULFLG),A	; Reset null flag
06EC: 79       [ 4]     PROCES: LD	A,C		; Get character
06ED: FE07     [11]     	CP	CTRLG		; Bell?
06EF: CA3007   [21|21]  	JP	Z,PUTCTL	; Yes - Save it
06F2: FE03     [28]     	CP	CTRLC		; Is it control "C"?
06F4: CC850B   [38|45]  	CALL	Z,PRCRLF	; Yes - Output CRLF
06F7: 37       [42]     	SCF			; Flag break
06F8: C8       [47|53]  	RET	Z		; Return if control "C"
06F9: FE0D     [54]     	CP	CR		; Is it enter?
06FB: CA800B   [64|64]  	JP	Z,ENDINP	; Yes - Terminate input
06FE: FE15     [71]     	CP	CTRLU		; Is it control "U"?
0700: CAC406   [81|81]  	JP	Z,KILIN		; Yes - Get another line
0703: FE40     [88]     	CP	'@'		; Is it "kill line"?
0705: CAC106   [98|98]  	JP	Z,OTKLN		; Yes - Kill line
0708: FE5F     [105]    	CP	'_'		; Is it delete?
070A: CAB906   [115|115]	JP	Z,DELCHR	; Yes - Delete character
070D: FE08     [122]    	CP	BKSP		; Is it backspace?
070F: CAB906   [132|132]	JP	Z,DELCHR	; Yes - Delete character
0712: FE12     [139]    	CP	CTRLR		; Is it control "R"?
0714: C22B07   [149|149]	JP	NZ,PUTBUF	; No - Put in buffer
0717: C5       [160]    	PUSH	BC		; Save buffer length
0718: D5       [171]    	PUSH	DE		; Save DE
0719: E5       [182]    	PUSH	HL		; Save buffer address
071A: 3600     [192]    	LD	(HL),0		; Mark end of buffer
071C: CD2F1D   [209]    	CALL	OUTNCR		; Output and do CRLF
071F: 21A680   [219]    	LD	HL,BUFFER	; Point to buffer start
0722: CD2312   [236]    	CALL	PRS		; Output buffer
0725: E1       [246]    	POP	HL		; Restore buffer address
0726: D1       [256]    	POP	DE		; Restore DE
0727: C1       [266]    	POP	BC		; Restore buffer length
0728: C3D306   [276]    	JP	MORINP		; Get another character
                        ;
072B: FE20     [ 7]     PUTBUF: CP	' '		; Is it a control code?
072D: DAD306   [17|17]  	JP	C,MORINP	; Yes - Ignore
0730: 78       [ 4]     PUTCTL: LD	A,B		; Get number of bytes in buffer
0731: FE49     [11]     	CP	72+1		; Test for line overflow
0733: 3E07     [18]     	LD	A,CTRLG		; Set a bell
0735: D24507   [28|28]  	JP	NC,OUTNBS	; Ring bell if buffer full
0738: 79       [32]     	LD	A,C		; Get character
0739: 71       [39]     	LD	(HL),C		; Save in buffer
073A: 321181   [52]     	LD	(LSTBIN),A	; Save last input byte
073D: 23       [58]     	INC	HL		; Move up buffer
073E: 04       [62]     	INC	B		; Increment length
073F: CD5E07   [17]     OUTIT:	CALL	OUTC		; Output the character entered
0742: C3D306   [27]     	JP	MORINP		; Get another character
                        ;
0745: CD5E07   [17]     OUTNBS: CALL	OUTC		; Output bell and back over it
0748: 3E08     [24]     	LD	A,BKSP		; Set back space
074A: C33F07   [34]     	JP	OUTIT		; Output it and get more
                        ;
074D: 7C       [ 4]     CPDEHL: LD	A,H		; Get H
074E: 92       [ 8]     	SUB	D		; Compare with D
074F: C0       [13|19]  	RET	NZ		; Different - Exit
0750: 7D       [17]     	LD	A,L		; Get L
0751: 93       [21]     	SUB	E		; Compare with E
0752: C9       [31]     	RET			; Return status
                        ;
0753: 7E       [ 7]     CHKSYN: LD	A,(HL)		; Check syntax of character
0754: E3       [26]     	EX	(SP),HL		; Address of test byte
0755: BE       [33]     	CP	(HL)		; Same as in code string?
0756: 23       [39]     	INC	HL		; Return address
0757: E3       [58]     	EX	(SP),HL		; Put it back
0758: CADD08   [68|68]  	JP	Z,GETCHR	; Yes - Get next character
075B: C38504   [78]     	JP	SNERR		; Different - ?SN Error
                        ;
075E: F5       [11]     OUTC:	PUSH	AF		; Save character
075F: 3A8A80   [24]     	LD	A,(CTLOFG)	; Get control "O" flag
0762: B7       [28]     	OR	A		; Is it set?
0763: C25812   [38|38]  	JP	NZ,POPAF	; Yes - don't output
0766: F1       [48]     	POP	AF		; Restore character
0767: C5       [59]     	PUSH	BC		; Save buffer length
0768: F5       [70]     	PUSH	AF		; Save character
0769: FE20     [77]     	CP	' '		; Is it a control code?
076B: DA8207   [87|87]  	JP	C,DINPOS	; Yes - Don't INC POS(X)
076E: 3A8780   [100]    	LD	A,(LWIDTH)	; Get line width
0771: 47       [104]    	LD	B,A		; To B
0772: 3AF080   [117]    	LD	A,(CURPOS)	; Get cursor position
0775: 04       [121]    	INC	B		; Width 255?
0776: CA7E07   [131|131]	JP	Z,INCLEN	; Yes - No width limit
0779: 05       [135]    	DEC	B		; Restore width
077A: B8       [139]    	CP	B		; At end of line?
077B: CC850B   [149|156]	CALL	Z,PRCRLF	; Yes - output CRLF
077E: 3C       [ 4]     INCLEN: INC	A		; Move on one character
077F: 32F080   [17]     	LD	(CURPOS),A	; Save new position
0782: F1       [10]     DINPOS: POP	AF		; Restore character
0783: C1       [20]     	POP	BC		; Restore buffer length
0784: CD1A1D   [37]     	CALL	MONOUT		; Send it
0787: C9       [47]     	RET
                        ;
0788: CDE21B   [17]     CLOTST: CALL	GETINP		; Get input character
078B: E67F     [24]     	AND	01111111B	; Strip bit 7
078D: FE0F     [31]     	CP	CTRLO		; Is it control "O"?
078F: C0       [36|42]  	RET	NZ		; No don't flip flag
0790: 3A8A80   [49]     	LD	A,(CTLOFG)	; Get flag
0793: 2F       [53]     	CPL			; Flip it
0794: 328A80   [66]     	LD	(CTLOFG),A	; Put it back
0797: AF       [70]     	XOR	A		; Null character
0798: C9       [80]     	RET
                        ;
0799: CDA909   [17]     LIST:	CALL	ATOH		; ASCII number to DE
079C: C0       [22|28]  	RET	NZ		; Return if anything extra
079D: C1       [32]     	POP	BC		; Rubbish - Not needed
079E: CD7105   [49]     	CALL	SRCHLN		; Search for line number in DE
07A1: C5       [60]     	PUSH	BC		; Save address of line
07A2: CDEF07   [77]     	CALL	SETLIN		; Set up lines counter
07A5: E1       [10]     LISTLP: POP	HL		; Restore address of line
07A6: 4E       [17]     	LD	C,(HL)		; Get LSB of next line
07A7: 23       [23]     	INC	HL
07A8: 46       [30]     	LD	B,(HL)		; Get MSB of next line
07A9: 23       [36]     	INC	HL
07AA: 78       [40]     	LD	A,B		; BC = 0 (End of program)?
07AB: B1       [44]     	OR	C
07AC: CAD004   [54|54]  	JP	Z,PRNTOK	; Yes - Go to command mode
07AF: CDF807   [71]     	CALL	COUNT		; Count lines
07B2: CD0809   [88]     	CALL	TSTBRK		; Test for break key
07B5: C5       [99]     	PUSH	BC		; Save address of next line
07B6: CD850B   [116]    	CALL	PRCRLF		; Output CRLF
07B9: 5E       [123]    	LD	E,(HL)		; Get LSB of line number
07BA: 23       [129]    	INC	HL
07BB: 56       [136]    	LD	D,(HL)		; Get MSB of line number
07BC: 23       [142]    	INC	HL
07BD: E5       [153]    	PUSH	HL		; Save address of line start
07BE: EB       [157]    	EX	DE,HL		; Line number to HL
07BF: CDC618   [174]    	CALL	PRNTHL		; Output line number in decimal
07C2: 3E20     [181]    	LD	A,' '		; Space after line number
07C4: E1       [191]    	POP	HL		; Restore start of line address
07C5: CD5E07   [17]     LSTLP2: CALL	OUTC		; Output character in A
07C8: 7E       [ 7]     LSTLP3: LD	A,(HL)		; Get next byte in line
07C9: B7       [11]     	OR	A		; End of line?
07CA: 23       [17]     	INC	HL		; To next byte in line
07CB: CAA507   [27|27]  	JP	Z,LISTLP	; Yes - get next line
07CE: F2C507   [37|37]  	JP	P,LSTLP2	; No token - output it
07D1: D67F     [44]     	SUB	ZEND-1		; Find and output word
07D3: 4F       [48]     	LD	C,A		; Token offset+1 to C
07D4: 110E02   [58]     	LD	DE,WORDS	; Reserved word list
07D7: 1A       [ 7]     FNDTOK: LD	A,(DE)		; Get character in list
07D8: 13       [13]     	INC	DE		; Move on to next
07D9: B7       [17]     	OR	A		; Is it start of word?
07DA: F2D707   [27|27]  	JP	P,FNDTOK	; No - Keep looking for word
07DD: 0D       [31]     	DEC	C		; Count words
07DE: C2D707   [41|41]  	JP	NZ,FNDTOK	; Not there - keep looking
07E1: E67F     [ 7]     OUTWRD: AND	01111111B	; Strip bit 7
07E3: CD5E07   [24]     	CALL	OUTC		; Output first character
07E6: 1A       [31]     	LD	A,(DE)		; Get next character
07E7: 13       [37]     	INC	DE		; Move on to next
07E8: B7       [41]     	OR	A		; Is it end of word?
07E9: F2E107   [51|51]  	JP	P,OUTWRD	; No - output the rest
07EC: C3C807   [61]     	JP	LSTLP3		; Next byte in line
                        ;
07EF: E5       [11]     SETLIN: PUSH	HL		; Set up LINES counter
07F0: 2A8D80   [27]     	LD	HL,(LINESN)	; Get LINES number
07F3: 228B80   [43]     	LD	(LINESC),HL	; Save in LINES counter
07F6: E1       [53]     	POP	HL
07F7: C9       [63]     	RET
                        ;
07F8: E5       [11]     COUNT:	PUSH	HL		; Save code string address
07F9: D5       [22]     	PUSH	DE
07FA: 2A8B80   [38]     	LD	HL,(LINESC)	; Get LINES counter
07FD: 11FFFF   [48]     	LD	DE,-1
0800: ED5A     [63]     	ADC	HL,DE		; Decrement
0802: 228B80   [79]     	LD	(LINESC),HL	; Put it back
0805: D1       [89]     	POP	DE
0806: E1       [99]     	POP	HL		; Restore code string address
0807: F0       [104|110]	RET	P		; Return if more lines to go
0808: E5       [115]    	PUSH	HL		; Save code string address
0809: 2A8D80   [131]    	LD	HL,(LINESN)	; Get LINES number
080C: 228B80   [147]    	LD	(LINESC),HL	; Reset LINES counter
080F: CDE21B   [164]    	CALL	GETINP		; Get input character
0812: FE03     [171]    	CP	CTRLC		; Is it control "C"?
0814: CA1B08   [181|181]	JP	Z,RSLNBK	; Yes - Reset LINES and break
0817: E1       [191]    	POP	HL		; Restore code string address
0818: C3F807   [201]    	JP	COUNT		; Keep on counting
                        ;
081B: 2A8D80   [16]     RSLNBK: LD	HL,(LINESN)	; Get LINES number
081E: 228B80   [32]     	LD	(LINESC),HL	; Reset LINES counter
0821: C34F01   [42]     	JP	BRKRET		; Go and output "Break"
                        ;
0824: 3E64     [ 7]     FOR:	LD	A,64H		; Flag "FOR" assignment
0826: 321081   [20]     	LD	(FORFLG),A	; Save "FOR" flag
0829: CD8B0A   [37]     	CALL	LET		; Set up initial index
082C: C1       [47]     	POP	BC		; Drop RETurn address
082D: E5       [58]     	PUSH	HL		; Save code string address
082E: CD740A   [75]     	CALL	DATA		; Get next statement address
0831: 220C81   [91]     	LD	(LOOPST),HL	; Save it for start of loop
0834: 210200   [101]    	LD	HL,2		; Offset for "FOR" block
0837: 39       [112]    	ADD	HL,SP		; Point to it
0838: CD3204   [17]     FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
083B: D1       [27]     	POP	DE		; Get code string address
083C: C25408   [37|37]  	JP	NZ,FORFND	; No nesting found
083F: 09       [48]     	ADD	HL,BC		; Move into "FOR" block
0840: D5       [59]     	PUSH	DE		; Save code string address
0841: 2B       [65]     	DEC	HL
0842: 56       [72]     	LD	D,(HL)		; Get MSB of loop statement
0843: 2B       [78]     	DEC	HL
0844: 5E       [85]     	LD	E,(HL)		; Get LSB of loop statement
0845: 23       [91]     	INC	HL
0846: 23       [97]     	INC	HL
0847: E5       [108]    	PUSH	HL		; Save block address
0848: 2A0C81   [124]    	LD	HL,(LOOPST)	; Get address of loop statement
084B: CD4D07   [141]    	CALL	CPDEHL		; Compare the FOR loops
084E: E1       [151]    	POP	HL		; Restore block address
084F: C23808   [161|161]	JP	NZ,FORSLP	; Different FORs - Find another
0852: D1       [171]    	POP	DE		; Restore code string address
0853: F9       [177]    	LD	SP,HL		; Remove all nested loops
                        ;
0854: EB       [ 4]     FORFND: EX	DE,HL		; Code string address to HL
0855: 0E08     [11]     	LD	C,8
0857: CD6204   [28]     	CALL	CHKSTK		; Check for 8 levels of stack
085A: E5       [39]     	PUSH	HL		; Save code string address
085B: 2A0C81   [55]     	LD	HL,(LOOPST)	; Get first statement of loop
085E: E3       [74]     	EX	(SP),HL		; Save and restore code string
085F: E5       [85]     	PUSH	HL		; Re-save code string address
0860: 2AA180   [101]    	LD	HL,(LINEAT)	; Get current line number
0863: E3       [120]    	EX	(SP),HL		; Save and restore code string
0864: CD4D0D   [137]    	CALL	TSTNUM		; Make sure it's a number
0867: CD5307   [154]    	CALL	CHKSYN		; Make sure "TO" is next
086A: A6                	DB	ZTO		; "TO" token
086B: CD4A0D   [171]    	CALL	GETNUM		; Get "TO" expression value
086E: E5       [182]    	PUSH	HL		; Save code string address
086F: CD7817   [199]    	CALL	BCDEFP		; Move "TO" value to BCDE
0872: E1       [209]    	POP	HL		; Restore code string address
0873: C5       [220]    	PUSH	BC		; Save "TO" value in block
0874: D5       [231]    	PUSH	DE
0875: 010081   [241]    	LD	BC,8100H	; BCDE - 1 (default STEP)
0878: 51       [245]    	LD	D,C		; C=0
0879: 5A       [249]    	LD	E,D		; D=0
087A: 7E       [256]    	LD	A,(HL)		; Get next byte in code string
087B: FEAB     [263]    	CP	ZSTEP		; See if "STEP" is stated
087D: 3E01     [270]    	LD	A,1		; Sign of step = 1
087F: C29008   [280|280]	JP	NZ,SAVSTP	; No STEP given - Default to 1
0882: CDDD08   [297]    	CALL	GETCHR		; Jump over "STEP" token
0885: CD4A0D   [314]    	CALL	GETNUM		; Get step value
0888: E5       [325]    	PUSH	HL		; Save code string address
0889: CD7817   [342]    	CALL	BCDEFP		; Move STEP to BCDE
088C: CD2C17   [359]    	CALL	TSTSGN		; Test sign of FPREG
088F: E1       [369]    	POP	HL		; Restore code string address
0890: C5       [11]     SAVSTP: PUSH	BC		; Save the STEP value in block
0891: D5       [22]     	PUSH	DE
0892: F5       [33]     	PUSH	AF		; Save sign of STEP
0893: 33       [39]     	INC	SP		; Don't save flags
0894: E5       [50]     	PUSH	HL		; Save code string address
0895: 2A1381   [66]     	LD	HL,(BRKLIN)	; Get address of index variable
0898: E3       [85]     	EX	(SP),HL		; Save and restore code string
0899: 0681     [ 7]     PUTFID: LD	B,ZFOR		; "FOR" block marker
089B: C5       [18]     	PUSH	BC		; Save it
089C: 33       [24]     	INC	SP		; Don't save C
                        ;
089D: CD0809   [17]     RUNCNT: CALL	TSTBRK		; Execution driver - Test break
08A0: 221381   [33]     	LD	(BRKLIN),HL	; Save code address for break
08A3: 7E       [40]     	LD	A,(HL)		; Get next byte in code string
08A4: FE3A     [47]     	CP	':'		; Multi statement line?
08A6: CABD08   [57|57]  	JP	Z,EXCUTE	; Yes - Execute it
08A9: B7       [61]     	OR	A		; End of line?
08AA: C28504   [71|71]  	JP	NZ,SNERR	; No - Syntax error
08AD: 23       [77]     	INC	HL		; Point to address of next line
08AE: 7E       [84]     	LD	A,(HL)		; Get LSB of line pointer
08AF: 23       [90]     	INC	HL
08B0: B6       [97]     	OR	(HL)		; Is it zero (End of prog)?
08B1: CA2F09   [107|107]	JP	Z,ENDPRG	; Yes - Terminate execution
08B4: 23       [113]    	INC	HL		; Point to line number
08B5: 5E       [120]    	LD	E,(HL)		; Get LSB of line number
08B6: 23       [126]    	INC	HL
08B7: 56       [133]    	LD	D,(HL)		; Get MSB of line number
08B8: EB       [137]    	EX	DE,HL		; Line number to HL
08B9: 22A180   [153]    	LD	(LINEAT),HL	; Save as current line number
08BC: EB       [157]    	EX	DE,HL		; Line number back to DE
08BD: CDDD08   [17]     EXCUTE: CALL	GETCHR		; Get key word
08C0: 119D08   [27]     	LD	DE,RUNCNT	; Where to RETurn to
08C3: D5       [38]     	PUSH	DE		; Save for RETurn
08C4: C8       [ 5|11]  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
08C5: D680     [ 7]     ONJMP:	SUB	ZEND		; Is it a token?
08C7: DA8B0A   [17|17]  	JP	C,LET		; No - try to assign it
08CA: FE25     [24]     	CP	ZNEW+1-ZEND	; END to NEW ?
08CC: D28504   [34|34]  	JP	NC,SNERR	; Not a key word - ?SN Error
08CF: 07       [38]     	RLCA			; Double it
08D0: 4F       [42]     	LD	C,A		; BC = Offset into table
08D1: 0600     [49]     	LD	B,0
08D3: EB       [53]     	EX	DE,HL		; Save code string address
08D4: 212D03   [63]     	LD	HL,WORDTB	; Keyword address table
08D7: 09       [74]     	ADD	HL,BC		; Point to routine address
08D8: 4E       [81]     	LD	C,(HL)		; Get LSB of routine address
08D9: 23       [87]     	INC	HL
08DA: 46       [94]     	LD	B,(HL)		; Get MSB of routine address
08DB: C5       [105]    	PUSH	BC		; Save routine address
08DC: EB       [109]    	EX	DE,HL		; Restore code string address
                        ;
08DD: 23       [ 6]     GETCHR: INC	HL		; Point to next character
08DE: 7E       [13]     	LD	A,(HL)		; Get next code string byte
08DF: FE3A     [20]     	CP	':'		; Z if ':'
08E1: D0       [25|31]  	RET	NC		; NC if > "9"
08E2: FE20     [32]     	CP	' '
08E4: CADD08   [42|42]  	JP	Z,GETCHR	; Skip over spaces
08E7: FE30     [49]     	CP	'0'
08E9: 3F       [53]     	CCF			; NC if < '0'
08EA: 3C       [57]     	INC	A		; Test for zero - Leave carry
08EB: 3D       [61]     	DEC	A		; Z if Null
08EC: C9       [71]     	RET
                        ;
08ED: EB       [ 4]     RESTOR: EX	DE,HL		; Save code string address
08EE: 2AA380   [20]     	LD	HL,(BASTXT)	; Point to start of program
08F1: CA0209   [30|30]  	JP	Z,RESTNL	; Just RESTORE - reset pointer
08F4: EB       [34]     	EX	DE,HL		; Restore code string address
08F5: CDA909   [51]     	CALL	ATOH		; Get line number to DE
08F8: E5       [62]     	PUSH	HL		; Save code string address
08F9: CD7105   [79]     	CALL	SRCHLN		; Search for line number in DE
08FC: 60       [83]     	LD	H,B		; HL = Address of line
08FD: 69       [87]     	LD	L,C
08FE: D1       [97]     	POP	DE		; Restore code string address
08FF: D24A0A   [107|107]	JP	NC,ULERR	; ?UL Error if not found
0902: 2B       [ 6]     RESTNL: DEC	HL		; Byte before DATA statement
0903: 222181   [16]     UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
0906: EB       [20]     	EX	DE,HL		; Restore code string address
0907: C9       [30]     	RET
                        ;
                        
0908: DF       [11]     TSTBRK: RST	18H		; Check input status
0909: C8       [16|22]  	RET	Z		; No key, go back
090A: D7       [27]     	RST	10H		; Get the key into A
090B: FE1B     [34]     	CP	ESC		; Escape key?
090D: 2811     [41|46]  	JR	Z,BRK		; Yes, break
090F: FE03     [48]     	CP	CTRLC		; <Ctrl-C>
0911: 280D     [55|60]  	JR	Z,BRK		; Yes, break
0913: FE13     [62]     	CP	CTRLS		; Stop scrolling?
0915: C0       [67|73]  	RET	NZ		; Other key, ignore
                        ;
                        
0916: D7       [11]     STALL:	RST	10H		; Wait for key
0917: FE11     [18]     	CP	CTRLQ		; Resume scrolling?
0919: C8       [23|29]  	RET	Z		; Release the chokehold
091A: FE03     [30]     	CP	CTRLC		; Second break?
091C: 2807     [37|42]  	JR	Z,STOP		; Break during hold exits prog
091E: 18F6     [49]     	JR	STALL		; Loop until <Ctrl-Q> or <brk>
                        ;
0920: 3EFF     [ 7]     BRK	LD	A,0FFH		; Set BRKFLG
0922: 329280   [20]     	LD	(BRKFLG),A	; Store it
                        ;
                        
0925: C0       [ 5|11]  STOP:	RET	NZ		; Exit if anything else
0926: F6                	DB	0F6H		; Flag "STOP"
0927: C0       [ 5|11]  PEND:	RET	NZ		; Exit if anything else
0928: 221381   [21]     	LD	(BRKLIN),HL	; Save point of break
092B: 21                	DB	21H		; Skip "OR 11111111B"
092C: F6FF     [ 7]     INPBRK: OR	11111111B	; Flag "Break" wanted
092E: C1       [17]     	POP	BC		; Return not needed and more
092F: 2AA180   [16]     ENDPRG: LD	HL,(LINEAT)	; Get current line number
0932: F5       [27]     	PUSH	AF		; Save STOP / END status
0933: 7D       [31]     	LD	A,L		; Is it direct break?
0934: A4       [35]     	AND	H
0935: 3C       [39]     	INC	A		; Line is -1 if direct break
0936: CA4209   [49|49]  	JP	Z,NOLIN		; Yes - No line number
0939: 221781   [65]     	LD	(ERRLIN),HL	; Save line of break
093C: 2A1381   [81]     	LD	HL,(BRKLIN)	; Get point of break
093F: 221981   [97]     	LD	(CONTAD),HL	; Save point to CONTinue
0942: AF       [ 4]     NOLIN:	XOR	A
0943: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
0946: CD780B   [34]     	CALL	STTLIN		; Start a new line
0949: F1       [44]     	POP	AF		; Restore STOP / END status
094A: 212804   [54]     	LD	HL,BRKMSG	; "Break" message
094D: C2B904   [64|64]  	JP	NZ,ERRIN	; "in line" wanted?
0950: C3D004   [74]     	JP	PRNTOK		; Go to command mode
                        ;
0953: 2A1981   [16]     CONT:	LD	HL,(CONTAD)	; Get CONTinue address
0956: 7C       [20]     	LD	A,H		; Is it zero?
0957: B5       [24]     	OR	L
0958: 1E20     [31]     	LD	E,CN		; ?CN Error
095A: CA9904   [41|41]  	JP	Z,ERROR		; Yes - output "?CN Error"
095D: EB       [45]     	EX	DE,HL		; Save code string address
095E: 2A1781   [61]     	LD	HL,(ERRLIN)	; Get line of last break
0961: 22A180   [77]     	LD	(LINEAT),HL	; Set up current line number
0964: EB       [81]     	EX	DE,HL		; Restore code string address
0965: C9       [91]     	RET			; CONTinue where left off
                        ;
0966: CDAB14   [17]     NULL:	CALL	GETINT		; Get integer 0-255
0969: C0       [22|28]  	RET	NZ		; Return if bad value
096A: 328680   [35]     	LD	(NULLS),A	; Set nulls number
096D: C9       [45]     	RET
                        ;
                        
096E: E5       [11]     ACCSUM: PUSH	HL		; Save address in array
096F: 2A8F80   [27]     	LD	HL,(CHKSUM)	; Get check sum
0972: 0600     [34]     	LD	B,0		; BC - Value of byte
0974: 4F       [38]     	LD	C,A
0975: 09       [49]     	ADD	HL,BC		; Add byte to check sum
0976: 228F80   [65]     	LD	(CHKSUM),HL	; Re-save check sum
0979: E1       [75]     	POP	HL		; Restore address in array
097A: C9       [85]     	RET
                        ;
097B: 7E       [ 7]     CHKLTR: LD	A,(HL)		; Get byte
097C: FE41     [14]     	CP	'A'		; < 'a' ?
097E: D8       [19|25]  	RET	C		; Carry set if not letter
097F: FE5B     [26]     	CP	'Z'+1		; > 'z' ?
0981: 3F       [30]     	CCF
0982: C9       [40]     	RET			; Carry set if not letter
                        ;
0983: CDDD08   [17]     FPSINT: CALL	GETCHR		; Get next character
0986: CD4A0D   [17]     POSINT: CALL	GETNUM		; Get integer 0 to 32767
0989: CD2C17   [17]     DEPINT: CALL	TSTSGN		; Test sign of FPREG
098C: FAA409   [27|27]  	JP	M,FCERR		; Negative - ?FC Error
098F: 3A2C81   [13]     DEINT:	LD	A,(FPEXP)	; Get integer value to DE
0992: FE90     [20]     	CP	80H+16		; Exponent in range (16 bits)?
0994: DAD417   [30|30]  	JP	C,FPINT		; Yes - convert it
0997: 018090   [40]     	LD	BC,9080H	; BCDE = -32768
099A: 110000   [50]     	LD	DE,0000
099D: E5       [61]     	PUSH	HL		; Save code string address
099E: CDA717   [78]     	CALL	CMPNUM		; Compare FPREG with BCDE
09A1: E1       [88]     	POP	HL		; Restore code string address
09A2: 51       [92]     	LD	D,C		; MSB to D
09A3: C8       [97|103] 	RET	Z		; Return if in range
09A4: 1E08     [ 7]     FCERR:	LD	E,FC		; ?FC Error
09A6: C39904   [17]     	JP	ERROR		; Output error-
                        ;
09A9: 2B       [ 6]     ATOH:	DEC	HL		; ASCII number to DE binary
09AA: 110000   [10]     GETLN:	LD	DE,0		; Get number to DE
09AD: CDDD08   [17]     GTLNLP: CALL	GETCHR		; Get next character
09B0: D0       [22|28]  	RET	NC		; Exit if not a digit
09B1: E5       [33]     	PUSH	HL		; Save code string address
09B2: F5       [44]     	PUSH	AF		; Save digit
09B3: 219819   [54]     	LD	HL,65529/10	; Largest number 65529
09B6: CD4D07   [71]     	CALL	CPDEHL		; Number in range?
09B9: DA8504   [81|81]  	JP	C,SNERR		; No - ?SN Error
09BC: 62       [85]     	LD	H,D		; HL = Number
09BD: 6B       [89]     	LD	L,E
09BE: 19       [100]    	ADD	HL,DE		; Times 2
09BF: 29       [111]    	ADD	HL,HL		; Times 4
09C0: 19       [122]    	ADD	HL,DE		; Times 5
09C1: 29       [133]    	ADD	HL,HL		; Times 10
09C2: F1       [143]    	POP	AF		; Restore digit
09C3: D630     [150]    	SUB	'0'		; Make it 0 to 9
09C5: 5F       [154]    	LD	E,A		; DE = Value of digit
09C6: 1600     [161]    	LD	D,0
09C8: 19       [172]    	ADD	HL,DE		; Add to number
09C9: EB       [176]    	EX	DE,HL		; Number to DE
09CA: E1       [186]    	POP	HL		; Restore code string address
09CB: C3AD09   [196]    	JP	GTLNLP		; Go to next character
                        ;
09CE: CAA105   [10|10]  CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
09D1: CD8609   [27]     	CALL	POSINT		; Get integer 0 to 32767 to DE
09D4: 2B       [33]     	DEC	HL		; Cancel increment
09D5: CDDD08   [50]     	CALL	GETCHR		; Get next character
09D8: E5       [61]     	PUSH	HL		; Save code string address
09D9: 2AF480   [77]     	LD	HL,(LSTRAM)	; Get end of RAM
09DC: CAF109   [87|87]  	JP	Z,STORED	; No value given - Use stored
09DF: E1       [97]     	POP	HL		; Restore code string address
09E0: CD5307   [114]    	CALL	CHKSYN		; Check for comma
09E3: 2C                	DB	','
09E4: D5       [125]    	PUSH	DE		; Save number
09E5: CD8609   [142]    	CALL	POSINT		; Get integer 0 to 32767
09E8: 2B       [148]    	DEC	HL		; Cancel increment
09E9: CDDD08   [165]    	CALL	GETCHR		; Get next character
09EC: C28504   [175|175]	JP	NZ,SNERR	; ?SN Error if more on line
09EF: E3       [194]    	EX	(SP),HL		; Save code string address
09F0: EB       [198]    	EX	DE,HL		; Number to DE
09F1: 7D       [ 4]     STORED: LD	A,L		; Get LSB of new RAM top
09F2: 93       [ 8]     	SUB	E		; Subtract LSB of string space
09F3: 5F       [12]     	LD	E,A		; Save LSB
09F4: 7C       [16]     	LD	A,H		; Get MSB of new RAM top
09F5: 9A       [20]     	SBC	A,D		; Subtract MSB of string space
09F6: 57       [24]     	LD	D,A		; Save MSB
09F7: DA7A04   [34|34]  	JP	C,OMERR		; ?OM Error if not enough mem
09FA: E5       [45]     	PUSH	HL		; Save RAM top
09FB: 2A1B81   [61]     	LD	HL,(PROGND)	; Get program end
09FE: 012800   [71]     	LD	BC,40		; 40 Bytes minimum working RAM
0A01: 09       [82]     	ADD	HL,BC		; Get lowest address
0A02: CD4D07   [99]     	CALL	CPDEHL		; Enough memory?
0A05: D27A04   [109|109]	JP	NC,OMERR	; No - ?OM Error
0A08: EB       [113]    	EX	DE,HL		; RAM top to HL
0A09: 229F80   [129]    	LD	(STRSPC),HL	; Set new string space
0A0C: E1       [139]    	POP	HL		; End of memory to use
0A0D: 22F480   [155]    	LD	(LSTRAM),HL	; Set new top of RAM
0A10: E1       [165]    	POP	HL		; Restore code string address
0A11: C3A105   [175]    	JP	INTVAR		; Initialise variables
                        ;
0A14: CA9D05   [10|10]  RUN:	JP	Z,RUNFST	; RUN from start if just RUN
0A17: CDA105   [27]     	CALL	INTVAR		; Initialise variables
0A1A: 019D08   [37]     	LD	BC,RUNCNT	; Execution driver loop
0A1D: C3300A   [47]     	JP	RUNLIN		; RUN from line number
                        ;
0A20: 0E03     [ 7]     GOSUB:	LD	C,3		; 3 Levels of stack needed
0A22: CD6204   [24]     	CALL	CHKSTK		; Check for 3 levels of stack
0A25: C1       [34]     	POP	BC		; Get return address
0A26: E5       [45]     	PUSH	HL		; Save code string for RETURN
0A27: E5       [56]     	PUSH	HL		; And for GOSUB routine
0A28: 2AA180   [72]     	LD	HL,(LINEAT)	; Get current line
0A2B: E3       [91]     	EX	(SP),HL		; Into stack - Code string out
0A2C: 3E8C     [98]     	LD	A,ZGOSUB	; "GOSUB" token
0A2E: F5       [109]    	PUSH	AF		; Save token
0A2F: 33       [115]    	INC	SP		; Don't save flags
                        ;
0A30: C5       [11]     RUNLIN: PUSH	BC		; Save return address
0A31: CDA909   [17]     GOTO:	CALL	ATOH		; ASCII number to DE binary
0A34: CD760A   [34]     	CALL	REM		; Get end of line
0A37: E5       [45]     	PUSH	HL		; Save end of line
0A38: 2AA180   [61]     	LD	HL,(LINEAT)	; Get current line
0A3B: CD4D07   [78]     	CALL	CPDEHL		; Line after current?
0A3E: E1       [88]     	POP	HL		; Restore end of line
0A3F: 23       [94]     	INC	HL		; Start of next line
0A40: DC7405   [104|111]	CALL	C,SRCHLP	; Line is after current line
0A43: D47105   [114|121]	CALL	NC,SRCHLN	; Line is before current line
0A46: 60       [118]    	LD	H,B		; Set up code string address
0A47: 69       [122]    	LD	L,C
0A48: 2B       [128]    	DEC	HL		; Incremented after
0A49: D8       [133|139]	RET	C		; Line found
0A4A: 1E0E     [ 7]     ULERR:	LD	E,UL		; ?UL Error
0A4C: C39904   [17]     	JP	ERROR		; Output error message
                        ;
0A4F: C0       [ 5|11]  RETURN: RET	NZ		; Return if not just RETURN
0A50: 16FF     [12]     	LD	D,-1		; Flag "GOSUB" search
0A52: CD2E04   [29]     	CALL	BAKSTK		; Look "GOSUB" block
0A55: F9       [35]     	LD	SP,HL		; Kill all FORs in subroutine
0A56: FE8C     [42]     	CP	ZGOSUB		; Test for "GOSUB" token
0A58: 1E04     [49]     	LD	E,RG		; ?RG Error
0A5A: C29904   [59|59]  	JP	NZ,ERROR	; Error if no "GOSUB" found
0A5D: E1       [69]     	POP	HL		; Get RETURN line number
0A5E: 22A180   [85]     	LD	(LINEAT),HL	; Save as current
0A61: 23       [91]     	INC	HL		; Was it from direct statement?
0A62: 7C       [95]     	LD	A,H
0A63: B5       [99]     	OR	L		; Return to line
0A64: C26E0A   [109|109]	JP	NZ,RETLIN	; No - Return to line
0A67: 3A1181   [122]    	LD	A,(LSTBIN)	; Any INPUT in subroutine?
0A6A: B7       [126]    	OR	A		; If so buffer is corrupted
0A6B: C2CF04   [136|136]	JP	NZ,POPNOK	; Yes - Go to command mode
0A6E: 219D08   [10]     RETLIN: LD	HL,RUNCNT	; Execution driver loop
0A71: E3       [29]     	EX	(SP),HL		; Into stack - Code string out
0A72: 3E                	DB	3EH		; Skip "POP HL"
0A73: E1       [10]     NXTDTA: POP	HL		; Restore code string address
                        ;
0A74: 013A              DATA:	DB	01H,3AH		; ':' End of statement
0A76: 0E00     [ 7]     REM:	LD	C,0		; 00	End of statement
0A78: 0600     [14]     	LD	B,0
0A7A: 79       [ 4]     NXTSTL: LD	A,C		; Statement and byte
0A7B: 48       [ 8]     	LD	C,B
0A7C: 47       [12]     	LD	B,A		; Statement end byte
0A7D: 7E       [ 7]     NXTSTT: LD	A,(HL)		; Get byte
0A7E: B7       [11]     	OR	A		; End of line?
0A7F: C8       [16|22]  	RET	Z		; Yes - Exit
0A80: B8       [20]     	CP	B		; End of statement?
0A81: C8       [25|31]  	RET	Z		; Yes - Exit
0A82: 23       [31]     	INC	HL		; Next byte
0A83: FE22     [38]     	CP	'"'		; Literal string?
0A85: CA7A0A   [48|48]  	JP	Z,NXTSTL	; Yes - Look for another '"'
0A88: C37D0A   [58]     	JP	NXTSTT		; Keep looking
                        ;
0A8B: CD400F   [17]     LET:	CALL	GETVAR		; Get variable name
0A8E: CD5307   [34]     	CALL	CHKSYN		; Make sure "=" follows
0A91: B4                	DB	ZEQUAL		; "=" token
0A92: D5       [45]     	PUSH	DE		; Save address of variable
0A93: 3AF280   [58]     	LD	A,(TYPE)	; Get data type
0A96: F5       [69]     	PUSH	AF		; Save type
0A97: CD5C0D   [86]     	CALL	EVAL		; Evaluate expression
0A9A: F1       [96]     	POP	AF		; Restore type
0A9B: E3       [115]    	EX	(SP),HL		; Save code - Get var addr
0A9C: 221381   [131]    	LD	(BRKLIN),HL	; Save address of variable
0A9F: 1F       [135]    	RRA			; Adjust type
0AA0: CD4F0D   [152]    	CALL	CHKTYP		; Check types are the same
0AA3: CADE0A   [162|162]	JP	Z,LETNUM	; Numeric - Move value
0AA6: E5       [11]     LETSTR: PUSH	HL		; Save address of string var
0AA7: 2A2981   [27]     	LD	HL,(FPREG)	; Pointer to string entry
0AAA: E5       [38]     	PUSH	HL		; Save it on stack
0AAB: 23       [44]     	INC	HL		; Skip over length
0AAC: 23       [50]     	INC	HL
0AAD: 5E       [57]     	LD	E,(HL)		; LSB of string address
0AAE: 23       [63]     	INC	HL
0AAF: 56       [70]     	LD	D,(HL)		; MSB of string address
0AB0: 2AA380   [86]     	LD	HL,(BASTXT)	; Point to start of program
0AB3: CD4D07   [103]    	CALL	CPDEHL		; Is string before program?
0AB6: D2CD0A   [113|113]	JP	NC,CRESTR	; Yes - Create string entry
0AB9: 2A9F80   [129]    	LD	HL,(STRSPC)	; Point to string space
0ABC: CD4D07   [146]    	CALL	CPDEHL		; Is string literal in program?
0ABF: D1       [156]    	POP	DE		; Restore address of string
0AC0: D2D50A   [166|166]	JP	NC,MVSTPT	; Yes - Set up pointer
0AC3: 210481   [176]    	LD	HL,TMPSTR	; Temporary string pool
0AC6: CD4D07   [193]    	CALL	CPDEHL		; Is string in temporary pool?
0AC9: D2D50A   [203|203]	JP	NC,MVSTPT	; No - Set up pointer
0ACC: 3E                	DB	3EH		; Skip "POP DE"
0ACD: D1       [10]     CRESTR: POP	DE		; Restore address of string
0ACE: CD8413   [27]     	CALL	BAKTMP		; Back to last tmp-str entry
0AD1: EB       [31]     	EX	DE,HL		; Address of string entry
0AD2: CDBD11   [48]     	CALL	SAVSTR		; Save string in string area
0AD5: CD8413   [17]     MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
0AD8: E1       [27]     	POP	HL		; Get string pointer
0AD9: CD8717   [44]     	CALL	DETHL4		; Move string pointer to var
0ADC: E1       [54]     	POP	HL		; Restore code string address
0ADD: C9       [64]     	RET
                        ;
0ADE: E5       [11]     LETNUM: PUSH	HL		; Save address of variable
0ADF: CD8417   [28]     	CALL	FPTHL		; Move value to variable
0AE2: D1       [38]     	POP	DE		; Restore address of variable
0AE3: E1       [48]     	POP	HL		; Restore code string address
0AE4: C9       [58]     	RET
                        ;
0AE5: CDAB14   [17]     ON:	CALL	GETINT		; Get integer 0-255
0AE8: 7E       [24]     	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
0AE9: 47       [28]     	LD	B,A		; Save in B
0AEA: FE8C     [35]     	CP	ZGOSUB		; "GOSUB" token?
0AEC: CAF40A   [45|45]  	JP	Z,ONGO		; Yes - Find line number
0AEF: CD5307   [62]     	CALL	CHKSYN		; Make sure it's "GOTO"
0AF2: 88                	DB	ZGOTO		; "GOTO" token
0AF3: 2B       [68]     	DEC	HL		; Cancel increment
0AF4: 4B       [ 4]     ONGO:	LD	C,E		; Integer of branch value
0AF5: 0D       [ 4]     ONGOLP: DEC	C		; Count branches
0AF6: 78       [ 8]     	LD	A,B		; Get "GOTO" or "GOSUB" token
0AF7: CAC508   [18|18]  	JP	Z,ONJMP		; Go to that line if right one
0AFA: CDAA09   [35]     	CALL	GETLN		; Get line number to DE
0AFD: FE2C     [42]     	CP	','		; Another line number?
0AFF: C0       [47|53]  	RET	NZ		; No - Drop through
0B00: C3F50A   [57]     	JP	ONGOLP		; Yes - loop
                        ;
0B03: CD5C0D   [17]     IF:	CALL	EVAL		; Evaluate expression
0B06: 7E       [24]     	LD	A,(HL)		; Get token
0B07: FE88     [31]     	CP	ZGOTO		; "GOTO" token?
0B09: CA110B   [41|41]  	JP	Z,IFGO		; Yes - Get line
0B0C: CD5307   [58]     	CALL	CHKSYN		; Make sure it's "THEN"
0B0F: A9                	DB	ZTHEN		; "THEN" token
0B10: 2B       [64]     	DEC	HL		; Cancel increment
0B11: CD4D0D   [17]     IFGO:	CALL	TSTNUM		; Make sure it's numeric
0B14: CD2C17   [34]     	CALL	TSTSGN		; Test state of expression
0B17: CA760A   [44|44]  	JP	Z,REM		; False - Drop through
0B1A: CDDD08   [61]     	CALL	GETCHR		; Get next character
0B1D: DA310A   [71|71]  	JP	C,GOTO		; Number - GOTO that line
0B20: C3C408   [81]     	JP	IFJMP		; Otherwise do statement
                        ;
0B23: 2B       [ 6]     MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
0B24: CDDD08   [23]     	CALL	GETCHR		; Get next character
0B27: CA850B   [10|10]  PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
0B2A: C8       [ 5|11]  PRNTLP: RET	Z		; End of list - Exit
0B2B: FEA5     [12]     	CP	ZTAB		; "TAB(" token?
0B2D: CAB80B   [22|22]  	JP	Z,DOTAB		; Yes - Do TAB routine
0B30: FEA8     [29]     	CP	ZSPC		; "SPC(" token?
0B32: CAB80B   [39|39]  	JP	Z,DOTAB		; Yes - Do SPC routine
0B35: E5       [50]     	PUSH	HL		; Save code string address
0B36: FE2C     [57]     	CP	','		; Comma?
0B38: CAA10B   [67|67]  	JP	Z,DOCOM		; Yes - Move to next zone
0B3B: FE3B     [74]     	CP	59;";"		; Semi-colon?
0B3D: CADB0B   [84|84]  	JP	Z,NEXITM	; Do semi-colon routine
0B40: C1       [94]     	POP	BC		; Code string address to BC
0B41: CD5C0D   [111]    	CALL	EVAL		; Evaluate expression
0B44: E5       [122]    	PUSH	HL		; Save code string address
0B45: 3AF280   [135]    	LD	A,(TYPE)	; Get variable type
0B48: B7       [139]    	OR	A		; Is it a string variable?
0B49: C2710B   [149|149]	JP	NZ,PRNTST	; Yes - Output string contents
0B4C: CDD118   [166]    	CALL	NUMASC		; Convert number to text
0B4F: CDE111   [183]    	CALL	CRTST		; Create temporary string
0B52: 3620     [193]    	LD	(HL),' '	; Followed by a space
0B54: 2A2981   [209]    	LD	HL,(FPREG)	; Get length of output
0B57: 34       [220]    	INC	(HL)		; Plus 1 for the space
0B58: 2A2981   [236]    	LD	HL,(FPREG)	; < Not needed >
0B5B: 3A8780   [249]    	LD	A,(LWIDTH)	; Get width of line
0B5E: 47       [253]    	LD	B,A		; To B
0B5F: 04       [257]    	INC	B		; Width 255 (No limit)?
0B60: CA6D0B   [267|267]	JP	Z,PRNTNB	; Yes - Output number string
0B63: 04       [271]    	INC	B		; Adjust it
0B64: 3AF080   [284]    	LD	A,(CURPOS)	; Get cursor position
0B67: 86       [291]    	ADD	A,(HL)		; Add length of string
0B68: 3D       [295]    	DEC	A		; Adjust it
0B69: B8       [299]    	CP	B		; Will output fit on this line?
0B6A: D4850B   [309|316]	CALL	NC,PRCRLF	; No - CRLF first
0B6D: CD2612   [17]     PRNTNB: CALL	PRS1		; Output string at (HL)
0B70: AF       [21]     	XOR	A		; Skip CALL by setting 'z' flag
0B71: C42612   [10|17]  PRNTST: CALL	NZ,PRS1		; Output string at (HL)
0B74: E1       [20]     	POP	HL		; Restore code string address
0B75: C3230B   [30]     	JP	MRPRNT		; See if more to PRINT
                        ;
0B78: 3AF080   [13]     STTLIN: LD	A,(CURPOS)	; Make sure on new line
0B7B: B7       [17]     	OR	A		; Already at start?
0B7C: C8       [22|28]  	RET	Z		; Yes - Do nothing
0B7D: C3850B   [32]     	JP	PRCRLF		; Start a new line
                        ;
0B80: 3600     [10]     ENDINP: LD	(HL),0		; Mark end of buffer
0B82: 21A580   [20]     	LD	HL,BUFFER-1	; Point to buffer
0B85: 3E0D     [ 7]     PRCRLF: LD	A,CR		; Load a CR
0B87: CD5E07   [24]     	CALL	OUTC		; Output character
0B8A: 3E0A     [31]     	LD	A,LF		; Load a LF
0B8C: CD5E07   [48]     	CALL	OUTC		; Output character
0B8F: AF       [ 4]     DONULL: XOR	A		; Set to position 0
0B90: 32F080   [17]     	LD	(CURPOS),A	; Store it
0B93: 3A8680   [30]     	LD	A,(NULLS)	; Get number of nulls
0B96: 3D       [ 4]     NULLP:	DEC	A		; Count them
0B97: C8       [ 9|15]  	RET	Z		; Return if done
0B98: F5       [20]     	PUSH	AF		; Save count
0B99: AF       [24]     	XOR	A		; Load a null
0B9A: CD5E07   [41]     	CALL	OUTC		; Output it
0B9D: F1       [51]     	POP	AF		; Restore count
0B9E: C3960B   [61]     	JP	NULLP		; Keep counting
                        ;
0BA1: 3A8880   [13]     DOCOM:	LD	A,(COMMAN)	; Get comma width
0BA4: 47       [17]     	LD	B,A		; Save in B
0BA5: 3AF080   [30]     	LD	A,(CURPOS)	; Get current position
0BA8: B8       [34]     	CP	B		; Within the limit?
0BA9: D4850B   [44|51]  	CALL	NC,PRCRLF	; No - output CRLF
0BAC: D2DB0B   [54|54]  	JP	NC,NEXITM	; Get next item
0BAF: D60E     [ 7]     ZONELP: SUB	14		; Next zone of 14 characters
0BB1: D2AF0B   [17|17]  	JP	NC,ZONELP	; Repeat if more zones
0BB4: 2F       [21]     	CPL			; Number of spaces to output
0BB5: C3D00B   [31]     	JP	ASPCS		; Output them
                        ;
0BB8: F5       [11]     DOTAB:	PUSH	AF		; Save token
0BB9: CDA814   [28]     	CALL	FNDNUM		; Evaluate expression
0BBC: CD5307   [45]     	CALL	CHKSYN		; Make sure ")" follows
0BBF: 29                	DB	")"
0BC0: 2B       [51]     	DEC	HL		; Back space on to ")"
0BC1: F1       [61]     	POP	AF		; Restore token
0BC2: D6A8     [68]     	SUB	ZSPC		; Was it "SPC(" ?
0BC4: E5       [79]     	PUSH	HL		; Save code string address
0BC5: CACB0B   [89|89]  	JP	Z,DOSPC	; Yes - Do 'E' spaces
0BC8: 3AF080   [102]    	LD	A,(CURPOS)	; Get current position
0BCB: 2F       [ 4]     DOSPC:	CPL			; Number of spaces to print to
0BCC: 83       [ 8]     	ADD	A,E		; Total number to print
0BCD: D2DB0B   [18|18]  	JP	NC,NEXITM	; TAB < Current POS(X)
0BD0: 3C       [ 4]     ASPCS:	INC	A		; Output A spaces
0BD1: 47       [ 8]     	LD	B,A		; Save number to print
0BD2: 3E20     [15]     	LD	A,' '		; Space
0BD4: CD5E07   [17]     SPCLP:	CALL	OUTC		; Output character in A
0BD7: 05       [21]     	DEC	B		; Count them
0BD8: C2D40B   [31|31]  	JP	NZ,SPCLP	; Repeat if more
0BDB: E1       [10]     NEXITM: POP	HL		; Restore code string address
0BDC: CDDD08   [27]     	CALL	GETCHR		; Get next character
0BDF: C32A0B   [37]     	JP	PRNTLP		; More to print
                        ;
0BE2: 3F526564          REDO:	DB	"?Redo from start",CR,LF,0
0BE6: 6F206672          
0BEA: 6F6D2073          
0BEE: 74617274          
0BF2: 0D0A00            
                        ;
0BF5: 3A1281   [13]     BADINP: LD	A,(READFG)	; READ or INPUT?
0BF8: B7       [17]     	OR	A
0BF9: C27F04   [27|27]  	JP	NZ,DATSNR	; READ - ?SN Error
0BFC: C1       [37]     	POP	BC		; Throw away code string addr
0BFD: 21E20B   [47]     	LD	HL,REDO		; "Redo from start" message
0C00: CD2312   [64]     	CALL	PRS		; Output string
0C03: C3D005   [74]     	JP	DOAGN		; Do last INPUT again
                        ;
0C06: CD8E11   [17]     INPUT:	CALL	IDTEST		; Test for illegal direct
0C09: 7E       [24]     	LD	A,(HL)		; Get character after "INPUT"
0C0A: FE22     [31]     	CP	'"'		; Is there a prompt string?
0C0C: 3E00     [38]     	LD	A,0		; Clear A and leave flags
0C0E: 328A80   [51]     	LD	(CTLOFG),A	; Enable output
0C11: C2200C   [61|61]  	JP	NZ,NOPMPT	; No prompt - get input
0C14: CDE211   [78]     	CALL	QTSTR		; Get string terminated by '"'
0C17: CD5307   [95]     	CALL	CHKSYN		; Check for ';' after prompt
0C1A: 3B                	DB	';'
0C1B: E5       [106]    	PUSH	HL		; Save code string address
0C1C: CD2612   [123]    	CALL	PRS1		; Output prompt string
0C1F: 3E                	DB	3EH		; Skip "PUSH HL"
0C20: E5       [11]     NOPMPT: PUSH	HL		; Save code string address
0C21: CDD405   [28]     	CALL	PROMPT		; Get input with "? " prompt
0C24: C1       [38]     	POP	BC		; Restore code string address
0C25: DA2C09   [48|48]  	JP	C,INPBRK	; Break pressed - Exit
0C28: 23       [54]     	INC	HL		; Next byte
0C29: 7E       [61]     	LD	A,(HL)		; Get it
0C2A: B7       [65]     	OR	A		; End of line?
0C2B: 2B       [71]     	DEC	HL		; Back again
0C2C: C5       [82]     	PUSH	BC		; Re-save code string address
0C2D: CA730A   [92|92]  	JP	Z,NXTDTA	; Yes - Find next DATA stmt
0C30: 362C     [102]    	LD	(HL),','	; Store comma as separator
0C32: C33A0C   [112]    	JP	NXTITM		; Get next item
                        ;
0C35: E5       [11]     READ:	PUSH	HL		; Save code string address
0C36: 2A2181   [27]     	LD	HL,(NXTDAT)	; Next DATA statement
0C39: F6                	DB	0F6H		; Flag "READ"
0C3A: AF       [ 4]     NXTITM: XOR	A		; Flag "INPUT"
0C3B: 321281   [17]     	LD	(READFG),A	; Save "READ"/"INPUT" flag
0C3E: E3       [36]     	EX	(SP),HL		; Get code str' , Save pointer
0C3F: C3460C   [46]     	JP	GTVLUS		; Get values
                        ;
0C42: CD5307   [17]     NEDMOR: CALL	CHKSYN		; Check for comma between items
0C45: 2C                	DB	','
0C46: CD400F   [17]     GTVLUS: CALL	GETVAR		; Get variable name
0C49: E3       [36]     	EX	(SP),HL		; Save code str" , Get pointer
0C4A: D5       [47]     	PUSH	DE		; Save variable address
0C4B: 7E       [54]     	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
0C4C: FE2C     [61]     	CP	','		; Comma?
0C4E: CA6E0C   [71|71]  	JP	Z,ANTVLU	; Yes - Get another value
0C51: 3A1281   [84]     	LD	A,(READFG)	; Is it READ?
0C54: B7       [88]     	OR	A
0C55: C2DB0C   [98|98]  	JP	NZ,FDTLP	; Yes - Find next DATA stmt
0C58: 3E3F     [105]    	LD	A,'?'		; More INPUT needed
0C5A: CD5E07   [122]    	CALL	OUTC		; Output character
0C5D: CDD405   [139]    	CALL	PROMPT		; Get INPUT with prompt
0C60: D1       [149]    	POP	DE		; Variable address
0C61: C1       [159]    	POP	BC		; Code string address
0C62: DA2C09   [169|169]	JP	C,INPBRK	; Break pressed
0C65: 23       [175]    	INC	HL		; Point to next DATA byte
0C66: 7E       [182]    	LD	A,(HL)		; Get byte
0C67: B7       [186]    	OR	A		; Is it zero (No input) ?
0C68: 2B       [192]    	DEC	HL		; Back space INPUT pointer
0C69: C5       [203]    	PUSH	BC		; Save code string address
0C6A: CA730A   [213|213]	JP	Z,NXTDTA	; Find end of buffer
0C6D: D5       [224]    	PUSH	DE		; Save variable address
0C6E: 3AF280   [13]     ANTVLU: LD	A,(TYPE)	; Check data type
0C71: B7       [17]     	OR	A		; Is it numeric?
0C72: CA980C   [27|27]  	JP	Z,INPBIN	; Yes - Convert to binary
0C75: CDDD08   [44]     	CALL	GETCHR		; Get next character
0C78: 57       [48]     	LD	D,A		; Save input character
0C79: 47       [52]     	LD	B,A		; Again
0C7A: FE22     [59]     	CP	'"'		; Start of literal sting?
0C7C: CA8C0C   [69|69]  	JP	Z,STRENT	; Yes - Create string entry
0C7F: 3A1281   [82]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0C82: B7       [86]     	OR	A
0C83: 57       [90]     	LD	D,A		; Save 00 if "INPUT"
0C84: CA890C   [100|100]	JP	Z,ITMSEP	; "INPUT" - End with 00
0C87: 163A     [107]    	LD	D,':'		; "DATA" - End with 00 or ':'
0C89: 062C     [ 7]     ITMSEP: LD	B,','		; Item separator
0C8B: 2B       [13]     	DEC	HL		; Back space for DTSTR
0C8C: CDE511   [17]     STRENT: CALL	DTSTR		; Get string terminated by D
0C8F: EB       [21]     	EX	DE,HL		; String address to DE
0C90: 21A30C   [31]     	LD	HL,LTSTND	; Where to go after LETSTR
0C93: E3       [50]     	EX	(SP),HL		; Save HL , get input pointer
0C94: D5       [61]     	PUSH	DE		; Save address of string
0C95: C3A60A   [71]     	JP	LETSTR		; Assign string to variable
                        ;
0C98: CDDD08   [17]     INPBIN: CALL	GETCHR		; Get next character
0C9B: CD3318   [34]     	CALL	ASCTFP		; Convert ASCII to FP number
0C9E: E3       [53]     	EX	(SP),HL		; Save input ptr, Get var addr
0C9F: CD8417   [70]     	CALL	FPTHL		; Move FPREG to variable
0CA2: E1       [80]     	POP	HL		; Restore input pointer
0CA3: 2B       [ 6]     LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
0CA4: CDDD08   [23]     	CALL	GETCHR		; Get next character
0CA7: CAAF0C   [33|33]  	JP	Z,MORDT		; End of line - More needed?
0CAA: FE2C     [40]     	CP	','		; Another value?
0CAC: C2F50B   [50|50]  	JP	NZ,BADINP	; No - Bad input
0CAF: E3       [19]     MORDT:	EX	(SP),HL		; Get code string address
0CB0: 2B       [25]     	DEC	HL		; DEC 'cos GETCHR INCs
0CB1: CDDD08   [42]     	CALL	GETCHR		; Get next character
0CB4: C2420C   [52|52]  	JP	NZ,NEDMOR	; More needed - Get it
0CB7: D1       [62]     	POP	DE		; Restore DATA pointer
0CB8: 3A1281   [75]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0CBB: B7       [79]     	OR	A
0CBC: EB       [83]     	EX	DE,HL		; DATA pointer to HL
0CBD: C20309   [93|93]  	JP	NZ,UPDATA	; Update DATA pointer if "READ"
0CC0: D5       [104]    	PUSH	DE		; Save code string address
0CC1: B6       [111]    	OR	(HL)		; More input given?
0CC2: 21CA0C   [121]    	LD	HL,EXTIG	; "?Extra ignored" message
0CC5: C42312   [131|138]	CALL	NZ,PRS		; Output string if extra given
0CC8: E1       [141]    	POP	HL		; Restore code string address
0CC9: C9       [151]    	RET
                        ;
0CCA: 3F457874          EXTIG:	DB	"?Extra ignored",CR,LF,0
0CCE: 72612069          
0CD2: 676E6F72          
0CD6: 65640D0A          
0CDA: 00                
                        ;
0CDB: CD740A   [17]     FDTLP:	CALL	DATA		; Get next statement
0CDE: B7       [21]     	OR	A		; End of line?
0CDF: C2F40C   [31|31]  	JP	NZ,FANDT	; No - See if DATA statement
0CE2: 23       [37]     	INC	HL
0CE3: 7E       [44]     	LD	A,(HL)		; End of program?
0CE4: 23       [50]     	INC	HL
0CE5: B6       [57]     	OR	(HL)		; 00 00 Ends program
0CE6: 1E06     [64]     	LD	E,OD		; ?OD Error
0CE8: CA9904   [74|74]  	JP	Z,ERROR		; Yes - Out of DATA
0CEB: 23       [80]     	INC	HL
0CEC: 5E       [87]     	LD	E,(HL)		; LSB of line number
0CED: 23       [93]     	INC	HL
0CEE: 56       [100]    	LD	D,(HL)		; MSB of line number
0CEF: EB       [104]    	EX	DE,HL
0CF0: 220E81   [120]    	LD	(DATLIN),HL	; Set line of current DATA item
0CF3: EB       [124]    	EX	DE,HL
0CF4: CDDD08   [17]     FANDT:	CALL	GETCHR		; Get next character
0CF7: FE83     [24]     	CP	ZDATA		; "DATA" token
0CF9: C2DB0C   [34|34]  	JP	NZ,FDTLP	; No "DATA" - Keep looking
0CFC: C36E0C   [44]     	JP	ANTVLU		; Found - Convert input
                        ;
0CFF: 110000   [10]     NEXT:	LD	DE,0		; In case no index given
0D02: C4400F   [10|17]  NEXT1:	CALL	NZ,GETVAR	; Get index address
0D05: 221381   [26]     	LD	(BRKLIN),HL	; Save code string address
0D08: CD2E04   [43]     	CALL	BAKSTK		; Look for "FOR" block
0D0B: C28B04   [53|53]  	JP	NZ,NFERR	; No "FOR" - ?NF Error
0D0E: F9       [59]     	LD	SP,HL		; Clear nested loops
0D0F: D5       [70]     	PUSH	DE		; Save index address
0D10: 7E       [77]     	LD	A,(HL)		; Get sign of STEP
0D11: 23       [83]     	INC	HL
0D12: F5       [94]     	PUSH	AF		; Save sign of STEP
0D13: D5       [105]    	PUSH	DE		; Save index address
0D14: CD6A17   [122]    	CALL	PHLTFP		; Move index value to FPREG
0D17: E3       [141]    	EX	(SP),HL		; Save address of TO value
0D18: E5       [152]    	PUSH	HL		; Save address of index
0D19: CDD714   [169]    	CALL	ADDPHL		; Add STEP to index value
0D1C: E1       [179]    	POP	HL		; Restore address of index
0D1D: CD8417   [196]    	CALL	FPTHL		; Move value to index variable
0D20: E1       [206]    	POP	HL		; Restore address of TO value
0D21: CD7B17   [223]    	CALL	LOADFP		; Move TO value to BCDE
0D24: E5       [234]    	PUSH	HL		; Save address of line of FOR
0D25: CDA717   [251]    	CALL	CMPNUM		; Compare index with TO value
0D28: E1       [261]    	POP	HL		; Restore address of line num
0D29: C1       [271]    	POP	BC		; Address of sign of STEP
0D2A: 90       [275]    	SUB	B		; Compare with expected sign
0D2B: CD7B17   [292]    	CALL	LOADFP		; BC = Loop stmt,DE = Line num
0D2E: CA3A0D   [302|302]	JP	Z,KILFOR	; Loop finished - Terminate it
0D31: EB       [306]    	EX	DE,HL		; Loop statement line number
0D32: 22A180   [322]    	LD	(LINEAT),HL	; Set loop line number
0D35: 69       [326]    	LD	L,C		; Set code string to loop
0D36: 60       [330]    	LD	H,B
0D37: C39908   [340]    	JP	PUTFID		; Put back "FOR" and continue
                        ;
0D3A: F9       [ 6]     KILFOR: LD	SP,HL		; Remove "FOR" block
0D3B: 2A1381   [22]     	LD	HL,(BRKLIN)	; Code string after "NEXT"
0D3E: 7E       [29]     	LD	A,(HL)		; Get next byte in code string
0D3F: FE2C     [36]     	CP	','		; More NEXTs ?
0D41: C29D08   [46|46]  	JP	NZ,RUNCNT	; No - Do next statement
0D44: CDDD08   [63]     	CALL	GETCHR		; Position to index name
0D47: CD020D   [80]     	CALL	NEXT1		; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        ;
0D4A: CD5C0D   [17]     GETNUM: CALL	EVAL		; Get a numeric expression
0D4D: F6                TSTNUM: DB	0F6H		; Clear carry (numeric)
0D4E: 37       [ 4]     TSTSTR: SCF			; Set carry (string)
0D4F: 3AF280   [13]     CHKTYP: LD	A,(TYPE)	; Check types match
0D52: 8F       [17]     	ADC	A,A		; Expected + actual
0D53: B7       [21]     	OR	A		; Clear carry , set parity
0D54: E8       [26|32]  	RET	PE		; Even parity - Types match
0D55: C39704   [36]     	JP	TMERR		; Different types - Error
                        ;
0D58: CD5307   [17]     OPNPAR: CALL	CHKSYN		; Make sure "(" follows
0D5B: 28                	DB	"("
0D5C: 2B       [ 6]     EVAL:	DEC	HL		; Evaluate expression & save
0D5D: 1600     [13]     	LD	D,0		; Precedence value
0D5F: D5       [11]     EVAL1:	PUSH	DE		; Save precedence
0D60: 0E01     [18]     	LD	C,1
0D62: CD6204   [35]     	CALL	CHKSTK		; Check for 1 level of stack
0D65: CDD30D   [52]     	CALL	OPRND		; Get next expression value
0D68: 221581   [16]     EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
0D6B: 2A1581   [16]     EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
0D6E: C1       [26]     	POP	BC		; Precedence value and operator
0D6F: 78       [30]     	LD	A,B		; Get precedence value
0D70: FE78     [37]     	CP	78H		; "AND" or "OR" ?
0D72: D44D0D   [47|54]  	CALL	NC,TSTNUM	; No - Make sure it's a number
0D75: 7E       [54]     	LD	A,(HL)		; Get next operator / function
0D76: 1600     [61]     	LD	D,0		; Clear Last relation
0D78: D6B3     [ 7]     RLTLP:	SUB	ZGTR		; ">" Token
0D7A: DA940D   [17|17]  	JP	C,FOPRND	; + - * / ^ AND OR - Test it
0D7D: FE03     [24]     	CP	ZLTH+1-ZGTR	; < = >
0D7F: D2940D   [34|34]  	JP	NC,FOPRND	; Function - Call it
0D82: FE01     [41]     	CP	ZEQUAL-ZGTR	; "="
0D84: 17       [45]     	RLA			; <- Test for legal
0D85: AA       [49]     	XOR	D		; <- combinations of < = >
0D86: BA       [53]     	CP	D		; <- by combining last token
0D87: 57       [57]     	LD	D,A		; <- with current one
0D88: DA8504   [67|67]  	JP	C,SNERR		; Error if "<<' '==" or ">>"
0D8B: 220A81   [83]     	LD	(CUROPR),HL	; Save address of current token
0D8E: CDDD08   [100]    	CALL	GETCHR		; Get next character
0D91: C3780D   [110]    	JP	RLTLP		; Treat the two as one
                        ;
0D94: 7A       [ 4]     FOPRND: LD	A,D		; < = > found ?
0D95: B7       [ 8]     	OR	A
0D96: C2BB0E   [18|18]  	JP	NZ,TSTRED	; Yes - Test for reduction
0D99: 7E       [25]     	LD	A,(HL)		; Get operator token
0D9A: 220A81   [41]     	LD	(CUROPR),HL	; Save operator address
0D9D: D6AC     [48]     	SUB	ZPLUS		; Operator or function?
0D9F: D8       [53|59]  	RET	C		; Neither - Exit
0DA0: FE07     [60]     	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
0DA2: D0       [65|71]  	RET	NC		; No - Exit
0DA3: 5F       [69]     	LD	E,A		; Coded operator
0DA4: 3AF280   [82]     	LD	A,(TYPE)	; Get data type
0DA7: 3D       [86]     	DEC	A		; FF = numeric , 00 = string
0DA8: B3       [90]     	OR	E		; Combine with coded operator
0DA9: 7B       [94]     	LD	A,E		; Get coded operator
0DAA: CA1913   [104|104]	JP	Z,CONCAT	; String concatenation
0DAD: 07       [108]    	RLCA			; Times 2
0DAE: 83       [112]    	ADD	A,E		; Times 3
0DAF: 5F       [116]    	LD	E,A		; To DE (D is 0)
0DB0: 217703   [126]    	LD	HL,PRITAB	; Precedence table
0DB3: 19       [137]    	ADD	HL,DE		; To the operator concerned
0DB4: 78       [141]    	LD	A,B		; Last operator precedence
0DB5: 56       [148]    	LD	D,(HL)		; Get evaluation precedence
0DB6: BA       [152]    	CP	D		; Compare with eval precedence
0DB7: D0       [157|163]	RET	NC		; Exit if higher precedence
0DB8: 23       [163]    	INC	HL		; Point to routine address
0DB9: CD4D0D   [180]    	CALL	TSTNUM		; Make sure it's a number
                        ;
0DBC: C5       [11]     STKTHS: PUSH	BC		; Save last precedence & token
0DBD: 016B0D   [21]     	LD	BC,EVAL3	; Where to go on prec' break
0DC0: C5       [32]     	PUSH	BC		; Save on stack for return
0DC1: 43       [36]     	LD	B,E		; Save operator
0DC2: 4A       [40]     	LD	C,D		; Save precedence
0DC3: CD5D17   [57]     	CALL	STAKFP		; Move value to stack
0DC6: 58       [61]     	LD	E,B		; Restore operator
0DC7: 51       [65]     	LD	D,C		; Restore precedence
0DC8: 4E       [72]     	LD	C,(HL)		; Get LSB of routine address
0DC9: 23       [78]     	INC	HL
0DCA: 46       [85]     	LD	B,(HL)		; Get MSB of routine address
0DCB: 23       [91]     	INC	HL
0DCC: C5       [102]    	PUSH	BC		; Save routine address
0DCD: 2A0A81   [118]    	LD	HL,(CUROPR)	; Address of current operator
0DD0: C35F0D   [128]    	JP	EVAL1		; Loop until prec' break
                        ;
0DD3: AF       [ 4]     OPRND:	XOR	A		; Get operand routine
0DD4: 32F280   [17]     	LD	(TYPE),A	; Set numeric expected
0DD7: CDDD08   [34]     	CALL	GETCHR		; Get next character
0DDA: 1E24     [41]     	LD	E,MO		; ?MO Error
0DDC: CA9904   [51|51]  	JP	Z,ERROR		; No operand - Error
0DDF: DA3318   [61|61]  	JP	C,ASCTFP	; Number - Get value
0DE2: CD7B09   [78]     	CALL	CHKLTR		; See if a letter
0DE5: D23A0E   [88|88]  	JP	NC,CONVAR	; Letter - Find variable
0DE8: FE26     [95]     	CP	'&'		; &H = HEX, &B = BINARY
0DEA: 2012     [102|107]	JR	NZ, NOTAMP
0DEC: CDDD08   [119]    	CALL	GETCHR		; Get next character
0DEF: FE48     [126]    	CP	'H'		; Hex number indicated? [function added]
0DF1: CA771C   [136|136]	JP	Z,HEXTFP	; Convert Hex to FPREG
0DF4: FE42     [143]    	CP	'B'		; Binary number indicated? [function added]
0DF6: CAE71C   [153|153]	JP	Z,BINTFP	; Convert Bin to FPREG
0DF9: 1E02     [160]    	LD	E,SN		; If neither then a ?SN Error
0DFB: CA9904   [170|170]	JP	Z,ERROR
0DFE: FEAC     [ 7]     NOTAMP: CP	ZPLUS		; '+' Token ?
0E00: CAD30D   [17|17]  	JP	Z,OPRND		; Yes - Look for operand
0E03: FE2E     [24]     	CP	'.'		; '.' ?
0E05: CA3318   [34|34]  	JP	Z,ASCTFP	; Yes - Create FP number
0E08: FEAD     [41]     	CP	ZMINUS		; '-' Token ?
0E0A: CA290E   [51|51]  	JP	Z,MINUS		; Yes - Do minus
0E0D: FE22     [58]     	CP	'"'		; Literal string ?
0E0F: CAE211   [68|68]  	JP	Z,QTSTR		; Get string terminated by '"'
0E12: FEAA     [75]     	CP	ZNOT		; "NOT" Token ?
0E14: CA1B0F   [85|85]  	JP	Z,EVNOT		; Yes - Eval NOT expression
0E17: FEA7     [92]     	CP	ZFN		; "FN" Token ?
0E19: CA4611   [102|102]	JP	Z,DOFN		; Yes - Do FN routine
0E1C: D6B6     [109]    	SUB	ZSGN		; Is it a function?
0E1E: D24B0E   [119|119]	JP	NC,FNOFST	; Yes - Evaluate function
0E21: CD580D   [17]     EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
0E24: CD5307   [34]     	CALL	CHKSYN		; Make sure ")" follows
0E27: 29                	DB	")"
0E28: C9       [44]     	RET
                        ;
0E29: 167D     [ 7]     MINUS:	LD	D,7DH		; '-' precedence
0E2B: CD5F0D   [24]     	CALL	EVAL1		; Evaluate until prec' break
0E2E: 2A1581   [40]     	LD	HL,(NXTOPR)	; Get next operator address
0E31: E5       [51]     	PUSH	HL		; Save next operator address
0E32: CD5517   [68]     	CALL	INVSGN		; Negate value
0E35: CD4D0D   [17]     RETNUM: CALL	TSTNUM		; Make sure it's a number
0E38: E1       [27]     	POP	HL		; Restore next operator address
0E39: C9       [37]     	RET
                        ;
0E3A: CD400F   [17]     CONVAR: CALL	GETVAR		; Get variable address to DE
0E3D: E5       [11]     FRMEVL: PUSH	HL		; Save code string address
0E3E: EB       [15]     	EX	DE,HL		; Variable address to HL
0E3F: 222981   [31]     	LD	(FPREG),HL	; Save address of variable
0E42: 3AF280   [44]     	LD	A,(TYPE)	; Get type
0E45: B7       [48]     	OR	A		; Numeric?
0E46: CC6A17   [58|65]  	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
0E49: E1       [68]     	POP	HL		; Restore code string address
0E4A: C9       [78]     	RET
                        ;
0E4B: 0600     [ 7]     FNOFST: LD	B,0		; Get address of function
0E4D: 07       [11]     	RLCA			; Double function offset
0E4E: 4F       [15]     	LD	C,A		; BC = Offset in function table
0E4F: C5       [26]     	PUSH	BC		; Save adjusted token value
0E50: CDDD08   [43]     	CALL	GETCHR		; Get next character
0E53: 79       [47]     	LD	A,C		; Get adjusted token value
0E54: FE31     [54]     	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
0E56: DA720E   [64|64]  	JP	C,FNVAL		; No - Do function
0E59: CD580D   [81]     	CALL	OPNPAR		; Evaluate expression	(X,...
0E5C: CD5307   [98]     	CALL	CHKSYN		; Make sure ',' follows
0E5F: 2C                	DB	','
0E60: CD4E0D   [115]    	CALL	TSTSTR		; Make sure it's a string
0E63: EB       [119]    	EX	DE,HL		; Save code string address
0E64: 2A2981   [135]    	LD	HL,(FPREG)	; Get address of string
0E67: E3       [154]    	EX	(SP),HL		; Save address of string
0E68: E5       [165]    	PUSH	HL		; Save adjusted token value
0E69: EB       [169]    	EX	DE,HL		; Restore code string address
0E6A: CDAB14   [186]    	CALL	GETINT		; Get integer 0-255
0E6D: EB       [190]    	EX	DE,HL		; Save code string address
0E6E: E3       [209]    	EX	(SP),HL		; Save integer,HL = adj' token
0E6F: C37A0E   [219]    	JP	GOFUNC		; Jump to string function
                        ;
0E72: CD210E   [17]     FNVAL:	CALL	EVLPAR		; Evaluate expression
0E75: E3       [36]     	EX	(SP),HL		; HL = Adjusted token value
0E76: 11350E   [46]     	LD	DE,RETNUM	; Return number from function
0E79: D5       [57]     	PUSH	DE		; Save on stack
0E7A: 01D601   [10]     GOFUNC: LD	BC,FNCTAB	; Function routine addresses
0E7D: 09       [21]     	ADD	HL,BC		; Point to right address
0E7E: 4E       [28]     	LD	C,(HL)		; Get LSB of address
0E7F: 23       [34]     	INC	HL		;
0E80: 66       [41]     	LD	H,(HL)		; Get MSB of address
0E81: 69       [45]     	LD	L,C		; Address to HL
0E82: E9       [49]     	JP	(HL)		; Jump to function
                        ;
0E83: 15       [ 4]     SGNEXP: DEC	D		; Dee to flag negative exponent
0E84: FEAD     [11]     	CP	ZMINUS		; '-' token ?
0E86: C8       [16|22]  	RET	Z		; Yes - Return
0E87: FE2D     [23]     	CP	'-'		; '-' ASCII ?
0E89: C8       [28|34]  	RET	Z		; Yes - Return
0E8A: 14       [32]     	INC	D		; Inc to flag positive exponent
0E8B: FE2B     [39]     	CP	'+'		; '+' ASCII ?
0E8D: C8       [44|50]  	RET	Z		; Yes - Return
0E8E: FEAC     [51]     	CP	ZPLUS		; '+' token ?
0E90: C8       [56|62]  	RET	Z		; Yes - Return
0E91: 2B       [62]     	DEC	HL		; DEC 'cos GETCHR INCs
0E92: C9       [72]     	RET			; Return "NZ"
                        ;
0E93: F6                POR:	DB	0F6H		; Flag "OR"
0E94: AF       [ 4]     PAND:	XOR	A		; Flag "AND"
0E95: F5       [15]     	PUSH	AF		; Save "AND" / "OR" flag
0E96: CD4D0D   [32]     	CALL	TSTNUM		; Make sure it's a number
0E99: CD8F09   [49]     	CALL	DEINT		; Get integer -32768 to 32767
0E9C: F1       [59]     	POP	AF		; Restore "AND" / "OR" flag
0E9D: EB       [63]     	EX	DE,HL		; <- Get last
0E9E: C1       [73]     	POP	BC		; <- value
0E9F: E3       [92]     	EX	(SP),HL		; <- from
0EA0: EB       [96]     	EX	DE,HL		; <- stack
0EA1: CD6D17   [113]    	CALL	FPBCDE		; Move last value to FPREG
0EA4: F5       [124]    	PUSH	AF		; Save "AND" / "OR" flag
0EA5: CD8F09   [141]    	CALL	DEINT		; Get integer -32768 to 32767
0EA8: F1       [151]    	POP	AF		; Restore "AND" / "OR" flag
0EA9: C1       [161]    	POP	BC		; Get value
0EAA: 79       [165]    	LD	A,C		; Get LSB
0EAB: 210411   [175]    	LD	HL,ACPASS	; Address of save AC as current
0EAE: C2B60E   [185|185]	JP	NZ,POR1		; Jump if OR
0EB1: A3       [189]    	AND	E		; "AND" LSBs
0EB2: 4F       [193]    	LD	C,A		; Save LSB
0EB3: 78       [197]    	LD	A,B		; Get MBS
0EB4: A2       [201]    	AND	D		; "AND" MSBs
0EB5: E9       [205]    	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0EB6: B3       [ 4]     POR1:	OR	E		; "OR" LSBs
0EB7: 4F       [ 8]     	LD	C,A		; Save LSB
0EB8: 78       [12]     	LD	A,B		; Get MSB
0EB9: B2       [16]     	OR	D		; "OR" MSBs
0EBA: E9       [20]     	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0EBB: 21CD0E   [10]     TSTRED: LD	HL,CMPLOG	; Logical compare routine
0EBE: 3AF280   [23]     	LD	A,(TYPE)	; Get data type
0EC1: 1F       [27]     	RRA			; Carry set = string
0EC2: 7A       [31]     	LD	A,D		; Get last precedence value
0EC3: 17       [35]     	RLA			; Times 2 plus carry
0EC4: 5F       [39]     	LD	E,A		; To E
0EC5: 1664     [46]     	LD	D,64H		; Relational precedence
0EC7: 78       [50]     	LD	A,B		; Get current precedence
0EC8: BA       [54]     	CP	D		; Compare with last
0EC9: D0       [59|65]  	RET	NC		; Eval if last was rel' or log'
0ECA: C3BC0D   [69]     	JP	STKTHS		; Stack this one and get next
                        ;
0ECD: CF0E              CMPLOG: DW	CMPLG1		; Compare two values / strings
0ECF: 79       [ 4]     CMPLG1: LD	A,C		; Get data type
0ED0: B7       [ 8]     	OR	A
0ED1: 1F       [12]     	RRA
0ED2: C1       [22]     	POP	BC		; Get last expression to BCDE
0ED3: D1       [32]     	POP	DE
0ED4: F5       [43]     	PUSH	AF		; Save status
0ED5: CD4F0D   [60]     	CALL	CHKTYP		; Check that types match
0ED8: 21110F   [70]     	LD	HL,CMPRES	; Result to comparison
0EDB: E5       [81]     	PUSH	HL		; Save for RETurn
0EDC: CAA717   [91|91]  	JP	Z,CMPNUM	; Compare values if numeric
0EDF: AF       [95]     	XOR	A		; Compare two strings
0EE0: 32F280   [108]    	LD	(TYPE),A	; Set type to numeric
0EE3: D5       [119]    	PUSH	DE		; Save string name
0EE4: CD6613   [136]    	CALL	GSTRCU		; Get current string
0EE7: 7E       [143]    	LD	A,(HL)		; Get length of string
0EE8: 23       [149]    	INC	HL
0EE9: 23       [155]    	INC	HL
0EEA: 4E       [162]    	LD	C,(HL)		; Get LSB of address
0EEB: 23       [168]    	INC	HL
0EEC: 46       [175]    	LD	B,(HL)		; Get MSB of address
0EED: D1       [185]    	POP	DE		; Restore string name
0EEE: C5       [196]    	PUSH	BC		; Save address of string
0EEF: F5       [207]    	PUSH	AF		; Save length of string
0EF0: CD6A13   [224]    	CALL	GSTRDE		; Get second string
0EF3: CD7B17   [241]    	CALL	LOADFP		; Get address of second string
0EF6: F1       [251]    	POP	AF		; Restore length of string 1
0EF7: 57       [255]    	LD	D,A		; Length to D
0EF8: E1       [265]    	POP	HL		; Restore address of string 1
0EF9: 7B       [ 4]     CMPSTR: LD	A,E		; Bytes of string 2 to do
0EFA: B2       [ 8]     	OR	D		; Bytes of string 1 to do
0EFB: C8       [13|19]  	RET	Z		; Exit if all bytes compared
0EFC: 7A       [17]     	LD	A,D		; Get bytes of string 1 to do
0EFD: D601     [24]     	SUB	1
0EFF: D8       [29|35]  	RET	C		; Exit if end of string 1
0F00: AF       [33]     	XOR	A
0F01: BB       [37]     	CP	E		; Bytes of string 2 to do
0F02: 3C       [41]     	INC	A
0F03: D0       [46|52]  	RET	NC		; Exit if end of string 2
0F04: 15       [50]     	DEC	D		; Count bytes in string 1
0F05: 1D       [54]     	DEC	E		; Count bytes in string 2
0F06: 0A       [61]     	LD	A,(BC)		; Byte in string 2
0F07: BE       [68]     	CP	(HL)		; Compare to byte in string 1
0F08: 23       [74]     	INC	HL		; Move up string 1
0F09: 03       [80]     	INC	BC		; Move up string 2
0F0A: CAF90E   [90|90]  	JP	Z,CMPSTR	; Same - Try next bytes
0F0D: 3F       [94]     	CCF			; Flag difference (">" or "<")
0F0E: C33717   [104]    	JP	FLGDIF		; "<" gives -1 , ">" gives +1
                        ;
0F11: 3C       [ 4]     CMPRES: INC	A		; Increment current value
0F12: 8F       [ 8]     	ADC	A,A		; Double plus carry
0F13: C1       [18]     	POP	BC		; Get other value
0F14: A0       [22]     	AND	B		; Combine them
0F15: C6FF     [29]     	ADD	A,-1		; Carry set if different
0F17: 9F       [33]     	SBC	A,A		; 00 - Equal , FF - Different
0F18: C33E17   [43]     	JP	FLGREL		; Set current value & continue
                        ;
0F1B: 165A     [ 7]     EVNOT:	LD	D,5AH		; Precedence value for "NOT"
0F1D: CD5F0D   [24]     	CALL	EVAL1		; Eval until precedence break
0F20: CD4D0D   [41]     	CALL	TSTNUM		; Make sure it's a number
0F23: CD8F09   [58]     	CALL	DEINT		; Get integer -32768 - 32767
0F26: 7B       [62]     	LD	A,E		; Get LSB
0F27: 2F       [66]     	CPL			; Invert LSB
0F28: 4F       [70]     	LD	C,A		; Save "NOT" of LSB
0F29: 7A       [74]     	LD	A,D		; Get MSB
0F2A: 2F       [78]     	CPL			; Invert MSB
0F2B: CD0411   [95]     	CALL	ACPASS		; Save AC as current
0F2E: C1       [105]    	POP	BC		; Clean up stack
0F2F: C36B0D   [115]    	JP	EVAL3		; Continue evaluation
                        ;
0F32: 2B       [ 6]     DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
0F33: CDDD08   [23]     	CALL	GETCHR		; Get next character
0F36: C8       [28|34]  	RET	Z		; End of DIM statement
0F37: CD5307   [45]     	CALL	CHKSYN		; Make sure ',' follows
0F3A: 2C                	DB	','
0F3B: 01320F   [10]     DIM:	LD	BC,DIMRET	; Return to "DIMRET"
0F3E: C5       [21]     	PUSH	BC		; Save on stack
0F3F: F6                	DB	0F6H		; Flag "Create" variable
0F40: AF       [ 4]     GETVAR: XOR	A		; Find variable address,to DE
0F41: 32F180   [17]     	LD	(LCRFLG),A	; Set locate / create flag
0F44: 46       [24]     	LD	B,(HL)		; Get First byte of name
0F45: CD7B09   [17]     GTFNAM: CALL	CHKLTR		; See if a letter
0F48: DA8504   [27|27]  	JP	C,SNERR		; ?SN Error if not a letter
0F4B: AF       [31]     	XOR	A
0F4C: 4F       [35]     	LD	C,A		; Clear second byte of name
0F4D: 32F280   [48]     	LD	(TYPE),A	; Set type to numeric
0F50: CDDD08   [65]     	CALL	GETCHR		; Get next character
0F53: DA5C0F   [75|75]  	JP	C,SVNAM2	; Numeric - Save in name
0F56: CD7B09   [92]     	CALL	CHKLTR		; See if a letter
0F59: DA690F   [102|102]	JP	C,CHARTY	; Not a letter - Check type
0F5C: 4F       [ 4]     SVNAM2: LD	C,A		; Save second byte of name
0F5D: CDDD08   [17]     ENDNAM: CALL	GETCHR		; Get next character
0F60: DA5D0F   [27|27]  	JP	C,ENDNAM	; Numeric - Get another
0F63: CD7B09   [44]     	CALL	CHKLTR		; See if a letter
0F66: D25D0F   [54|54]  	JP	NC,ENDNAM	; Letter - Get another
0F69: D624     [ 7]     CHARTY: SUB	'$'		; String variable?
0F6B: C2780F   [17|17]  	JP	NZ,NOTSTR	; No - Numeric variable
0F6E: 3C       [21]     	INC	A		; A = 1 (string type)
0F6F: 32F280   [34]     	LD	(TYPE),A	; Set type to string
0F72: 0F       [38]     	RRCA			; A = 80H , Flag for string
0F73: 81       [42]     	ADD	A,C		; 2nd byte of name has bit 7 on
0F74: 4F       [46]     	LD	C,A		; Resave second byte on name
0F75: CDDD08   [63]     	CALL	GETCHR		; Get next character
0F78: 3A1081   [13]     NOTSTR: LD	A,(FORFLG)	; Array name needed ?
0F7B: 3D       [17]     	DEC	A
0F7C: CA2510   [27|27]  	JP	Z,ARLDSV	; Yes - Get array name
0F7F: F2880F   [37|37]  	JP	P,NSCFOR	; No array with "FOR" or "FN"
0F82: 7E       [44]     	LD	A,(HL)		; Get byte again
0F83: D628     [51]     	SUB	'('		; Subscripted variable?
0F85: CAFD0F   [61|61]  	JP	Z,SBSCPT	; Yes - Sort out subscript
                        ;
0F88: AF       [ 4]     NSCFOR: XOR	A		; Simple variable
0F89: 321081   [17]     	LD	(FORFLG),A	; Clear "FOR" flag
0F8C: E5       [28]     	PUSH	HL		; Save code string address
0F8D: 50       [32]     	LD	D,B		; DE = Variable name to find
0F8E: 59       [36]     	LD	E,C
0F8F: 2A2381   [52]     	LD	HL,(FNRGNM)	; FN argument name
0F92: CD4D07   [69]     	CALL	CPDEHL		; Is it the FN argument?
0F95: 112581   [79]     	LD	DE,FNARG	; Point to argument value
0F98: CA6D16   [89|89]  	JP	Z,POPHRT	; Yes - Return FN argument value
0F9B: 2A1D81   [105]    	LD	HL,(VAREND)	; End of variables
0F9E: EB       [109]    	EX	DE,HL		; Address of end of search
0F9F: 2A1B81   [125]    	LD	HL,(PROGND)	; Start of variables address
0FA2: CD4D07   [17]     FNDVAR: CALL	CPDEHL		; End of variable list table?
0FA5: CABB0F   [27|27]  	JP	Z,CFEVAL	; Yes - Called from EVAL?
0FA8: 79       [31]     	LD	A,C		; Get second byte of name
0FA9: 96       [38]     	SUB	(HL)		; Compare with name in list
0FAA: 23       [44]     	INC	HL		; Move on to first byte
0FAB: C2B00F   [54|54]  	JP	NZ,FNTHR	; Different - Find another
0FAE: 78       [58]     	LD	A,B		; Get first byte of name
0FAF: 96       [65]     	SUB	(HL)		; Compare with name in list
0FB0: 23       [ 6]     FNTHR:	INC	HL		; Move on to LSB of value
0FB1: CAEF0F   [16|16]  	JP	Z,RETADR	; Found - Return address
0FB4: 23       [22]     	INC	HL		; <- Skip
0FB5: 23       [28]     	INC	HL		; <- over
0FB6: 23       [34]     	INC	HL		; <- F.P.
0FB7: 23       [40]     	INC	HL		; <- value
0FB8: C3A20F   [50]     	JP	FNDVAR		; Keep looking
                        ;
0FBB: E1       [10]     CFEVAL: POP	HL		; Restore code string address
0FBC: E3       [29]     	EX	(SP),HL		; Get return address
0FBD: D5       [40]     	PUSH	DE		; Save address of variable
0FBE: 113D0E   [50]     	LD	DE,FRMEVL	; Return address in EVAL
0FC1: CD4D07   [67]     	CALL	CPDEHL		; Called from EVAL ?
0FC4: D1       [77]     	POP	DE		; Restore address of variable
0FC5: CAF20F   [87|87]  	JP	Z,RETNUL	; Yes - Return null variable
0FC8: E3       [106]    	EX	(SP),HL		; Put back return
0FC9: E5       [117]    	PUSH	HL		; Save code string address
0FCA: C5       [128]    	PUSH	BC		; Save variable name
0FCB: 010600   [138]    	LD	BC,6		; 2 byte name plus 4 byte data
0FCE: 2A1F81   [154]    	LD	HL,(ARREND)	; End of arrays
0FD1: E5       [165]    	PUSH	HL		; Save end of arrays
0FD2: 09       [176]    	ADD	HL,BC		; Move up 6 bytes
0FD3: C1       [186]    	POP	BC		; Source address in BC
0FD4: E5       [197]    	PUSH	HL		; Save new end address
0FD5: CD5104   [214]    	CALL	MOVUP		; Move arrays up
0FD8: E1       [224]    	POP	HL		; Restore new end address
0FD9: 221F81   [240]    	LD	(ARREND),HL	; Set new end address
0FDC: 60       [244]    	LD	H,B		; End of variables to HL
0FDD: 69       [248]    	LD	L,C
0FDE: 221D81   [264]    	LD	(VAREND),HL	; Set new end address
                        ;
0FE1: 2B       [ 6]     ZEROLP: DEC	HL		; Back through to zero variable
0FE2: 3600     [16]     	LD	(HL),0		; Zero byte in variable
0FE4: CD4D07   [33]     	CALL	CPDEHL		; Done them all?
0FE7: C2E10F   [43|43]  	JP	NZ,ZEROLP	; No - Keep on going
0FEA: D1       [53]     	POP	DE		; Get variable name
0FEB: 73       [60]     	LD	(HL),E		; Store second character
0FEC: 23       [66]     	INC	HL
0FED: 72       [73]     	LD	(HL),D		; Store first character
0FEE: 23       [79]     	INC	HL
0FEF: EB       [ 4]     RETADR: EX	DE,HL		; Address of variable in DE
0FF0: E1       [14]     	POP	HL		; Restore code string address
0FF1: C9       [24]     	RET
                        ;
0FF2: 322C81   [13]     RETNUL: LD	(FPEXP),A	; Set result to zero
0FF5: 212104   [23]     	LD	HL,ZERBYT	; Also set a null string
0FF8: 222981   [39]     	LD	(FPREG),HL	; Save for EVAL
0FFB: E1       [49]     	POP	HL		; Restore code string address
0FFC: C9       [59]     	RET
                        ;
0FFD: E5       [11]     SBSCPT: PUSH	HL		; Save code string address
0FFE: 2AF180   [27]     	LD	HL,(LCRFLG)	; Locate/Create and Type
1001: E3       [46]     	EX	(SP),HL		; Save and get code string
1002: 57       [50]     	LD	D,A		; Zero number of dimensions
1003: D5       [11]     SCPTLP: PUSH	DE		; Save number of dimensions
1004: C5       [22]     	PUSH	BC		; Save array name
1005: CD8309   [39]     	CALL	FPSINT		; Get subscript (0-32767)
1008: C1       [49]     	POP	BC		; Restore array name
1009: F1       [59]     	POP	AF		; Get number of dimensions
100A: EB       [63]     	EX	DE,HL
100B: E3       [82]     	EX	(SP),HL		; Save subscript value
100C: E5       [93]     	PUSH	HL		; Save LCRFLG and TYPE
100D: EB       [97]     	EX	DE,HL
100E: 3C       [101]    	INC	A		; Count dimensions
100F: 57       [105]    	LD	D,A		; Save in D
1010: 7E       [112]    	LD	A,(HL)		; Get next byte in code string
1011: FE2C     [119]    	CP	','		; Comma (more to come)?
1013: CA0310   [129|129]	JP	Z,SCPTLP	; Yes - More subscripts
1016: CD5307   [146]    	CALL	CHKSYN		; Make sure ")" follows
1019: 29                	DB	")"
101A: 221581   [162]    	LD	(NXTOPR),HL	; Save code string address
101D: E1       [172]    	POP	HL		; Get LCRFLG and TYPE
101E: 22F180   [188]    	LD	(LCRFLG),HL	; Restore Locate/create & type
1021: 1E00     [195]    	LD	E,0		; Flag not CSAVE* or CLOAD*
1023: D5       [206]    	PUSH	DE		; Save number of dimensions (D)
1024: 11                	DB	11H		; Skip "PUSH HL" and "PUSH AF'
                        ;
1025: E5       [11]     ARLDSV: PUSH	HL		; Save code string address
1026: F5       [22]     	PUSH	AF		; A = 00 , Flags set = Z,N
1027: 2A1D81   [38]     	LD	HL,(VAREND)	; Start of arrays
102A: 3E                	DB	3EH		; Skip "ADD HL,DE"
102B: 19       [11]     FNDARY: ADD	HL,DE		; Move to next array start
102C: EB       [15]     	EX	DE,HL
102D: 2A1F81   [31]     	LD	HL,(ARREND)	; End of arrays
1030: EB       [35]     	EX	DE,HL		; Current array pointer
1031: CD4D07   [52]     	CALL	CPDEHL		; End of arrays found?
1034: CA5D10   [62|62]  	JP	Z,CREARY	; Yes - Create array
1037: 7E       [69]     	LD	A,(HL)		; Get second byte of name
1038: B9       [73]     	CP	C		; Compare with name given
1039: 23       [79]     	INC	HL		; Move on
103A: C23F10   [89|89]  	JP	NZ,NXTARY	; Different - Find next array
103D: 7E       [96]     	LD	A,(HL)		; Get first byte of name
103E: B8       [100]    	CP	B		; Compare with name given
103F: 23       [ 6]     NXTARY: INC	HL		; Move on
1040: 5E       [13]     	LD	E,(HL)		; Get LSB of next array address
1041: 23       [19]     	INC	HL
1042: 56       [26]     	LD	D,(HL)		; Get MSB of next array address
1043: 23       [32]     	INC	HL
1044: C22B10   [42|42]  	JP	NZ,FNDARY	; Not found - Keep looking
1047: 3AF180   [55]     	LD	A,(LCRFLG)	; Found Locate or Create it?
104A: B7       [59]     	OR	A
104B: C28E04   [69|69]  	JP	NZ,DDERR	; Create - ?DD Error
104E: F1       [79]     	POP	AF		; Locate - Get number of dim'ns
104F: 44       [83]     	LD	B,H		; BC Points to array dim'ns
1050: 4D       [87]     	LD	C,L
1051: CA6D16   [97|97]  	JP	Z,POPHRT	; Jump if array load/save
1054: 96       [104]    	SUB	(HL)		; Same number of dimensions?
1055: CABB10   [114|114]	JP	Z,FINDEL	; Yes - Find element
1058: 1E10     [ 7]     BSERR:	LD	E,BS		; ?BS Error
105A: C39904   [17]     	JP	ERROR		; Output error
                        ;
105D: 110400   [10]     CREARY: LD	DE,4		; 4 Bytes per entry
1060: F1       [20]     	POP	AF		; Array to save or 0 dim'ns?
1061: CAA409   [30|30]  	JP	Z,FCERR		; Yes - ?FC Error
1064: 71       [37]     	LD	(HL),C		; Save second byte of name
1065: 23       [43]     	INC	HL
1066: 70       [50]     	LD	(HL),B		; Save first byte of name
1067: 23       [56]     	INC	HL
1068: 4F       [60]     	LD	C,A		; Number of dimensions to C
1069: CD6204   [77]     	CALL	CHKSTK		; Check if enough memory
106C: 23       [83]     	INC	HL		; Point to number of dimensions
106D: 23       [89]     	INC	HL
106E: 220A81   [105]    	LD	(CUROPR),HL	; Save address of pointer
1071: 71       [112]    	LD	(HL),C		; Set number of dimensions
1072: 23       [118]    	INC	HL
1073: 3AF180   [131]    	LD	A,(LCRFLG)	; Locate of Create?
1076: 17       [135]    	RLA			; Carry set = Create
1077: 79       [139]    	LD	A,C		; Get number of dimensions
1078: 010B00   [10]     CRARLP: LD	BC,10+1		; Default dimension size 10
107B: D28010   [20|20]  	JP	NC,DEFSIZ	; Locate - Set default size
107E: C1       [30]     	POP	BC		; Get specified dimension size
107F: 03       [36]     	INC	BC		; Include zero element
1080: 71       [ 7]     DEFSIZ: LD	(HL),C		; Save LSB of dimension size
1081: 23       [13]     	INC	HL
1082: 70       [20]     	LD	(HL),B		; Save MSB of dimension size
1083: 23       [26]     	INC	HL
1084: F5       [37]     	PUSH	AF		; Save num' of dim'ns an status
1085: E5       [48]     	PUSH	HL		; Save address of dim'n size
1086: CD1818   [65]     	CALL	MLDEBC		; Multiply DE by BC to find
1089: EB       [69]     	EX	DE,HL		; amount of mem needed (to DE)
108A: E1       [79]     	POP	HL		; Restore address of dimension
108B: F1       [89]     	POP	AF		; Restore number of dimensions
108C: 3D       [93]     	DEC	A		; Count them
108D: C27810   [103|103]	JP	NZ,CRARLP	; Do next dimension if more
1090: F5       [114]    	PUSH	AF		; Save locate/create flag
1091: 42       [118]    	LD	B,D		; MSB of memory needed
1092: 4B       [122]    	LD	C,E		; LSB of memory needed
1093: EB       [126]    	EX	DE,HL
1094: 19       [137]    	ADD	HL,DE		; Add bytes to array start
1095: DA7A04   [147|147]	JP	C,OMERR		; Too big - Error
1098: CD6B04   [164]    	CALL	ENFMEM		; See if enough memory
109B: 221F81   [180]    	LD	(ARREND),HL	; Save new end of array
                        ;
109E: 2B       [ 6]     ZERARY: DEC	HL		; Back through array data
109F: 3600     [16]     	LD	(HL),0		; Set array element to zero
10A1: CD4D07   [33]     	CALL	CPDEHL		; All elements zeroed?
10A4: C29E10   [43|43]  	JP	NZ,ZERARY	; No - Keep on going
10A7: 03       [49]     	INC	BC		; Number of bytes + 1
10A8: 57       [53]     	LD	D,A		; A=0
10A9: 2A0A81   [69]     	LD	HL,(CUROPR)	; Get address of array
10AC: 5E       [76]     	LD	E,(HL)		; Number of dimensions
10AD: EB       [80]     	EX	DE,HL		; To HL
10AE: 29       [91]     	ADD	HL,HL		; Two bytes per dimension size
10AF: 09       [102]    	ADD	HL,BC		; Add number of bytes
10B0: EB       [106]    	EX	DE,HL		; Bytes needed to DE
10B1: 2B       [112]    	DEC	HL
10B2: 2B       [118]    	DEC	HL
10B3: 73       [125]    	LD	(HL),E		; Save LSB of bytes needed
10B4: 23       [131]    	INC	HL
10B5: 72       [138]    	LD	(HL),D		; Save MSB of bytes needed
10B6: 23       [144]    	INC	HL
10B7: F1       [154]    	POP	AF		; Locate / Create?
10B8: DADF10   [164|164]	JP	C,ENDDIM	; A is 0 , End if create
10BB: 47       [ 4]     FINDEL: LD	B,A		; Find array element
10BC: 4F       [ 8]     	LD	C,A
10BD: 7E       [15]     	LD	A,(HL)		; Number of dimensions
10BE: 23       [21]     	INC	HL
10BF: 16                	DB	16H		; Skip "POP HL"
10C0: E1       [10]     FNDELP: POP	HL		; Address of next dim' size
10C1: 5E       [17]     	LD	E,(HL)		; Get LSB of dim'n size
10C2: 23       [23]     	INC	HL
10C3: 56       [30]     	LD	D,(HL)		; Get MSB of dim'n size
10C4: 23       [36]     	INC	HL
10C5: E3       [55]     	EX	(SP),HL		; Save address - Get index
10C6: F5       [66]     	PUSH	AF		; Save number of dim'ns
10C7: CD4D07   [83]     	CALL	CPDEHL		; Dimension too large?
10CA: D25810   [93|93]  	JP	NC,BSERR	; Yes - ?BS Error
10CD: E5       [104]    	PUSH	HL		; Save index
10CE: CD1818   [121]    	CALL	MLDEBC		; Multiply previous by size
10D1: D1       [131]    	POP	DE		; Index supplied to DE
10D2: 19       [142]    	ADD	HL,DE		; Add index to pointer
10D3: F1       [152]    	POP	AF		; Number of dimensions
10D4: 3D       [156]    	DEC	A		; Count them
10D5: 44       [160]    	LD	B,H		; MSB of pointer
10D6: 4D       [164]    	LD	C,L		; LSB of pointer
10D7: C2C010   [174|174]	JP	NZ,FNDELP	; More - Keep going
10DA: 29       [185]    	ADD	HL,HL		; 4 Bytes per element
10DB: 29       [196]    	ADD	HL,HL
10DC: C1       [206]    	POP	BC		; Start of array
10DD: 09       [217]    	ADD	HL,BC		; Point to element
10DE: EB       [221]    	EX	DE,HL		; Address of element to DE
10DF: 2A1581   [16]     ENDDIM: LD	HL,(NXTOPR)	; Got code string address
10E2: C9       [26]     	RET
                        ;
10E3: 2A1F81   [16]     FRE:	LD	HL,(ARREND)	; Start of free memory
10E6: EB       [20]     	EX	DE,HL		; To DE
10E7: 210000   [30]     	LD	HL,0		; End of free memory
10EA: 39       [41]     	ADD	HL,SP		; Current stack value
10EB: 3AF280   [54]     	LD	A,(TYPE)	; Dummy argument type
10EE: B7       [58]     	OR	A
10EF: CAFF10   [68|68]  	JP	Z,FRENUM	; Numeric - Free variable space
10F2: CD6613   [85]     	CALL	GSTRCU		; Current string to pool
10F5: CD6612   [102]    	CALL	GARBGE		; Garbage collection
10F8: 2A9F80   [118]    	LD	HL,(STRSPC)	; Bottom of string space in use
10FB: EB       [122]    	EX	DE,HL		; To DE
10FC: 2A0881   [138]    	LD	HL,(STRBOT)	; Bottom of string space
10FF: 7D       [ 4]     FRENUM: LD	A,L		; Get LSB of end
1100: 93       [ 8]     	SUB	E		; Subtract LSB of beginning
1101: 4F       [12]     	LD	C,A		; Save difference if C
1102: 7C       [16]     	LD	A,H		; Get MSB of end
1103: 9A       [20]     	SBC	A,D		; Subtract MSB of beginning
1104: 41       [ 4]     ACPASS: LD	B,C		; Return integer AC
1105: 50       [ 4]     ABPASS: LD	D,B		; Return integer AB
1106: 1E00     [11]     	LD	E,0
1108: 21F280   [21]     	LD	HL,TYPE		; Point to type
110B: 73       [28]     	LD	(HL),E		; Set type to numeric
110C: 0690     [35]     	LD	B,80H+16	; 16 bit integer
110E: C34317   [45]     	JP	RETINT		; Return the integr
                        ;
1111: 3AF080   [13]     POS:	LD	A,(CURPOS)	; Get cursor position
1114: 47       [ 4]     PASSA:	LD	B,A		; Put A into AB
1115: AF       [ 8]     	XOR	A		; Zero A
1116: C30511   [18]     	JP	ABPASS		; Return integer AB
                        ;
1119: CD9C11   [17]     DEF:	CALL	CHEKFN		; Get "FN" and name
111C: CD8E11   [34]     	CALL	IDTEST		; Test for illegal direct
111F: 01740A   [44]     	LD	BC,DATA		; To get next statement
1122: C5       [55]     	PUSH	BC		; Save address for RETurn
1123: D5       [66]     	PUSH	DE		; Save address of function ptr
1124: CD5307   [83]     	CALL	CHKSYN		; Make sure "(" follows
1127: 28                	DB	"("
1128: CD400F   [100]    	CALL	GETVAR		; Get argument variable name
112B: E5       [111]    	PUSH	HL		; Save code string address
112C: EB       [115]    	EX	DE,HL		; Argument address to HL
112D: 2B       [121]    	DEC	HL
112E: 56       [128]    	LD	D,(HL)		; Get first byte of arg name
112F: 2B       [134]    	DEC	HL
1130: 5E       [141]    	LD	E,(HL)		; Get second byte of arg name
1131: E1       [151]    	POP	HL		; Restore code string address
1132: CD4D0D   [168]    	CALL	TSTNUM		; Make sure numeric argument
1135: CD5307   [185]    	CALL	CHKSYN		; Make sure ")" follows
1138: 29                	DB	")"
1139: CD5307   [202]    	CALL	CHKSYN		; Make sure "=" follows
113C: B4                	DB	ZEQUAL		; "=" token
113D: 44       [206]    	LD	B,H		; Code string address to BC
113E: 4D       [210]    	LD	C,L
113F: E3       [229]    	EX	(SP),HL		; Save code str , Get FN ptr
1140: 71       [236]    	LD	(HL),C		; Save LSB of FN code string
1141: 23       [242]    	INC	HL
1142: 70       [249]    	LD	(HL),B		; Save MSB of FN code string
1143: C3DB11   [259]    	JP	SVSTAD		; Save address and do function
                        ;
1146: CD9C11   [17]     DOFN:	CALL	CHEKFN		; Make sure FN follows
1149: D5       [28]     	PUSH	DE		; Save function pointer address
114A: CD210E   [45]     	CALL	EVLPAR		; Evaluate expression in "()"
114D: CD4D0D   [62]     	CALL	TSTNUM		; Make sure numeric result
1150: E3       [81]     	EX	(SP),HL		; Save code str , Get FN ptr
1151: 5E       [88]     	LD	E,(HL)		; Get LSB of FN code string
1152: 23       [94]     	INC	HL
1153: 56       [101]    	LD	D,(HL)		; Get MSB of FN code string
1154: 23       [107]    	INC	HL
1155: 7A       [111]    	LD	A,D		; And function DEFined?
1156: B3       [115]    	OR	E
1157: CA9104   [125|125]	JP	Z,UFERR		; No - ?UF Error
115A: 7E       [132]    	LD	A,(HL)		; Get LSB of argument address
115B: 23       [138]    	INC	HL
115C: 66       [145]    	LD	H,(HL)		; Get MSB of argument address
115D: 6F       [149]    	LD	L,A		; HL = Arg variable address
115E: E5       [160]    	PUSH	HL		; Save it
115F: 2A2381   [176]    	LD	HL,(FNRGNM)	; Get old argument name
1162: E3       [195]    	EX	(SP),HL;	; Save old , Get new
1163: 222381   [211]    	LD	(FNRGNM),HL	; Set new argument name
1166: 2A2781   [227]    	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
1169: E5       [238]    	PUSH	HL		; Save it
116A: 2A2581   [254]    	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
116D: E5       [265]    	PUSH	HL		; Save it
116E: 212581   [275]    	LD	HL,FNARG	; HL = Value of argument
1171: D5       [286]    	PUSH	DE		; Save FN code string address
1172: CD8417   [303]    	CALL	FPTHL		; Move FPREG to argument
1175: E1       [313]    	POP	HL		; Get FN code string address
1176: CD4A0D   [330]    	CALL	GETNUM		; Get value from function
1179: 2B       [336]    	DEC	HL		; DEC 'cos GETCHR INCs
117A: CDDD08   [353]    	CALL	GETCHR		; Get next character
117D: C28504   [363|363]	JP	NZ,SNERR	; Bad character in FN - Error
1180: E1       [373]    	POP	HL		; Get MSB,EXP of old arg
1181: 222581   [389]    	LD	(FNARG),HL	; Restore it
1184: E1       [399]    	POP	HL		; Get LSB,NLSB of old arg
1185: 222781   [415]    	LD	(FNARG+2),HL	; Restore it
1188: E1       [425]    	POP	HL		; Get name of old arg
1189: 222381   [441]    	LD	(FNRGNM),HL	; Restore it
118C: E1       [451]    	POP	HL		; Restore code string address
118D: C9       [461]    	RET
                        ;
118E: E5       [11]     IDTEST: PUSH	HL		; Save code string address
118F: 2AA180   [27]     	LD	HL,(LINEAT)	; Get current line number
1192: 23       [33]     	INC	HL		; -1 means direct statement
1193: 7C       [37]     	LD	A,H
1194: B5       [41]     	OR	L
1195: E1       [51]     	POP	HL		; Restore code string address
1196: C0       [56|62]  	RET	NZ		; Return if in program
1197: 1E16     [63]     	LD	E,ID		; ?ID Error
1199: C39904   [73]     	JP	ERROR
                        ;
119C: CD5307   [17]     CHEKFN: CALL	CHKSYN		; Make sure FN follows
119F: A7                	DB	ZFN		; "FN" token
11A0: 3E80     [24]     	LD	A,80H
11A2: 321081   [37]     	LD	(FORFLG),A	; Flag FN name to find
11A5: B6       [44]     	OR	(HL)		; FN name has bit 7 set
11A6: 47       [48]     	LD	B,A		; in first byte of name
11A7: CD450F   [65]     	CALL	GTFNAM		; Get FN name
11AA: C34D0D   [75]     	JP	TSTNUM		; Make sure numeric function
                        ;
11AD: CD4D0D   [17]     STR:	CALL	TSTNUM		; Make sure it's a number
11B0: CDD118   [34]     	CALL	NUMASC		; Turn number into text
11B3: CDE111   [17]     STR1:	CALL	CRTST		; Create string entry for it
11B6: CD6613   [34]     	CALL	GSTRCU		; Current string to pool
11B9: 01C113   [44]     	LD	BC,TOPOOL	; Save in string pool
11BC: C5       [55]     	PUSH	BC		; Save address on stack
                        ;
11BD: 7E       [ 7]     SAVSTR: LD	A,(HL)		; Get string length
11BE: 23       [13]     	INC	HL
11BF: 23       [19]     	INC	HL
11C0: E5       [30]     	PUSH	HL		; Save pointer to string
11C1: CD3C12   [47]     	CALL	TESTR		; See if enough string space
11C4: E1       [57]     	POP	HL		; Restore pointer to string
11C5: 4E       [64]     	LD	C,(HL)		; Get LSB of address
11C6: 23       [70]     	INC	HL
11C7: 46       [77]     	LD	B,(HL)		; Get MSB of address
11C8: CDD511   [94]     	CALL	CRTMST		; Create string entry
11CB: E5       [105]    	PUSH	HL		; Save pointer to MSB of addr
11CC: 6F       [109]    	LD	L,A		; Length of string
11CD: CD5913   [126]    	CALL	TOSTRA		; Move to string area
11D0: D1       [136]    	POP	DE		; Restore pointer to MSB
11D1: C9       [146]    	RET
                        ;
11D2: CD3C12   [17]     MKTMST: CALL	TESTR		; See if enough string space
11D5: 210481   [10]     CRTMST: LD	HL,TMPSTR	; Temporary string
11D8: E5       [21]     	PUSH	HL		; Save it
11D9: 77       [28]     	LD	(HL),A		; Save length of string
11DA: 23       [34]     	INC	HL
11DB: 23       [ 6]     SVSTAD: INC	HL
11DC: 73       [13]     	LD	(HL),E		; Save LSB of address
11DD: 23       [19]     	INC	HL
11DE: 72       [26]     	LD	(HL),D		; Save MSB of address
11DF: E1       [36]     	POP	HL		; Restore pointer
11E0: C9       [46]     	RET
                        ;
11E1: 2B       [ 6]     CRTST:	DEC	HL		; DEC - INCed after
11E2: 0622     [ 7]     QTSTR:	LD	B,'"'		; Terminating quote
11E4: 50       [11]     	LD	D,B		; Quote to D
11E5: E5       [11]     DTSTR:	PUSH	HL		; Save start
11E6: 0EFF     [18]     	LD	C,-1		; Set counter to -1
11E8: 23       [ 6]     QTSTLP: INC	HL		; Move on
11E9: 7E       [13]     	LD	A,(HL)		; Get byte
11EA: 0C       [17]     	INC	C		; Count bytes
11EB: B7       [21]     	OR	A		; End of line?
11EC: CAF711   [31|31]  	JP	Z,CRTSTE	; Yes - Create string entry
11EF: BA       [35]     	CP	D		; Terminator D found?
11F0: CAF711   [45|45]  	JP	Z,CRTSTE	; Yes - Create string entry
11F3: B8       [49]     	CP	B		; Terminator B found?
11F4: C2E811   [59|59]  	JP	NZ,QTSTLP	; No - Keep looking
11F7: FE22     [ 7]     CRTSTE: CP	'"'		; End with '"'?
11F9: CCDD08   [17|24]  	CALL	Z,GETCHR	; Yes - Get next character
11FC: E3       [36]     	EX	(SP),HL		; Starting quote
11FD: 23       [42]     	INC	HL		; First byte of string
11FE: EB       [46]     	EX	DE,HL		; To DE
11FF: 79       [50]     	LD	A,C		; Get length
1200: CDD511   [67]     	CALL	CRTMST		; Create string entry
1203: 110481   [10]     TSTOPL: LD	DE,TMPSTR	; Temporary string
1206: 2AF680   [26]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
1209: 222981   [42]     	LD	(FPREG),HL	; Save address of string ptr
120C: 3E01     [49]     	LD	A,1
120E: 32F280   [62]     	LD	(TYPE),A	; Set type to string
1211: CD8717   [79]     	CALL	DETHL4		; Move string to pool
1214: CD4D07   [96]     	CALL	CPDEHL		; Out of string pool?
1217: 22F680   [112]    	LD	(TMSTPT),HL	; Save new pointer
121A: E1       [122]    	POP	HL		; Restore code string address
121B: 7E       [129]    	LD	A,(HL)		; Get next code byte
121C: C0       [134|140]	RET	NZ		; Return if pool OK
121D: 1E1E     [141]    	LD	E,ST		; ?ST Error
121F: C39904   [151]    	JP	ERROR		; String pool overflow
                        ;
1222: 23       [ 6]     PRNUMS: INC	HL		; Skip leading space
1223: CDE111   [17]     PRS:	CALL	CRTST		; Create string entry for it
1226: CD6613   [17]     PRS1:	CALL	GSTRCU		; Current string to pool
1229: CD7B17   [34]     	CALL	LOADFP		; Move string block to BCDE
122C: 1C       [38]     	INC	E		; Length + 1
122D: 1D       [ 4]     PRSLP:	DEC	E		; Count characters
122E: C8       [ 9|15]  	RET	Z		; End of string
122F: 0A       [16]     	LD	A,(BC)		; Get byte to output
1230: CD5E07   [33]     	CALL	OUTC		; Output character in A
1233: FE0D     [40]     	CP	CR		; Return?
1235: CC8F0B   [50|57]  	CALL	Z,DONULL	; Yes - Do nulls
1238: 03       [56]     	INC	BC		; Next byte in string
1239: C32D12   [66]     	JP	PRSLP		; More characters to output
                        ;
123C: B7       [ 4]     TESTR:	OR	A		; Test if enough room
123D: 0E                	DB	0EH		; No garbage collection done
123E: F1       [10]     GRBDON: POP	AF		; Garbage collection done
123F: F5       [21]     	PUSH	AF		; Save status
1240: 2A9F80   [37]     	LD	HL,(STRSPC)	; Bottom of string space in use
1243: EB       [41]     	EX	DE,HL		; To DE
1244: 2A0881   [57]     	LD	HL,(STRBOT)	; Bottom of string area
1247: 2F       [61]     	CPL			; Negate length (Top down)
1248: 4F       [65]     	LD	C,A		; -Length to BC
1249: 06FF     [72]     	LD	B,-1		; BC = -ve length of string
124B: 09       [83]     	ADD	HL,BC		; Add to bottom of space in use
124C: 23       [89]     	INC	HL		; Plus one for 2's complement
124D: CD4D07   [106]    	CALL	CPDEHL		; Below string RAM area?
1250: DA5A12   [116|116]	JP	C,TESTOS	; Tidy up if not done else err
1253: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of area
1256: 23       [138]    	INC	HL		; Point to first byte of string
1257: EB       [142]    	EX	DE,HL		; Address to DE
1258: F1       [10]     POPAF:	POP	AF		; Throw away status push
1259: C9       [20]     	RET
                        ;
125A: F1       [10]     TESTOS: POP	AF		; Garbage collect been done?
125B: 1E1A     [17]     	LD	E,OS		; ?OS Error
125D: CA9904   [27|27]  	JP	Z,ERROR		; Yes - Not enough string apace
1260: BF       [31]     	CP	A		; Flag garbage collect done
1261: F5       [42]     	PUSH	AF		; Save status
1262: 013E12   [52]     	LD	BC,GRBDON	; Garbage collection done
1265: C5       [63]     	PUSH	BC		; Save for RETurn
1266: 2AF480   [16]     GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
1269: 220881   [16]     GARBLP: LD	(STRBOT),HL	; Reset string pointer
126C: 210000   [26]     	LD	HL,0
126F: E5       [37]     	PUSH	HL		; Flag no string found
1270: 2A9F80   [53]     	LD	HL,(STRSPC)	; Get bottom of string space
1273: E5       [64]     	PUSH	HL		; Save bottom of string space
1274: 21F880   [74]     	LD	HL,TMSTPL	; Temporary string pool
1277: EB       [ 4]     GRBLP:	EX	DE,HL
1278: 2AF680   [20]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
127B: EB       [24]     	EX	DE,HL
127C: CD4D07   [41]     	CALL	CPDEHL		; Temporary string pool done?
127F: 017712   [51]     	LD	BC,GRBLP	; Loop until string pool done
1282: C2CB12   [61|61]  	JP	NZ,STPOOL	; No - See if in string area
1285: 2A1B81   [77]     	LD	HL,(PROGND)	; Start of simple variables
1288: EB       [ 4]     SMPVAR: EX	DE,HL
1289: 2A1D81   [20]     	LD	HL,(VAREND)	; End of simple variables
128C: EB       [24]     	EX	DE,HL
128D: CD4D07   [41]     	CALL	CPDEHL		; All simple strings done?
1290: CA9E12   [51|51]  	JP	Z,ARRLP		; Yes - Do string arrays
1293: 7E       [58]     	LD	A,(HL)		; Get type of variable
1294: 23       [64]     	INC	HL
1295: 23       [70]     	INC	HL
1296: B7       [74]     	OR	A		; "S" flag set if string
1297: CDCE12   [91]     	CALL	STRADD		; See if string in string area
129A: C38812   [101]    	JP	SMPVAR		; Loop until simple ones done
                        ;
129D: C1       [10]     GNXARY: POP	BC		; Scrap address of this array
129E: EB       [ 4]     ARRLP:	EX	DE,HL
129F: 2A1F81   [20]     	LD	HL,(ARREND)	; End of string arrays
12A2: EB       [24]     	EX	DE,HL
12A3: CD4D07   [41]     	CALL	CPDEHL		; All string arrays done?
12A6: CAF412   [51|51]  	JP	Z,SCNEND	; Yes - Move string if found
12A9: CD7B17   [68]     	CALL	LOADFP		; Get array name to BCDE
12AC: 7B       [72]     	LD	A,E		; Get type of array	
12AD: E5       [83]     	PUSH	HL		; Save address of num of dim'ns
12AE: 09       [94]     	ADD	HL,BC		; Start of next array
12AF: B7       [98]     	OR	A		; Test type of array
12B0: F29D12   [108|108]	JP	P,GNXARY	; Numeric array - Ignore it
12B3: 220A81   [124]    	LD	(CUROPR),HL	; Save address of next array
12B6: E1       [134]    	POP	HL		; Get address of num of dim'ns
12B7: 4E       [141]    	LD	C,(HL)		; BC = Number of dimensions
12B8: 0600     [148]    	LD	B,0
12BA: 09       [159]    	ADD	HL,BC		; Two bytes per dimension size
12BB: 09       [170]    	ADD	HL,BC
12BC: 23       [176]    	INC	HL		; Plus one for number of dim'ns
12BD: EB       [ 4]     GRBARY: EX	DE,HL
12BE: 2A0A81   [20]     	LD	HL,(CUROPR)	; Get address of next array
12C1: EB       [24]     	EX	DE,HL
12C2: CD4D07   [41]     	CALL	CPDEHL		; Is this array finished?
12C5: CA9E12   [51|51]  	JP	Z,ARRLP		; Yes - Get next one
12C8: 01BD12   [61]     	LD	BC,GRBARY	; Loop until array all done
12CB: C5       [11]     STPOOL: PUSH	BC		; Save return address
12CC: F680     [18]     	OR	80H		; Flag string type
12CE: 7E       [ 7]     STRADD: LD	A,(HL)		; Get string length
12CF: 23       [13]     	INC	HL
12D0: 23       [19]     	INC	HL
12D1: 5E       [26]     	LD	E,(HL)		; Get LSB of string address
12D2: 23       [32]     	INC	HL
12D3: 56       [39]     	LD	D,(HL)		; Get MSB of string address
12D4: 23       [45]     	INC	HL
12D5: F0       [50|56]  	RET	P		; Not a string - Return
12D6: B7       [54]     	OR	A		; Set flags on string length
12D7: C8       [59|65]  	RET	Z		; Null string - Return
12D8: 44       [63]     	LD	B,H		; Save variable pointer
12D9: 4D       [67]     	LD	C,L
12DA: 2A0881   [83]     	LD	HL,(STRBOT)	; Bottom of new area
12DD: CD4D07   [100]    	CALL	CPDEHL		; String been done?
12E0: 60       [104]    	LD	H,B		; Restore variable pointer
12E1: 69       [108]    	LD	L,C
12E2: D8       [113|119]	RET	C		; String done - Ignore
12E3: E1       [123]    	POP	HL		; Return address
12E4: E3       [142]    	EX	(SP),HL		; Lowest available string area
12E5: CD4D07   [159]    	CALL	CPDEHL		; String within string area?
12E8: E3       [178]    	EX	(SP),HL		; Lowest available string area
12E9: E5       [189]    	PUSH	HL		; Re-save return address
12EA: 60       [193]    	LD	H,B		; Restore variable pointer
12EB: 69       [197]    	LD	L,C
12EC: D0       [202|208]	RET	NC		; Outside string area - Ignore
12ED: C1       [212]    	POP	BC		; Get return , Throw 2 away
12EE: F1       [222]    	POP	AF		; 
12EF: F1       [232]    	POP	AF		; 
12F0: E5       [243]    	PUSH	HL		; Save variable pointer
12F1: D5       [254]    	PUSH	DE		; Save address of current
12F2: C5       [265]    	PUSH	BC		; Put back return address
12F3: C9       [275]    	RET			; Go to it
                        ;
12F4: D1       [10]     SCNEND: POP	DE		; Addresses of strings
12F5: E1       [20]     	POP	HL		; 
12F6: 7D       [24]     	LD	A,L		; HL = 0 if no more to do
12F7: B4       [28]     	OR	H
12F8: C8       [33|39]  	RET	Z		; No more to do - Return
12F9: 2B       [39]     	DEC	HL
12FA: 46       [46]     	LD	B,(HL)		; MSB of address of string
12FB: 2B       [52]     	DEC	HL
12FC: 4E       [59]     	LD	C,(HL)		; LSB of address of string
12FD: E5       [70]     	PUSH	HL		; Save variable address
12FE: 2B       [76]     	DEC	HL
12FF: 2B       [82]     	DEC	HL
1300: 6E       [89]     	LD	L,(HL)		; HL = Length of string
1301: 2600     [96]     	LD	H,0
1303: 09       [107]    	ADD	HL,BC		; Address of end of string+1
1304: 50       [111]    	LD	D,B		; String address to DE
1305: 59       [115]    	LD	E,C
1306: 2B       [121]    	DEC	HL		; Last byte in string
1307: 44       [125]    	LD	B,H		; Address to BC
1308: 4D       [129]    	LD	C,L
1309: 2A0881   [145]    	LD	HL,(STRBOT)	; Current bottom of string area
130C: CD5404   [162]    	CALL	MOVSTR		; Move string to new address
130F: E1       [172]    	POP	HL		; Restore variable address
1310: 71       [179]    	LD	(HL),C		; Save new LSB of address
1311: 23       [185]    	INC	HL
1312: 70       [192]    	LD	(HL),B		; Save new MSB of address
1313: 69       [196]    	LD	L,C		; Next string area+1 to HL
1314: 60       [200]    	LD	H,B
1315: 2B       [206]    	DEC	HL		; Next string area address
1316: C36912   [216]    	JP	GARBLP		; Look for more strings
                        ;
1319: C5       [11]     CONCAT: PUSH	BC		; Save prec' opr & code string
131A: E5       [22]     	PUSH	HL		; 
131B: 2A2981   [38]     	LD	HL,(FPREG)	; Get first string
131E: E3       [57]     	EX	(SP),HL		; Save first string
131F: CDD30D   [74]     	CALL	OPRND		; Get second string
1322: E3       [93]     	EX	(SP),HL		; Restore first string
1323: CD4E0D   [110]    	CALL	TSTSTR		; Make sure it's a string
1326: 7E       [117]    	LD	A,(HL)		; Get length of second string
1327: E5       [128]    	PUSH	HL		; Save first string
1328: 2A2981   [144]    	LD	HL,(FPREG)	; Get second string
132B: E5       [155]    	PUSH	HL		; Save second string
132C: 86       [162]    	ADD	A,(HL)		; Add length of second string
132D: 1E1C     [169]    	LD	E,LS		; ?LS Error
132F: DA9904   [179|179]	JP	C,ERROR		; String too long - Error
1332: CDD211   [196]    	CALL	MKTMST		; Make temporary string
1335: D1       [206]    	POP	DE		; Get second string to DE
1336: CD6A13   [223]    	CALL	GSTRDE		; Move to string pool if needed
1339: E3       [242]    	EX	(SP),HL		; Get first string
133A: CD6913   [259]    	CALL	GSTRHL		; Move to string pool if needed
133D: E5       [270]    	PUSH	HL		; Save first string
133E: 2A0681   [286]    	LD	HL,(TMPSTR+2)	; Temporary string address
1341: EB       [290]    	EX	DE,HL		; To DE
1342: CD5013   [307]    	CALL	SSTSA		; First string to string area
1345: CD5013   [324]    	CALL	SSTSA		; Second string to string area
1348: 21680D   [334]    	LD	HL,EVAL2	; Return to evaluation loop
134B: E3       [353]    	EX	(SP),HL		; Save return,get code string
134C: E5       [364]    	PUSH	HL		; Save code string address
134D: C30312   [374]    	JP	TSTOPL		; To temporary string to pool
                        ;
1350: E1       [10]     SSTSA:	POP	HL		; Return address
1351: E3       [29]     	EX	(SP),HL		; Get string block,save return
1352: 7E       [36]     	LD	A,(HL)		; Get length of string
1353: 23       [42]     	INC	HL
1354: 23       [48]     	INC	HL
1355: 4E       [55]     	LD	C,(HL)		; Get LSB of string address
1356: 23       [61]     	INC	HL
1357: 46       [68]     	LD	B,(HL)		; Get MSB of string address
1358: 6F       [72]     	LD	L,A		; Length to L
1359: 2C       [ 4]     TOSTRA: INC	L		; INC - DECed after
135A: 2D       [ 4]     TSALP:	DEC	L		; Count bytes moved
135B: C8       [ 9|15]  	RET	Z		; End of string - Return
135C: 0A       [16]     	LD	A,(BC)		; Get source
135D: 12       [23]     	LD	(DE),A		; Save destination
135E: 03       [29]     	INC	BC		; Next source
135F: 13       [35]     	INC	DE		; Next destination
1360: C35A13   [45]     	JP	TSALP		; Loop until string moved
                        ;
1363: CD4E0D   [17]     GETSTR: CALL	TSTSTR		; Make sure it's a string
1366: 2A2981   [16]     GSTRCU: LD	HL,(FPREG)	; Get current string
1369: EB       [ 4]     GSTRHL: EX	DE,HL		; Save DE
136A: CD8413   [17]     GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
136D: EB       [21]     	EX	DE,HL		; Restore DE
136E: C0       [26|32]  	RET	NZ		; No - Return
136F: D5       [37]     	PUSH	DE		; Save string
1370: 50       [41]     	LD	D,B		; String block address to DE
1371: 59       [45]     	LD	E,C
1372: 1B       [51]     	DEC	DE		; Point to length
1373: 4E       [58]     	LD	C,(HL)		; Get string length
1374: 2A0881   [74]     	LD	HL,(STRBOT)	; Current bottom of string area
1377: CD4D07   [91]     	CALL	CPDEHL		; Last one in string area?
137A: C28213   [101|101]	JP	NZ,POPHL	; No - Return
137D: 47       [105]    	LD	B,A		; Clear B (A=0)
137E: 09       [116]    	ADD	HL,BC		; Remove string from str' area
137F: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of str' area
1382: E1       [10]     POPHL:	POP	HL		; Restore string
1383: C9       [20]     	RET
                        ;
1384: 2AF680   [16]     BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
1387: 2B       [22]     	DEC	HL		; Back
1388: 46       [29]     	LD	B,(HL)		; Get MSB of address
1389: 2B       [35]     	DEC	HL		; Back
138A: 4E       [42]     	LD	C,(HL)		; Get LSB of address
138B: 2B       [48]     	DEC	HL		; Back
138C: 2B       [54]     	DEC	HL		; Back
138D: CD4D07   [71]     	CALL	CPDEHL		; String last in string pool?
1390: C0       [76|82]  	RET	NZ		; Yes - Leave it
1391: 22F680   [92]     	LD	(TMSTPT),HL	; Save new string pool top
1394: C9       [102]    	RET
                        ;
1395: 011411   [10]     LEN:	LD	BC,PASSA	; To return integer A
1398: C5       [21]     	PUSH	BC		; Save address
1399: CD6313   [17]     GETLEN: CALL	GETSTR		; Get string and its length
139C: AF       [21]     	XOR	A
139D: 57       [25]     	LD	D,A		; Clear D
139E: 32F280   [38]     	LD	(TYPE),A	; Set type to numeric
13A1: 7E       [45]     	LD	A,(HL)		; Get length of string
13A2: B7       [49]     	OR	A		; Set status flags
13A3: C9       [59]     	RET
                        ;
13A4: 011411   [10]     ASC:	LD	BC,PASSA	; To return integer A
13A7: C5       [21]     	PUSH	BC		; Save address
13A8: CD9913   [17]     GTFLNM: CALL	GETLEN		; Get length of string
13AB: CAA409   [27|27]  	JP	Z,FCERR		; Null string - Error
13AE: 23       [33]     	INC	HL
13AF: 23       [39]     	INC	HL
13B0: 5E       [46]     	LD	E,(HL)		; Get LSB of address
13B1: 23       [52]     	INC	HL
13B2: 56       [59]     	LD	D,(HL)		; Get MSB of address
13B3: 1A       [66]     	LD	A,(DE)		; Get first byte of string
13B4: C9       [76]     	RET
                        ;
13B5: 3E01     [ 7]     CHR:	LD	A,1		; One character string
13B7: CDD211   [24]     	CALL	MKTMST		; Make a temporary string
13BA: CDAE14   [41]     	CALL	MAKINT		; Make it integer A
13BD: 2A0681   [57]     	LD	HL,(TMPSTR+2)	; Get address of string
13C0: 73       [64]     	LD	(HL),E		; Save character
13C1: C1       [10]     TOPOOL: POP	BC		; Clean up stack
13C2: C30312   [20]     	JP	TSTOPL		; Temporary string to pool
                        ;
13C5: CD5E14   [17]     LEFT:	CALL	LFRGNM		; Get number and ending ")"
13C8: AF       [21]     	XOR	A		; Start at first byte in string
13C9: E3       [19]     RIGHT1: EX	(SP),HL		; Save code string,Get string
13CA: 4F       [23]     	LD	C,A		; Starting position in string
13CB: E5       [11]     MID1:	PUSH	HL		; Save string block address
13CC: 7E       [18]     	LD	A,(HL)		; Get length of string
13CD: B8       [22]     	CP	B		; Compare with number given
13CE: DAD313   [32|32]  	JP	C,ALLFOL	; All following bytes required
13D1: 78       [36]     	LD	A,B		; Get new length
13D2: 11                	DB	11H		; Skip "LD C,0"
13D3: 0E00     [ 7]     ALLFOL: LD	C,0		; First byte of string
13D5: C5       [18]     	PUSH	BC		; Save position in string
13D6: CD3C12   [35]     	CALL	TESTR		; See if enough string space
13D9: C1       [45]     	POP	BC		; Get position in string
13DA: E1       [55]     	POP	HL		; Restore string block address
13DB: E5       [66]     	PUSH	HL		; And re-save it
13DC: 23       [72]     	INC	HL
13DD: 23       [78]     	INC	HL
13DE: 46       [85]     	LD	B,(HL)		; Get LSB of address
13DF: 23       [91]     	INC	HL
13E0: 66       [98]     	LD	H,(HL)		; Get MSB of address
13E1: 68       [102]    	LD	L,B		; HL = address of string
13E2: 0600     [109]    	LD	B,0		; BC = starting address
13E4: 09       [120]    	ADD	HL,BC		; Point to that byte
13E5: 44       [124]    	LD	B,H		; BC = source string
13E6: 4D       [128]    	LD	C,L
13E7: CDD511   [145]    	CALL	CRTMST		; Create a string entry
13EA: 6F       [149]    	LD	L,A		; Length of new string
13EB: CD5913   [166]    	CALL	TOSTRA		; Move string to string area
13EE: D1       [176]    	POP	DE		; Clear stack
13EF: CD6A13   [193]    	CALL	GSTRDE		; Move to string pool if needed
13F2: C30312   [203]    	JP	TSTOPL		; Temporary string to pool
                        ;
13F5: CD5E14   [17]     RIGHT:	CALL	LFRGNM		; Get number and ending ")"
13F8: D1       [27]     	POP	DE		; Get string length
13F9: D5       [38]     	PUSH	DE		; And re-save
13FA: 1A       [45]     	LD	A,(DE)		; Get length
13FB: 90       [49]     	SUB	B		; Move back N bytes
13FC: C3C913   [59]     	JP	RIGHT1		; Go and get sub-string
                        ;
13FF: EB       [ 4]     MID:	EX	DE,HL		; Get code string address
1400: 7E       [11]     	LD	A,(HL)		; Get next byte ',' or ")"
1401: CD6314   [28]     	CALL	MIDNUM		; Get number supplied
1404: 04       [32]     	INC	B		; Is it character zero?
1405: 05       [36]     	DEC	B
1406: CAA409   [46|46]  	JP	Z,FCERR		; Yes - Error
1409: C5       [57]     	PUSH	BC		; Save starting position
140A: 1EFF     [64]     	LD	E,255		; All of string
140C: FE29     [71]     	CP	')'		; Any length given?
140E: CA1814   [81|81]  	JP	Z,RSTSTR	; No - Rest of string
1411: CD5307   [98]     	CALL	CHKSYN		; Make sure ',' follows
1414: 2C                	DB	','
1415: CDAB14   [115]    	CALL	GETINT		; Get integer 0-255
1418: CD5307   [17]     RSTSTR: CALL	CHKSYN		; Make sure ")" follows
141B: 29                	DB	")"
141C: F1       [27]     	POP	AF		; Restore starting position
141D: E3       [46]     	EX	(SP),HL		; Get string,8ave code string
141E: 01CB13   [56]     	LD	BC,MID1		; Continuation of MID$ routine
1421: C5       [67]     	PUSH	BC		; Save for return
1422: 3D       [71]     	DEC	A		; Starting position-1
1423: BE       [78]     	CP	(HL)		; Compare with length
1424: 0600     [85]     	LD	B,0		; Zero bytes length
1426: D0       [90|96]  	RET	NC		; Null string if start past end
1427: 4F       [94]     	LD	C,A		; Save starting position-1
1428: 7E       [101]    	LD	A,(HL)		; Get length of string
1429: 91       [105]    	SUB	C		; Subtract start
142A: BB       [109]    	CP	E		; Enough string for it?
142B: 47       [113]    	LD	B,A		; Save maximum length available
142C: D8       [118|124]	RET	C		; Truncate string if needed
142D: 43       [122]    	LD	B,E		; Set specified length
142E: C9       [132]    	RET			; Go and create string
                        ;
142F: CD9913   [17]     VAL:	CALL	GETLEN		; Get length of string
1432: CA4C15   [27|27]  	JP	Z,RESZER	; Result zero
1435: 5F       [31]     	LD	E,A		; Save length
1436: 23       [37]     	INC	HL
1437: 23       [43]     	INC	HL
1438: 7E       [50]     	LD	A,(HL)		; Get LSB of address
1439: 23       [56]     	INC	HL
143A: 66       [63]     	LD	H,(HL)		; Get MSB of address
143B: 6F       [67]     	LD	L,A		; HL = String address
143C: E5       [78]     	PUSH	HL		; Save string address
143D: 19       [89]     	ADD	HL,DE
143E: 46       [96]     	LD	B,(HL)		; Get end of string+1 byte
143F: 72       [103]    	LD	(HL),D		; Zero it to terminate
1440: E3       [122]    	EX	(SP),HL		; Save string end,get start
1441: C5       [133]    	PUSH	BC		; Save end+1 byte
1442: 7E       [140]    	LD	A,(HL)		; Get starting byte
1443: FE24     [147]    	CP	'$'		; Hex number indicated? [function added]
1445: C24D14   [157|157]	JP	NZ,VAL1
1448: CD771C   [174]    	CALL	HEXTFP		; Convert Hex to FPREG
144B: 180D     [186]    	JR	VAL3
144D: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
144F: C25714   [17|17]  	JP	NZ,VAL2
1452: CDE71C   [34]     	CALL	BINTFP		; Convert Bin to FPREG
1455: 1803     [46]     	JR	VAL3
1457: CD3318   [17]     VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
145A: C1       [10]     VAL3:	POP	BC		; Restore end+1 byte
145B: E1       [20]     	POP	HL		; Restore end+1 address
145C: 70       [27]     	LD	(HL),B		; Put back original byte
145D: C9       [37]     	RET
                        ;
145E: EB       [ 4]     LFRGNM: EX	DE,HL		; Code string address to HL
145F: CD5307   [21]     	CALL	CHKSYN		; Make sure ")" follows
1462: 29                	DB	")"
1463: C1       [10]     MIDNUM: POP	BC		; Get return address
1464: D1       [20]     	POP	DE		; Get number supplied
1465: C5       [31]     	PUSH	BC		; Re-save return address
1466: 43       [35]     	LD	B,E		; Number to B
1467: C9       [45]     	RET
                        ;
1468: CDAE14   [17]     INP:	CALL	MAKINT		; Make it integer A
146B: 328480   [30]     	LD	(INPORT),A	; Set input port
146E: CD8380   [47]     	CALL	INPSUB		; Get input from port
1471: C31411   [57]     	JP	PASSA		; Return integer A
                        ;
1474: CD9814   [17]     POUT:	CALL	SETIO		; Set up port number
1477: C34B80   [27]     	JP	OUTSUB		; Output data and return
                        ;
147A: CD9814   [17]     WAIT:	CALL	SETIO		; Set up port number
147D: F5       [28]     	PUSH	AF		; Save AND mask
147E: 1E00     [35]     	LD	E,0		; Assume zero if none given
1480: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
1481: CDDD08   [58]     	CALL	GETCHR		; Get next character
1484: CA8E14   [68|68]  	JP	Z,NOXOR		; No XOR byte given
1487: CD5307   [85]     	CALL	CHKSYN		; Make sure ',' follows
148A: 2C                	DB	','
148B: CDAB14   [102]    	CALL	GETINT		; Get integer 0-255 to XOR with
148E: C1       [10]     NOXOR:	POP	BC		; Restore AND mask
148F: CD8380   [17]     WAITLP: CALL	INPSUB		; Get input
1492: AB       [21]     	XOR	E		; Flip selected bits
1493: A0       [25]     	AND	B		; Result non-zero?
1494: CA8F14   [35|35]  	JP	Z,WAITLP	; No = keep waiting
1497: C9       [45]     	RET
                        ;
1498: CDAB14   [17]     SETIO:	CALL	GETINT		; Get integer 0-255
149B: 328480   [30]     	LD	(INPORT),A	; Set input port
149E: 324C80   [43]     	LD	(OTPORT),A	; Set output port
14A1: CD5307   [60]     	CALL	CHKSYN		; Make sure ',' follows
14A4: 2C                	DB	','
14A5: C3AB14   [70]     	JP	GETINT		; Get integer 0-255 and return
                        ;
14A8: CDDD08   [17]     FNDNUM: CALL	GETCHR		; Get next character
14AB: CD4A0D   [17]     GETINT: CALL	GETNUM		; Get a number from 0 to 255
14AE: CD8909   [17]     MAKINT: CALL	DEPINT		; Make sure value 0 - 255
14B1: 7A       [21]     	LD	A,D		; Get MSB of number
14B2: B7       [25]     	OR	A		; Zero?
14B3: C2A409   [35|35]  	JP	NZ,FCERR	; No - Error
14B6: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
14B7: CDDD08   [58]     	CALL	GETCHR		; Get next character
14BA: 7B       [62]     	LD	A,E		; Get number to A
14BB: C9       [72]     	RET
                        ;
14BC: CD8F09   [17]     PEEK:	CALL	DEINT		; Get memory address
14BF: 1A       [24]     	LD	A,(DE)		; Get byte in memory
14C0: C31411   [34]     	JP	PASSA		; Return integer A
                        ;
14C3: CD4A0D   [17]     POKE:	CALL	GETNUM		; Get memory address
14C6: CD8F09   [34]     	CALL	DEINT		; Get integer -32768 to 3276
14C9: D5       [45]     	PUSH	DE		; Save memory address
14CA: CD5307   [62]     	CALL	CHKSYN		; Make sure ',' follows
14CD: 2C                	DB	','
14CE: CDAB14   [79]     	CALL	GETINT		; Get integer 0-255
14D1: D1       [89]     	POP	DE		; Restore memory address
14D2: 12       [96]     	LD	(DE),A		; Load it into memory
14D3: C9       [106]    	RET
                        ;
14D4: 21AA19   [10]     ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
14D7: CD7B17   [17]     ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
14DA: C3E614   [27]     	JP	FPADD		; Add BCDE to FPREG
                        ;
14DD: CD7B17   [17]     SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
14E0: 21                	DB	21H		; Skip "POP BC" and "POP DE"
14E1: C1       [10]     PSUB:	POP	BC		; Get FP number from stack
14E2: D1       [20]     	POP	DE
14E3: CD5517   [17]     SUBCDE: CALL	INVSGN		; Negate FPREG
14E6: 78       [ 4]     FPADD:	LD	A,B		; Get FP exponent
14E7: B7       [ 8]     	OR	A		; Is number zero?
14E8: C8       [13|19]  	RET	Z		; Yes - Nothing to add
14E9: 3A2C81   [26]     	LD	A,(FPEXP)	; Get FPREG exponent
14EC: B7       [30]     	OR	A		; Is this number zero?
14ED: CA6D17   [40|40]  	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
14F0: 90       [44]     	SUB	B		; BCDE number larger?
14F1: D20015   [54|54]  	JP	NC,NOSWAP	; No - Don't swap them
14F4: 2F       [58]     	CPL			; Two's complement
14F5: 3C       [62]     	INC	A		;	FP exponent
14F6: EB       [66]     	EX	DE,HL
14F7: CD5D17   [83]     	CALL	STAKFP		; Put FPREG on stack
14FA: EB       [87]     	EX	DE,HL
14FB: CD6D17   [104]    	CALL	FPBCDE		; Move BCDE to FPREG
14FE: C1       [114]    	POP	BC		; Restore number from stack
14FF: D1       [124]    	POP	DE
1500: FE19     [ 7]     NOSWAP: CP	24+1		; Second number insignificant?
1502: D0       [12|18]  	RET	NC		; Yes - First number is result
1503: F5       [23]     	PUSH	AF		; Save number of bits to scale
1504: CD9217   [40]     	CALL	SIGNS		; Set MSBs & sign of result
1507: 67       [44]     	LD	H,A		; Save sign of result
1508: F1       [54]     	POP	AF		; Restore scaling factor
1509: CDAB15   [71]     	CALL	SCALE		; Scale BCDE to same exponent
150C: B4       [75]     	OR	H		; Result to be positive?
150D: 212981   [85]     	LD	HL,FPREG	; Point to FPREG
1510: F22615   [95|95]  	JP	P,MINCDE	; No - Subtract FPREG from CDE
1513: CD8B15   [112]    	CALL	PLUCDE		; Add FPREG to CDE
1516: D26C15   [122|122]	JP	NC,RONDUP	; No overflow - Round it up
1519: 23       [128]    	INC	HL		; Point to exponent
151A: 34       [139]    	INC	(HL)		; Increment it
151B: CA9404   [149|149]	JP	Z,OVERR		; Number overflowed - Error
151E: 2E01     [156]    	LD	L,1		; 1 bit to shift right
1520: CDC115   [173]    	CALL	SHRT1		; Shift result right
1523: C36C15   [183]    	JP	RONDUP		; Round it up
                        ;
1526: AF       [ 4]     MINCDE: XOR	A		; Clear A and carry
1527: 90       [ 8]     	SUB	B		; Negate exponent
1528: 47       [12]     	LD	B,A		; Re-save exponent
1529: 7E       [19]     	LD	A,(HL)		; Get LSB of FPREG
152A: 9B       [23]     	SBC	A, E		; Subtract LSB of BCDE
152B: 5F       [27]     	LD	E,A		; Save LSB of BCDE
152C: 23       [33]     	INC	HL
152D: 7E       [40]     	LD	A,(HL)		; Get NMSB of FPREG
152E: 9A       [44]     	SBC	A,D		; Subtract NMSB of BCDE
152F: 57       [48]     	LD	D,A		; Save NMSB of BCDE
1530: 23       [54]     	INC	HL
1531: 7E       [61]     	LD	A,(HL)		; Get MSB of FPREG
1532: 99       [65]     	SBC	A,C		; Subtract MSB of BCDE
1533: 4F       [69]     	LD	C,A		; Save MSB of BCDE
1534: DC9715   [10|17]  CONPOS: CALL	C,COMPL		; Overflow - Make it positive
                        ;
1537: 68       [ 4]     BNORM:	LD	L,B		; L = Exponent
1538: 63       [ 8]     	LD	H,E		; H = LSB
1539: AF       [12]     	XOR	A
153A: 47       [ 4]     BNRMLP: LD	B,A		; Save bit count
153B: 79       [ 8]     	LD	A,C		; Get MSB
153C: B7       [12]     	OR	A		; Is it zero?
153D: C25915   [22|22]  	JP	NZ,PNORM	; No - Do it bit at a time
1540: 4A       [26]     	LD	C,D		; MSB = NMSB
1541: 54       [30]     	LD	D,H		; NMSB= LSB
1542: 65       [34]     	LD	H,L		; LSB = VLSB
1543: 6F       [38]     	LD	L,A		; VLSB= 0
1544: 78       [42]     	LD	A,B		; Get exponent
1545: D608     [49]     	SUB	8		; Count 8 bits
1547: FEE0     [56]     	CP	0E0H		; -24-8 Was number zero?
1549: C23A15   [66|66]  	JP	NZ,BNRMLP	; No - Keep normalising
154C: AF       [ 4]     RESZER: XOR	A		; Result is zero
154D: 322C81   [13]     SAVEXP: LD	(FPEXP),A	; Save result as zero
1550: C9       [23]     	RET
                        ;
1551: 05       [ 4]     NORMAL: DEC	B		; Count bits
1552: 29       [15]     	ADD	HL,HL		; Shift HL left
1553: 7A       [19]     	LD	A,D		; Get NMSB
1554: 17       [23]     	RLA			; Shift left with last bit
1555: 57       [27]     	LD	D,A		; Save NMSB
1556: 79       [31]     	LD	A,C		; Get MSB
1557: 8F       [35]     	ADC	A,A		; Shift left with last bit
1558: 4F       [39]     	LD	C,A		; Save MSB
1559: F25115   [10|10]  PNORM:	JP	P,NORMAL	; Not done - Keep going
155C: 78       [14]     	LD	A,B		; Number of bits shifted
155D: 5C       [18]     	LD	E,H		; Save HL in EB
155E: 45       [22]     	LD	B,L
155F: B7       [26]     	OR	A		; Any shifting done?
1560: CA6C15   [36|36]  	JP	Z,RONDUP	; No - Round it up
1563: 212C81   [46]     	LD	HL,FPEXP	; Point to exponent
1566: 86       [53]     	ADD	A,(HL)		; Add shifted bits
1567: 77       [60]     	LD	(HL),A		; Re-save exponent
1568: D24C15   [70|70]  	JP	NC,RESZER	; Underflow - Result is zero
156B: C8       [75|81]  	RET	Z		; Result is zero
156C: 78       [ 4]     RONDUP: LD	A,B		; Get VLSB of number
156D: 212C81   [10]     RONDB:	LD	HL,FPEXP	; Point to exponent
1570: B7       [14]     	OR	A		; Any rounding?
1571: FC7E15   [24|31]  	CALL	M,FPROND	; Yes - Round number up
1574: 46       [31]     	LD	B,(HL)		; B = Exponent
1575: 23       [37]     	INC	HL
1576: 7E       [44]     	LD	A,(HL)		; Get sign of result
1577: E680     [51]     	AND	10000000B	; Only bit 7 needed
1579: A9       [55]     	XOR	C		; Set correct sign
157A: 4F       [59]     	LD	C,A		; Save correct sign in number
157B: C36D17   [69]     	JP	FPBCDE		; Move BCDE to FPREG
                        ;
157E: 1C       [ 4]     FPROND: INC	E		; Round LSB
157F: C0       [ 9|15]  	RET	NZ		; Return if ok
1580: 14       [13]     	INC	D		; Round NMSB
1581: C0       [18|24]  	RET	NZ		; Return if ok
1582: 0C       [22]     	INC	C		; Round MSB
1583: C0       [27|33]  	RET	NZ		; Return if ok
1584: 0E80     [34]     	LD	C,80H		; Set normal value
1586: 34       [45]     	INC	(HL)		; Increment exponent
1587: C0       [50|56]  	RET	NZ		; Return if ok
1588: C39404   [60]     	JP	OVERR		; Overflow error
                        ;
158B: 7E       [ 7]     PLUCDE: LD	A,(HL)		; Get LSB of FPREG
158C: 83       [11]     	ADD	A,E		; Add LSB of BCDE
158D: 5F       [15]     	LD	E,A		; Save LSB of BCDE
158E: 23       [21]     	INC	HL
158F: 7E       [28]     	LD	A,(HL)		; Get NMSB of FPREG
1590: 8A       [32]     	ADC	A,D		; Add NMSB of BCDE
1591: 57       [36]     	LD	D,A		; Save NMSB of BCDE
1592: 23       [42]     	INC	HL
1593: 7E       [49]     	LD	A,(HL)		; Get MSB of FPREG
1594: 89       [53]     	ADC	A,C		; Add MSB of BCDE
1595: 4F       [57]     	LD	C,A		; Save MSB of BCDE
1596: C9       [67]     	RET
                        ;
1597: 212D81   [10]     COMPL:	LD	HL,SGNRES	; Sign of result
159A: 7E       [17]     	LD	A,(HL)		; Get sign of result
159B: 2F       [21]     	CPL			; Negate it
159C: 77       [28]     	LD	(HL),A		; Put it back
159D: AF       [32]     	XOR	A
159E: 6F       [36]     	LD	L,A		; Set L to zero
159F: 90       [40]     	SUB	B		; Negate exponent,set carry
15A0: 47       [44]     	LD	B,A		; Re-save exponent
15A1: 7D       [48]     	LD	A,L		; Load zero
15A2: 9B       [52]     	SBC	A,E		; Negate LSB
15A3: 5F       [56]     	LD	E,A		; Re-save LSB
15A4: 7D       [60]     	LD	A,L		; Load zero
15A5: 9A       [64]     	SBC	A,D		; Negate NMSB
15A6: 57       [68]     	LD	D,A		; Re-save NMSB
15A7: 7D       [72]     	LD	A,L		; Load zero
15A8: 99       [76]     	SBC	A,C		; Negate MSB
15A9: 4F       [80]     	LD	C,A		; Re-save MSB
15AA: C9       [90]     	RET
                        ;
15AB: 0600     [ 7]     SCALE:	LD	B,0		; Clear underflow
15AD: D608     [ 7]     SCALLP: SUB	8		; 8 bits (a whole byte)?
15AF: DABA15   [17|17]  	JP	C,SHRITE	; No - Shift right A bits
15B2: 43       [21]     	LD	B,E		; <- Shift
15B3: 5A       [25]     	LD	E,D		; <- right
15B4: 51       [29]     	LD	D,C		; <- eight
15B5: 0E00     [36]     	LD	C,0		; <- bits
15B7: C3AD15   [46]     	JP	SCALLP		; More bits to shift
                        ;
15BA: C609     [ 7]     SHRITE: ADD	A,8+1		; Adjust count
15BC: 6F       [11]     	LD	L,A		; Save bits to shift
15BD: AF       [ 4]     SHRLP:	XOR	A		; Flag for all done
15BE: 2D       [ 8]     	DEC	L		; All shifting done?
15BF: C8       [13|19]  	RET	Z		; Yes - Return
15C0: 79       [17]     	LD	A,C		; Get MSB
15C1: 1F       [ 4]     SHRT1:	RRA			; Shift it right
15C2: 4F       [ 8]     	LD	C,A		; Re-save
15C3: 7A       [12]     	LD	A,D		; Get NMSB
15C4: 1F       [16]     	RRA			; Shift right with last bit
15C5: 57       [20]     	LD	D,A		; Re-save it
15C6: 7B       [24]     	LD	A,E		; Get LSB
15C7: 1F       [28]     	RRA			; Shift right with last bit
15C8: 5F       [32]     	LD	E,A		; Re-save it
15C9: 78       [36]     	LD	A,B		; Get underflow
15CA: 1F       [40]     	RRA			; Shift right with last bit
15CB: 47       [44]     	LD	B,A		; Re-save underflow
15CC: C3BD15   [54]     	JP	SHRLP		; More bits to do
                        ;
15CF: 00000081          UNITY:	DB	 000H,000H,000H,081H	; 1.00000
                        ;
15D3: 03                LOGTAB: DB	3			; Table used by LOG
15D4: AA561980          	DB	0AAH,056H,019H,080H	; 0.59898
15D8: F1227680          	DB	0F1H,022H,076H,080H	; 0.96147
15DC: 45AA3882          	DB	045H,0AAH,038H,082H	; 2.88539
                        ;
15E0: CD2C17   [17]     LOG:	CALL	TSTSGN		; Test sign of value
15E3: B7       [21]     	OR	A
15E4: EAA409   [31|31]  	JP	PE,FCERR	; ?FC Error if <= zero
15E7: 212C81   [41]     	LD	HL,FPEXP	; Point to exponent
15EA: 7E       [48]     	LD	A,(HL)		; Get exponent
15EB: 013580   [58]     	LD	BC,8035H	; BCDE = SQR(1/2)
15EE: 11F304   [68]     	LD	DE,04F3H
15F1: 90       [72]     	SUB	B		; Scale value to be < 1
15F2: F5       [83]     	PUSH	AF		; Save scale factor
15F3: 70       [90]     	LD	(HL),B		; Save new exponent
15F4: D5       [101]    	PUSH	DE		; Save SQR(1/2)
15F5: C5       [112]    	PUSH	BC
15F6: CDE614   [129]    	CALL	FPADD		; Add SQR(1/2) to value
15F9: C1       [139]    	POP	BC		; Restore SQR(1/2)
15FA: D1       [149]    	POP	DE
15FB: 04       [153]    	INC	B		; Make it SQR(2)
15FC: CD8216   [170]    	CALL	DVBCDE		; Divide by SQR(2)
15FF: 21CF15   [180]    	LD	HL,UNITY	; Point to 1.
1602: CDDD14   [197]    	CALL	SUBPHL		; Subtract FPREG from 1
1605: 21D315   [207]    	LD	HL,LOGTAB	; Coefficient table
1608: CD741A   [224]    	CALL	SUMSER		; Evaluate sum of series
160B: 018080   [234]    	LD	BC,8080H	; BCDE = -0.5
160E: 110000   [244]    	LD	DE,0000H
1611: CDE614   [261]    	CALL	FPADD		; Subtract 0.5 from FPREG
1614: F1       [271]    	POP	AF		; Restore scale factor
1615: CDA718   [288]    	CALL	RSCALE		; Re-scale number
1618: 013180   [10]     MULLN2: LD	BC,8031H	; BCDE = Ln(2)
161B: 111872   [20]     	LD	DE,7218H
161E: 21                	DB	21H		; Skip "POP BC" and "POP DE"
                        ;
161F: C1       [10]     MULT:	POP	BC		; Get number from stack
1620: D1       [20]     	POP	DE
1621: CD2C17   [17]     FPMULT: CALL	TSTSGN		; Test sign of FPREG
1624: C8       [22|28]  	RET	Z		; Return zero if zero
1625: 2E00     [29]     	LD	L,0		; Flag add exponents
1627: CDEA16   [46]     	CALL	ADDEXP		; Add exponents
162A: 79       [50]     	LD	A,C		; Get MSB of multiplier
162B: 323B81   [63]     	LD	(MULVAL),A	; Save MSB of multiplier
162E: EB       [67]     	EX	DE,HL
162F: 223C81   [83]     	LD	(MULVAL+1),HL	; Save rest of multiplier
1632: 010000   [93]     	LD	BC,0		; Partial product (BCDE) = zero
1635: 50       [97]     	LD	D,B
1636: 58       [101]    	LD	E,B
1637: 213715   [111]    	LD	HL,BNORM	; Address of normalise
163A: E5       [122]    	PUSH	HL		; Save for return
163B: 214316   [132]    	LD	HL,MULT8	; Address of 8 bit multiply
163E: E5       [143]    	PUSH	HL		; Save for NMSB,MSB
163F: E5       [154]    	PUSH	HL		; 
1640: 212981   [164]    	LD	HL,FPREG	; Point to number
1643: 7E       [ 7]     MULT8:	LD	A,(HL)		; Get LSB of number
1644: 23       [13]     	INC	HL		; Point to NMSB
1645: B7       [17]     	OR	A		; Test LSB
1646: CA6F16   [27|27]  	JP	Z,BYTSFT	; Zero - shift to next byte
1649: E5       [38]     	PUSH	HL		; Save address of number
164A: 2E08     [45]     	LD	L,8		; 8 bits to multiply by
164C: 1F       [ 4]     MUL8LP: RRA			; Shift LSB right
164D: 67       [ 8]     	LD	H,A		; Save LSB
164E: 79       [12]     	LD	A,C		; Get MSB
164F: D25D16   [22|22]  	JP	NC,NOMADD	; Bit was zero - Don't add
1652: E5       [33]     	PUSH	HL		; Save LSB and count
1653: 2A3C81   [49]     	LD	HL,(MULVAL+1)	; Get LSB and NMSB
1656: 19       [60]     	ADD	HL,DE		; Add NMSB and LSB
1657: EB       [64]     	EX	DE,HL		; Leave sum in DE
1658: E1       [74]     	POP	HL		; Restore MSB and count
1659: 3A3B81   [87]     	LD	A,(MULVAL)	; Get MSB of multiplier
165C: 89       [91]     	ADC	A,C		; Add MSB
165D: 1F       [ 4]     NOMADD: RRA			; Shift MSB right
165E: 4F       [ 8]     	LD	C,A		; Re-save MSB
165F: 7A       [12]     	LD	A,D		; Get NMSB
1660: 1F       [16]     	RRA			; Shift NMSB right
1661: 57       [20]     	LD	D,A		; Re-save NMSB
1662: 7B       [24]     	LD	A,E		; Get LSB
1663: 1F       [28]     	RRA			; Shift LSB right
1664: 5F       [32]     	LD	E,A		; Re-save LSB
1665: 78       [36]     	LD	A,B		; Get VLSB
1666: 1F       [40]     	RRA			; Shift VLSB right
1667: 47       [44]     	LD	B,A		; Re-save VLSB
1668: 2D       [48]     	DEC	L		; Count bits multiplied
1669: 7C       [52]     	LD	A,H		; Get LSB of multiplier
166A: C24C16   [62|62]  	JP	NZ,MUL8LP	; More - Do it
166D: E1       [10]     POPHRT: POP	HL		; Restore address of number
166E: C9       [20]     	RET
                        ;
166F: 43       [ 4]     BYTSFT: LD	B,E		; Shift partial product left
1670: 5A       [ 8]     	LD	E,D
1671: 51       [12]     	LD	D,C
1672: 4F       [16]     	LD	C,A
1673: C9       [26]     	RET
                        ;
1674: CD5D17   [17]     DIV10:	CALL	STAKFP		; Save FPREG on stack
1677: 012084   [27]     	LD	BC,8420H	; BCDE = 10.
167A: 110000   [37]     	LD	DE,0000H
167D: CD6D17   [54]     	CALL	FPBCDE		; Move 10 to FPREG
                        ;
1680: C1       [10]     DIV:	POP	BC		; Get number from stack
1681: D1       [20]     	POP	DE
1682: CD2C17   [17]     DVBCDE: CALL	TSTSGN		; Test sign of FPREG
1685: CA8804   [27|27]  	JP	Z,DZERR		; Error if division by zero
1688: 2EFF     [34]     	LD	L,-1		; Flag subtract exponents
168A: CDEA16   [51]     	CALL	ADDEXP		; Subtract exponents
168D: 34       [62]     	INC	(HL)		; Add 2 to exponent to adjust
168E: 34       [73]     	INC	(HL)
168F: 2B       [79]     	DEC	HL		; Point to MSB
1690: 7E       [86]     	LD	A,(HL)		; Get MSB of dividend
1691: 325780   [99]     	LD	(DIV3),A	; Save for subtraction
1694: 2B       [105]    	DEC	HL
1695: 7E       [112]    	LD	A,(HL)		; Get NMSB of dividend
1696: 325380   [125]    	LD	(DIV2),A	; Save for subtraction
1699: 2B       [131]    	DEC	HL
169A: 7E       [138]    	LD	A,(HL)		; Get MSB of dividend
169B: 324F80   [151]    	LD	(DIV1),A	; Save for subtraction
169E: 41       [155]    	LD	B,C		; Get MSB
169F: EB       [159]    	EX	DE,HL		; NMSB,LSB to HL
16A0: AF       [163]    	XOR	A
16A1: 4F       [167]    	LD	C,A		; Clear MSB of quotient
16A2: 57       [171]    	LD	D,A		; Clear NMSB of quotient
16A3: 5F       [175]    	LD	E,A		; Clear LSB of quotient
16A4: 325A80   [188]    	LD	(DIV4),A	; Clear overflow count
16A7: E5       [11]     DIVLP:	PUSH	HL		; Save divisor
16A8: C5       [22]     	PUSH	BC
16A9: 7D       [26]     	LD	A,L		; Get LSB of number
16AA: CD4E80   [43]     	CALL	DIVSUP		; Subt' divisor from dividend
16AD: DE00     [50]     	SBC	A,0		; Count for overflows
16AF: 3F       [54]     	CCF
16B0: D2BA16   [64|64]  	JP	NC,RESDIV	; Restore divisor if borrow
16B3: 325A80   [77]     	LD	(DIV4),A	; Re-save overflow count
16B6: F1       [87]     	POP	AF		; Scrap divisor
16B7: F1       [97]     	POP	AF
16B8: 37       [101]    	SCF			; Set carry to
16B9: D2                	DB	0D2H		; Skip "POP BC" and "POP HL"
                        ;
16BA: C1       [10]     RESDIV: POP	BC		; Restore divisor
16BB: E1       [20]     	POP	HL
16BC: 79       [24]     	LD	A,C		; Get MSB of quotient
16BD: 3C       [28]     	INC	A
16BE: 3D       [32]     	DEC	A
16BF: 1F       [36]     	RRA			; Bit 0 to bit 7
16C0: FA6D15   [46|46]  	JP	M,RONDB		; Done - Normalise result
16C3: 17       [50]     	RLA			; Restore carry
16C4: 7B       [54]     	LD	A,E		; Get LSB of quotient
16C5: 17       [58]     	RLA			; Double it
16C6: 5F       [62]     	LD	E,A		; Put it back
16C7: 7A       [66]     	LD	A,D		; Get NMSB of quotient
16C8: 17       [70]     	RLA			; Double it
16C9: 57       [74]     	LD	D,A		; Put it back
16CA: 79       [78]     	LD	A,C		; Get MSB of quotient
16CB: 17       [82]     	RLA			; Double it
16CC: 4F       [86]     	LD	C,A		; Put it back
16CD: 29       [97]     	ADD	HL,HL		; Double NMSB,LSB of divisor
16CE: 78       [101]    	LD	A,B		; Get MSB of divisor
16CF: 17       [105]    	RLA			; Double it
16D0: 47       [109]    	LD	B,A		; Put it back
16D1: 3A5A80   [122]    	LD	A,(DIV4)	; Get VLSB of quotient
16D4: 17       [126]    	RLA			; Double it
16D5: 325A80   [139]    	LD	(DIV4),A	; Put it back
16D8: 79       [143]    	LD	A,C		; Get MSB of quotient
16D9: B2       [147]    	OR	D		; Merge NMSB
16DA: B3       [151]    	OR	E		; Merge LSB
16DB: C2A716   [161|161]	JP	NZ,DIVLP	; Not done - Keep dividing
16DE: E5       [172]    	PUSH	HL		; Save divisor
16DF: 212C81   [182]    	LD	HL,FPEXP	; Point to exponent
16E2: 35       [193]    	DEC	(HL)		; Divide by 2
16E3: E1       [203]    	POP	HL		; Restore divisor
16E4: C2A716   [213|213]	JP	NZ,DIVLP	; Ok - Keep going
16E7: C39404   [223]    	JP	OVERR		; Overflow error
                        ;
16EA: 78       [ 4]     ADDEXP: LD	A,B		; Get exponent of dividend
16EB: B7       [ 8]     	OR	A		; Test it
16EC: CA0E17   [18|18]  	JP	Z,OVTST3	; Zero - Result zero
16EF: 7D       [22]     	LD	A,L		; Get add/subtract flag
16F0: 212C81   [32]     	LD	HL,FPEXP	; Point to exponent
16F3: AE       [39]     	XOR	(HL)		; Add or subtract it
16F4: 80       [43]     	ADD	A,B		; Add the other exponent
16F5: 47       [47]     	LD	B,A		; Save new exponent
16F6: 1F       [51]     	RRA			; Test exponent for overflow
16F7: A8       [55]     	XOR	B
16F8: 78       [59]     	LD	A,B		; Get exponent
16F9: F20D17   [69|69]  	JP	P,OVTST2	; Positive - Test for overflow
16FC: C680     [76]     	ADD	A,80H		; Add excess 128
16FE: 77       [83]     	LD	(HL),A		; Save new exponent
16FF: CA6D16   [93|93]  	JP	Z,POPHRT	; Zero - Result zero
1702: CD9217   [110]    	CALL	SIGNS		; Set MSBs and sign of result
1705: 77       [117]    	LD	(HL),A		; Save new exponent
1706: 2B       [123]    	DEC	HL		; Point to MSB
1707: C9       [133]    	RET
                        ;
1708: CD2C17   [17]     OVTST1: CALL	TSTSGN		; Test sign of FPREG
170B: 2F       [21]     	CPL			; Invert sign
170C: E1       [31]     	POP	HL		; Clean up stack
170D: B7       [ 4]     OVTST2: OR	A		; Test if new exponent zero
170E: E1       [10]     OVTST3: POP	HL		; Clear off return address
170F: F24C15   [20|20]  	JP	P,RESZER	; Result zero
1712: C39404   [30]     	JP	OVERR		; Overflow error
                        ;
1715: CD7817   [17]     MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
1718: 78       [21]     	LD	A,B		; Get exponent
1719: B7       [25]     	OR	A		; Is it zero?
171A: C8       [30|36]  	RET	Z		; Yes - Result is zero
171B: C602     [37]     	ADD	A,2		; Multiply by 4
171D: DA9404   [47|47]  	JP	C,OVERR		; Overflow - ?OV Error
1720: 47       [51]     	LD	B,A		; Re-save exponent
1721: CDE614   [68]     	CALL	FPADD		; Add BCDE to FPREG (Times 5)
1724: 212C81   [78]     	LD	HL,FPEXP	; Point to exponent
1727: 34       [89]     	INC	(HL)		; Double number (Times 10)
1728: C0       [94|100] 	RET	NZ		; Ok - Return
1729: C39404   [104]    	JP	OVERR		; Overflow error
                        ;
172C: 3A2C81   [13]     TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
172F: B7       [17]     	OR	A
1730: C8       [22|28]  	RET	Z		; RETurn if number is zero
1731: 3A2B81   [35]     	LD	A,(FPREG+2)	; Get MSB of FPREG
1734: FE                	DB	0FEH		; Test sign
1735: 2F       [ 4]     RETREL: CPL			; Invert sign
1736: 17       [ 8]     	RLA			; Sign bit to carry
1737: 9F       [ 4]     FLGDIF: SBC	A,A		; Carry to all bits of A
1738: C0       [ 9|15]  	RET	NZ		; Return -1 if negative
1739: 3C       [13]     	INC	A		; Bump to +1
173A: C9       [23]     	RET			; Positive - Return +1
                        ;
173B: CD2C17   [17]     SGN:	CALL	TSTSGN		; Test sign of FPREG
173E: 0688     [ 7]     FLGREL: LD	B,80H+8		; 8 bit integer in exponent
1740: 110000   [17]     	LD	DE,0		; Zero NMSB and LSB
1743: 212C81   [10]     RETINT: LD	HL,FPEXP	; Point to exponent
1746: 4F       [14]     	LD	C,A		; CDE = MSB,NMSB and LSB
1747: 70       [21]     	LD	(HL),B		; Save exponent
1748: 0600     [28]     	LD	B,0		; CDE = integer to normalise
174A: 23       [34]     	INC	HL		; Point to sign of result
174B: 3680     [44]     	LD	(HL),80H	; Set sign of result
174D: 17       [48]     	RLA			; Carry = sign of integer
174E: C33415   [58]     	JP	CONPOS		; Set sign of result
                        ;
1751: CD2C17   [17]     ABS:	CALL	TSTSGN		; Test sign of FPREG
1754: F0       [22|28]  	RET	P		; Return if positive
1755: 212B81   [10]     INVSGN: LD	HL,FPREG+2	; Point to MSB
1758: 7E       [17]     	LD	A,(HL)		; Get sign of mantissa
1759: EE80     [24]     	XOR	80H		; Invert sign of mantissa
175B: 77       [31]     	LD	(HL),A		; Re-save sign of mantissa
175C: C9       [41]     	RET
                        ;
175D: EB       [ 4]     STAKFP: EX	DE,HL		; Save code string address
175E: 2A2981   [20]     	LD	HL,(FPREG)	; LSB,NLSB of FPREG
1761: E3       [39]     	EX	(SP),HL		; Stack them,get return
1762: E5       [50]     	PUSH	HL		; Re-save return
1763: 2A2B81   [66]     	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
1766: E3       [85]     	EX	(SP),HL		; Stack them,get return
1767: E5       [96]     	PUSH	HL		; Re-save return
1768: EB       [100]    	EX	DE,HL		; Restore code string address
1769: C9       [110]    	RET
                        ;
176A: CD7B17   [17]     PHLTFP: CALL	LOADFP		; Number at HL to BCDE
176D: EB       [ 4]     FPBCDE: EX	DE,HL		; Save code string address
176E: 222981   [20]     	LD	(FPREG),HL	; Save LSB,NLSB of number
1771: 60       [24]     	LD	H,B		; Exponent of number
1772: 69       [28]     	LD	L,C		; MSB of number
1773: 222B81   [44]     	LD	(FPREG+2),HL	; Save MSB and exponent
1776: EB       [48]     	EX	DE,HL		; Restore code string address
1777: C9       [58]     	RET
                        ;
1778: 212981   [10]     BCDEFP: LD	HL,FPREG	; Point to FPREG
177B: 5E       [ 7]     LOADFP: LD	E,(HL)		; Get LSB of number
177C: 23       [13]     	INC	HL
177D: 56       [20]     	LD	D,(HL)		; Get NMSB of number
177E: 23       [26]     	INC	HL
177F: 4E       [33]     	LD	C,(HL)		; Get MSB of number
1780: 23       [39]     	INC	HL
1781: 46       [46]     	LD	B,(HL)		; Get exponent of number
1782: 23       [ 6]     INCHL:	INC	HL		; Used for conditional "INC HL"
1783: C9       [16]     	RET
                        ;
1784: 112981   [10]     FPTHL:	LD	DE,FPREG	; Point to FPREG
1787: 0604     [ 7]     DETHL4: LD	B,4		; 4 bytes to move
1789: 1A       [ 7]     DETHLB: LD	A,(DE)		; Get source
178A: 77       [14]     	LD	(HL),A		; Save destination
178B: 13       [20]     	INC	DE		; Next source
178C: 23       [26]     	INC	HL		; Next destination
178D: 05       [30]     	DEC	B		; Count bytes
178E: C28917   [40|40]  	JP	NZ,DETHLB	; Loop if more
1791: C9       [50]     	RET
                        ;
1792: 212B81   [10]     SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
1795: 7E       [17]     	LD	A,(HL)		; Get MSB
1796: 07       [21]     	RLCA			; Old sign to carry
1797: 37       [25]     	SCF			; Set MSBit
1798: 1F       [29]     	RRA			; Set MSBit of MSB
1799: 77       [36]     	LD	(HL),A		; Save new MSB
179A: 3F       [40]     	CCF			; Complement sign
179B: 1F       [44]     	RRA			; Old sign to carry
179C: 23       [50]     	INC	HL
179D: 23       [56]     	INC	HL
179E: 77       [63]     	LD	(HL),A		; Set sign of result
179F: 79       [67]     	LD	A,C		; Get MSB
17A0: 07       [71]     	RLCA			; Old sign to carry
17A1: 37       [75]     	SCF			; Set MSBit
17A2: 1F       [79]     	RRA			; Set MSBit of MSB
17A3: 4F       [83]     	LD	C,A		; Save MSB
17A4: 1F       [87]     	RRA
17A5: AE       [94]     	XOR	(HL)		; New sign of result
17A6: C9       [104]    	RET
                        ;
17A7: 78       [ 4]     CMPNUM: LD	A,B		; Get exponent of number
17A8: B7       [ 8]     	OR	A
17A9: CA2C17   [18|18]  	JP	Z,TSTSGN	; Zero - Test sign of FPREG
17AC: 213517   [28]     	LD	HL,RETREL	; Return relation routine
17AF: E5       [39]     	PUSH	HL		; Save for return
17B0: CD2C17   [56]     	CALL	TSTSGN		; Test sign of FPREG
17B3: 79       [60]     	LD	A,C		; Get MSB of number
17B4: C8       [65|71]  	RET	Z		; FPREG zero - Number's MSB
17B5: 212B81   [75]     	LD	HL,FPREG+2	; MSB of FPREG
17B8: AE       [82]     	XOR	(HL)		; Combine signs
17B9: 79       [86]     	LD	A,C		; Get MSB of number
17BA: F8       [91|97]  	RET	M		; Exit if signs different
17BB: CDC117   [108]    	CALL	CMPFP		; Compare FP numbers
17BE: 1F       [112]    	RRA			; Get carry to sign
17BF: A9       [116]    	XOR	C		; Combine with MSB of number
17C0: C9       [126]    	RET
                        ;
17C1: 23       [ 6]     CMPFP:	INC	HL		; Point to exponent
17C2: 78       [10]     	LD	A,B		; Get exponent
17C3: BE       [17]     	CP	(HL)		; Compare exponents
17C4: C0       [22|28]  	RET	NZ		; Different
17C5: 2B       [28]     	DEC	HL		; Point to MBS
17C6: 79       [32]     	LD	A,C		; Get MSB
17C7: BE       [39]     	CP	(HL)		; Compare MSBs
17C8: C0       [44|50]  	RET	NZ		; Different
17C9: 2B       [50]     	DEC	HL		; Point to NMSB
17CA: 7A       [54]     	LD	A,D		; Get NMSB
17CB: BE       [61]     	CP	(HL)		; Compare NMSBs
17CC: C0       [66|72]  	RET	NZ		; Different
17CD: 2B       [72]     	DEC	HL		; Point to LSB
17CE: 7B       [76]     	LD	A,E		; Get LSB
17CF: 96       [83]     	SUB	(HL)		; Compare LSBs
17D0: C0       [88|94]  	RET	NZ		; Different
17D1: E1       [98]     	POP	HL		; Drop RETurn
17D2: E1       [108]    	POP	HL		; Drop another RETurn
17D3: C9       [118]    	RET
                        ;
17D4: 47       [ 4]     FPINT:	LD	B,A		; <- Move
17D5: 4F       [ 8]     	LD	C,A		; <- exponent
17D6: 57       [12]     	LD	D,A		; <- to all
17D7: 5F       [16]     	LD	E,A		; <- bits
17D8: B7       [20]     	OR	A		; Test exponent
17D9: C8       [25|31]  	RET	Z		; Zero - Return zero
17DA: E5       [36]     	PUSH	HL		; Save pointer to number
17DB: CD7817   [53]     	CALL	BCDEFP		; Move FPREG to BCDE
17DE: CD9217   [70]     	CALL	SIGNS		; Set MSBs & sign of result
17E1: AE       [77]     	XOR	(HL)		; Combine with sign of FPREG
17E2: 67       [81]     	LD	H,A		; Save combined signs
17E3: FCF817   [91|98]  	CALL	M,DCBCDE	; Negative - Decrement BCDE
17E6: 3E98     [98]     	LD	A,80H+24	; 24 bits
17E8: 90       [102]    	SUB	B		; Bits to shift
17E9: CDAB15   [119]    	CALL	SCALE		; Shift BCDE
17EC: 7C       [123]    	LD	A,H		; Get combined sign
17ED: 17       [127]    	RLA			; Sign to carry
17EE: DC7E15   [137|144]	CALL	C,FPROND	; Negative - Round number up
17F1: 0600     [144]    	LD	B,0		; Zero exponent
17F3: DC9715   [154|161]	CALL	C,COMPL		; If negative make positive
17F6: E1       [164]    	POP	HL		; Restore pointer to number
17F7: C9       [174]    	RET
                        ;
17F8: 1B       [ 6]     DCBCDE: DEC	DE		; Decrement BCDE
17F9: 7A       [10]     	LD	A,D		; Test LSBs
17FA: A3       [14]     	AND	E
17FB: 3C       [18]     	INC	A
17FC: C0       [23|29]  	RET	NZ		; Exit if LSBs not FFFF
17FD: 0B       [29]     	DEC	BC		; Decrement MSBs
17FE: C9       [39]     	RET
                        ;
17FF: 212C81   [10]     INT:	LD	HL,FPEXP	; Point to exponent
1802: 7E       [17]     	LD	A,(HL)		; Get exponent
1803: FE98     [24]     	CP	80H+24		; Integer accuracy only?
1805: 3A2981   [37]     	LD	A,(FPREG)	; Get LSB
1808: D0       [42|48]  	RET	NC		; Yes - Already integer
1809: 7E       [49]     	LD	A,(HL)		; Get exponent
180A: CDD417   [66]     	CALL	FPINT		; F.P to integer
180D: 3698     [76]     	LD	(HL),80H+24	; Save 24 bit integer
180F: 7B       [80]     	LD	A,E		; Get LSB of number
1810: F5       [91]     	PUSH	AF		; Save LSB
1811: 79       [95]     	LD	A,C		; Get MSB of number
1812: 17       [99]     	RLA			; Sign to carry
1813: CD3415   [116]    	CALL	CONPOS		; Set sign of result
1816: F1       [126]    	POP	AF		; Restore LSB of number
1817: C9       [136]    	RET
                        ;
1818: 210000   [10]     MLDEBC: LD	HL,0		; Clear partial product
181B: 78       [14]     	LD	A,B		; Test multiplier
181C: B1       [18]     	OR	C
181D: C8       [23|29]  	RET	Z		; Return zero if zero
181E: 3E10     [30]     	LD	A,16		; 16 bits
1820: 29       [11]     MLDBLP: ADD	HL,HL		; Shift P.P left
1821: DA5810   [21|21]  	JP	C,BSERR		; ?BS Error if overflow
1824: EB       [25]     	EX	DE,HL
1825: 29       [36]     	ADD	HL,HL		; Shift multiplier left
1826: EB       [40]     	EX	DE,HL
1827: D22E18   [50|50]  	JP	NC,NOMLAD	; Bit was zero - No add
182A: 09       [61]     	ADD	HL,BC		; Add multiplicand
182B: DA5810   [71|71]  	JP	C,BSERR		; ?BS Error if overflow
182E: 3D       [ 4]     NOMLAD: DEC	A		; Count bits
182F: C22018   [14|14]  	JP	NZ,MLDBLP	; More
1832: C9       [24]     	RET
                        ;
1833: FE2D     [ 7]     ASCTFP: CP	'-'		; Negative?
1835: F5       [18]     	PUSH	AF		; Save it and flags
1836: CA3F18   [28|28]  	JP	Z,CNVNUM	; Yes - Convert number
1839: FE2B     [35]     	CP	'+'		; Positive?
183B: CA3F18   [45|45]  	JP	Z,CNVNUM	; Yes - Convert number
183E: 2B       [51]     	DEC	HL		; DEC 'cos GETCHR INCs
183F: CD4C15   [17]     CNVNUM: CALL	RESZER		; Set result to zero
1842: 47       [21]     	LD	B,A		; Digits after point counter
1843: 57       [25]     	LD	D,A		; Sign of exponent
1844: 5F       [29]     	LD	E,A		; Exponent of ten
1845: 2F       [33]     	CPL
1846: 4F       [37]     	LD	C,A		; Before or after point flag
1847: CDDD08   [17]     MANLP:	CALL	GETCHR		; Get next character
184A: DA9018   [27|27]  	JP	C,ADDIG		; Digit - Add to number
184D: FE2E     [34]     	CP	'.'
184F: CA6B18   [44|44]  	JP	Z,DPOINT	; '.' - Flag point
1852: FE45     [51]     	CP	'E'
1854: C26F18   [61|61]  	JP	NZ,CONEXP	; Not 'E' - Scale number
1857: CDDD08   [78]     	CALL	GETCHR		; Get next character
185A: CD830E   [95]     	CALL	SGNEXP		; Get sign of exponent
185D: CDDD08   [17]     EXPLP:	CALL	GETCHR		; Get next character
1860: DAB218   [27|27]  	JP	C,EDIGIT	; Digit - Add to exponent
1863: 14       [31]     	INC	D		; Is sign negative?
1864: C26F18   [41|41]  	JP	NZ,CONEXP	; No - Scale number
1867: AF       [45]     	XOR	A
1868: 93       [49]     	SUB	E		; Negate exponent
1869: 5F       [53]     	LD	E,A		; And re-save it
186A: 0C       [57]     	INC	C		; Flag end of number
186B: 0C       [ 4]     DPOINT: INC	C		; Flag point passed
186C: CA4718   [14|14]  	JP	Z,MANLP		; Zero - Get another digit
186F: E5       [11]     CONEXP: PUSH	HL		; Save code string address
1870: 7B       [15]     	LD	A,E		; Get exponent
1871: 90       [19]     	SUB	B		; Subtract digits after point
1872: F48818   [10|17]  SCALMI: CALL	P,SCALPL	; Positive - Multiply number
1875: F27E18   [20|20]  	JP	P,ENDCON	; Positive - All done
1878: F5       [31]     	PUSH	AF		; Save number of times to /10
1879: CD7416   [48]     	CALL	DIV10		; Divide by 10
187C: F1       [58]     	POP	AF		; Restore count
187D: 3C       [62]     	INC	A		; Count divides
                        ;
187E: C27218   [10|10]  ENDCON: JP	NZ,SCALMI	; More to do
1881: D1       [20]     	POP	DE		; Restore code string address
1882: F1       [30]     	POP	AF		; Restore sign of number
1883: CC5517   [40|47]  	CALL	Z,INVSGN	; Negative - Negate number
1886: EB       [44]     	EX	DE,HL		; Code string address to HL
1887: C9       [54]     	RET
                        ;
1888: C8       [ 5|11]  SCALPL: RET	Z		; Exit if no scaling needed
1889: F5       [11]     MULTEN: PUSH	AF		; Save count
188A: CD1517   [28]     	CALL	MLSP10		; Multiply number by 10
188D: F1       [38]     	POP	AF		; Restore count
188E: 3D       [42]     	DEC	A		; Count multiplies
188F: C9       [52]     	RET
                        ;
1890: D5       [11]     ADDIG:	PUSH	DE		; Save sign of exponent
1891: 57       [15]     	LD	D,A		; Save digit
1892: 78       [19]     	LD	A,B		; Get digits after point
1893: 89       [23]     	ADC	A,C		; Add one if after point
1894: 47       [27]     	LD	B,A		; Re-save counter
1895: C5       [38]     	PUSH	BC		; Save point flags
1896: E5       [49]     	PUSH	HL		; Save code string address
1897: D5       [60]     	PUSH	DE		; Save digit
1898: CD1517   [77]     	CALL	MLSP10		; Multiply number by 10
189B: F1       [87]     	POP	AF		; Restore digit
189C: D630     [94]     	SUB	'0'		; Make it absolute
189E: CDA718   [111]    	CALL	RSCALE		; Re-scale number
18A1: E1       [121]    	POP	HL		; Restore code string address
18A2: C1       [131]    	POP	BC		; Restore point flags
18A3: D1       [141]    	POP	DE		; Restore sign of exponent
18A4: C34718   [151]    	JP	MANLP		; Get another digit
                        ;
18A7: CD5D17   [17]     RSCALE: CALL	STAKFP		; Put number on stack
18AA: CD3E17   [34]     	CALL	FLGREL		; Digit to add to FPREG
18AD: C1       [10]     PADD:	POP	BC		; Restore number
18AE: D1       [20]     	POP	DE
18AF: C3E614   [30]     	JP	FPADD		; Add BCDE to FPREG and return
                        ;
18B2: 7B       [ 4]     EDIGIT: LD	A,E		; Get digit
18B3: 07       [ 8]     	RLCA			; Times 2
18B4: 07       [12]     	RLCA			; Times 4
18B5: 83       [16]     	ADD	A,E		; Times 5
18B6: 07       [20]     	RLCA			; Times 10
18B7: 86       [27]     	ADD	A,(HL)		; Add next digit
18B8: D630     [34]     	SUB	'0'		; Make it absolute
18BA: 5F       [38]     	LD	E,A		; Save new digit
18BB: C35D18   [48]     	JP	EXPLP		; Look for another digit
                        ;
18BE: E5       [11]     LINEIN: PUSH	HL		; Save code string address
18BF: 211D04   [21]     	LD	HL,INMSG	; Output " in "
18C2: CD2312   [38]     	CALL	PRS		; Output string at HL
18C5: E1       [48]     	POP	HL		; Restore code string address
18C6: EB       [ 4]     PRNTHL: EX	DE,HL		; Code string address to DE
18C7: AF       [ 8]     	XOR	A
18C8: 0698     [15]     	LD	B,80H+24	; 24 bits
18CA: CD4317   [32]     	CALL	RETINT		; Return the integer
18CD: 212212   [42]     	LD	HL,PRNUMS	; Print number string
18D0: E5       [53]     	PUSH	HL		; Save for return
18D1: 212E81   [10]     NUMASC: LD	HL,PBUFF	; Convert number to ASCII
18D4: E5       [21]     	PUSH	HL		; Save for return
18D5: CD2C17   [38]     	CALL	TSTSGN		; Test sign of FPREG
18D8: 3620     [48]     	LD	(HL),' '	; Space at start
18DA: F2DF18   [58|58]  	JP	P,SPCFST	; Positive - Space to start
18DD: 362D     [68]     	LD	(HL),'-'	; '-' sign at start
18DF: 23       [ 6]     SPCFST: INC	HL		; First byte of number
18E0: 3630     [16]     	LD	(HL),'0'	; '0' if zero
18E2: CA9519   [26|26]  	JP	Z,JSTZER	; Return '0' if zero
18E5: E5       [37]     	PUSH	HL		; Save buffer address
18E6: FC5517   [47|54]  	CALL	M,INVSGN	; Negate FPREG if negative
18E9: AF       [51]     	XOR	A		; Zero A
18EA: F5       [62]     	PUSH	AF		; Save it
18EB: CD9B19   [79]     	CALL	RNGTST		; Test number is in range
18EE: 014391   [10]     SIXDIG: LD	BC,9143H	; BCDE - 99999.9
18F1: 11F84F   [20]     	LD	DE,4FF8H
18F4: CDA717   [37]     	CALL	CMPNUM		; Compare numbers
18F7: B7       [41]     	OR	A
18F8: E20C19   [51|51]  	JP	PO,INRNG	; > 99999.9 - Sort it out
18FB: F1       [61]     	POP	AF		; Restore count
18FC: CD8918   [78]     	CALL	MULTEN		; Multiply by ten
18FF: F5       [89]     	PUSH	AF		; Re-save count
1900: C3EE18   [99]     	JP	SIXDIG		; Test it again
                        ;
1903: CD7416   [17]     GTSIXD: CALL	DIV10		; Divide by 10
1906: F1       [27]     	POP	AF		; Get count
1907: 3C       [31]     	INC	A		; Count divides
1908: F5       [42]     	PUSH	AF		; Re-save count
1909: CD9B19   [59]     	CALL	RNGTST		; Test number is in range
190C: CDD414   [17]     INRNG:	CALL	ROUND		; Add 0.5 to FPREG
190F: 3C       [21]     	INC	A
1910: CDD417   [38]     	CALL	FPINT		; F.P to integer
1913: CD6D17   [55]     	CALL	FPBCDE		; Move BCDE to FPREG
1916: 010603   [65]     	LD	BC,0306H	; 1E+06 to 1E-03 range
1919: F1       [75]     	POP	AF		; Restore count
191A: 81       [79]     	ADD	A,C		; 6 digits before point
191B: 3C       [83]     	INC	A		; Add one
191C: FA2819   [93|93]  	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
191F: FE08     [100]    	CP	6+1+1		; More than 999999 ?
1921: D22819   [110|110]	JP	NC,MAKNUM	; Yes - Do it in 'E' form
1924: 3C       [114]    	INC	A		; Adjust for exponent
1925: 47       [118]    	LD	B,A		; Exponent of number
1926: 3E02     [125]    	LD	A,2		; Make it zero after
                        ;
1928: 3D       [ 4]     MAKNUM: DEC	A		; Adjust for digits to do
1929: 3D       [ 8]     	DEC	A
192A: E1       [18]     	POP	HL		; Restore buffer address
192B: F5       [29]     	PUSH	AF		; Save count
192C: 11AE19   [39]     	LD	DE,POWERS	; Powers of ten
192F: 05       [43]     	DEC	B		; Count digits before point
1930: C23919   [53|53]  	JP	NZ,DIGTXT	; Not zero - Do number
1933: 362E     [63]     	LD	(HL),'.'	; Save point
1935: 23       [69]     	INC	HL		; Move on
1936: 3630     [79]     	LD	(HL),'0'	; Save zero
1938: 23       [85]     	INC	HL		; Move on
1939: 05       [ 4]     DIGTXT: DEC	B		; Count digits before point
193A: 362E     [14]     	LD	(HL),'.'	; Save point in case
193C: CC8217   [24|31]  	CALL	Z,INCHL		; Last digit - move on
193F: C5       [35]     	PUSH	BC		; Save digits before point
1940: E5       [46]     	PUSH	HL		; Save buffer address
1941: D5       [57]     	PUSH	DE		; Save powers of ten
1942: CD7817   [74]     	CALL	BCDEFP		; Move FPREG to BCDE
1945: E1       [84]     	POP	HL		; Powers of ten table
1946: 062F     [91]     	LD	B, '0'-1	; ASCII '0' - 1
1948: 04       [ 4]     TRYAGN: INC	B		; Count subtractions
1949: 7B       [ 8]     	LD	A,E		; Get LSB
194A: 96       [15]     	SUB	(HL)		; Subtract LSB
194B: 5F       [19]     	LD	E,A		; Save LSB
194C: 23       [25]     	INC	HL
194D: 7A       [29]     	LD	A,D		; Get NMSB
194E: 9E       [36]     	SBC	A,(HL)		; Subtract NMSB
194F: 57       [40]     	LD	D,A		; Save NMSB
1950: 23       [46]     	INC	HL
1951: 79       [50]     	LD	A,C		; Get MSB
1952: 9E       [57]     	SBC	A,(HL)		; Subtract MSB
1953: 4F       [61]     	LD	C,A		; Save MSB
1954: 2B       [67]     	DEC	HL		; Point back to start
1955: 2B       [73]     	DEC	HL
1956: D24819   [83|83]  	JP	NC,TRYAGN	; No overflow - Try again
1959: CD8B15   [100]    	CALL	PLUCDE		; Restore number
195C: 23       [106]    	INC	HL		; Start of next number
195D: CD6D17   [123]    	CALL	FPBCDE		; Move BCDE to FPREG
1960: EB       [127]    	EX	DE,HL		; Save point in table
1961: E1       [137]    	POP	HL		; Restore buffer address
1962: 70       [144]    	LD	(HL),B		; Save digit in buffer
1963: 23       [150]    	INC	HL		; And move on
1964: C1       [160]    	POP	BC		; Restore digit count
1965: 0D       [164]    	DEC	C		; Count digits
1966: C23919   [174|174]	JP	NZ,DIGTXT	; More - Do them
1969: 05       [178]    	DEC	B		; Any decimal part?
196A: CA7919   [188|188]	JP	Z,DOEBIT	; No - Do 'E' bit
196D: 2B       [ 6]     SUPTLZ: DEC	HL		; Move back through buffer
196E: 7E       [13]     	LD	A,(HL)		; Get character
196F: FE30     [20]     	CP	'0'		; '0' character?
1971: CA6D19   [30|30]  	JP	Z,SUPTLZ	; Yes - Look back for more
1974: FE2E     [37]     	CP	'.'		; A decimal point?
1976: C48217   [47|54]  	CALL	NZ,INCHL	; Move back over digit
                        ;
1979: F1       [10]     DOEBIT: POP	AF		; Get 'E' flag
197A: CA9819   [20|20]  	JP	Z,NOENED	; No 'E' needed - End buffer
197D: 3645     [30]     	LD	(HL),'E'	; Put 'E' in buffer
197F: 23       [36]     	INC	HL		; And move on
1980: 362B     [46]     	LD	(HL),'+'	; Put '+' in buffer
1982: F28919   [56|56]  	JP	P,OUTEXP	; Positive - Output exponent
1985: 362D     [66]     	LD	(HL),'-'	; Put '-' in buffer
1987: 2F       [70]     	CPL			; Negate exponent
1988: 3C       [74]     	INC	A
1989: 062F     [ 7]     OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
198B: 04       [ 4]     EXPTEN: INC	B		; Count subtractions
198C: D60A     [11]     	SUB	10		; Tens digit
198E: D28B19   [21|21]  	JP	NC,EXPTEN	; More to do
1991: C63A     [28]     	ADD	A,'0'+10	; Restore and make ASCII
1993: 23       [34]     	INC	HL		; Move on
1994: 70       [41]     	LD	(HL),B		; Save MSB of exponent
1995: 23       [ 6]     JSTZER: INC	HL		;
1996: 77       [13]     	LD	(HL),A		; Save LSB of exponent
1997: 23       [19]     	INC	HL
1998: 71       [ 7]     NOENED: LD	(HL),C		; Mark end of buffer
1999: E1       [17]     	POP	HL		; Restore code string address
199A: C9       [27]     	RET
                        ;
199B: 017494   [10]     RNGTST: LD	BC,9474H	; BCDE = 999999.
199E: 11F723   [20]     	LD	DE,23F7H
19A1: CDA717   [37]     	CALL	CMPNUM		; Compare numbers
19A4: B7       [41]     	OR	A
19A5: E1       [51]     	POP	HL		; Return address to HL
19A6: E20319   [61|61]  	JP	PO,GTSIXD	; Too big - Divide by ten
19A9: E9       [65]     	JP	(HL)		; Otherwise return to caller
                        ;
19AA: 00000080          HALF:	DB	00H,00H,00H,80H	; 0.5
                        ;
19AE: A08601            POWERS: DB	0A0H,086H,001H	; 100000
19B1: 102700            	DB	010H,027H,000H	; 10000
19B4: E80300            	DB	0E8H,003H,000H	; 1000
19B7: 640000            	DB	064H,000H,000H	; 100
19BA: 0A0000            	DB	00AH,000H,000H	; 10
19BD: 010000            	DB	001H,000H,000H	; 1
                        ;
19C0: 215517   [10]     NEGAFT: LD	HL,INVSGN	; Negate result
19C3: E3       [29]     	EX	(SP),HL		; To be done after caller
19C4: E9       [33]     	JP	(HL)		; Return to caller
                        ;
19C5: CD5D17   [17]     SQR:	CALL	STAKFP		; Put value on stack
19C8: 21AA19   [27]     	LD	HL,HALF		; Set power to 1/2
19CB: CD6A17   [44]     	CALL	PHLTFP		; Move 1/2 to FPREG
                        ;
19CE: C1       [10]     POWER:	POP	BC		; Get base
19CF: D1       [20]     	POP	DE
19D0: CD2C17   [37]     	CALL	TSTSGN		; Test sign of power
19D3: 78       [41]     	LD	A,B		; Get exponent of base
19D4: CA131A   [51|51]  	JP	Z,EXP		; Make result 1 if zero
19D7: F2DE19   [61|61]  	JP	P,POWER1	; Positive base - Ok
19DA: B7       [65]     	OR	A		; Zero to negative power?
19DB: CA8804   [75|75]  	JP	Z,DZERR		; Yes - ?/0 Error
19DE: B7       [ 4]     POWER1: OR	A		; Base zero?
19DF: CA4D15   [14|14]  	JP	Z,SAVEXP	; Yes - Return zero
19E2: D5       [25]     	PUSH	DE		; Save base
19E3: C5       [36]     	PUSH	BC
19E4: 79       [40]     	LD	A,C		; Get MSB of base
19E5: F67F     [47]     	OR	01111111B	; Get sign status
19E7: CD7817   [64]     	CALL	BCDEFP		; Move power to BCDE
19EA: F2FB19   [74|74]  	JP	P,POWER2	; Positive base - Ok
19ED: D5       [85]     	PUSH	DE		; Save power
19EE: C5       [96]     	PUSH	BC
19EF: CDFF17   [113]    	CALL	INT		; Get integer of power
19F2: C1       [123]    	POP	BC		; Restore power
19F3: D1       [133]    	POP	DE
19F4: F5       [144]    	PUSH	AF		; MSB of base
19F5: CDA717   [161]    	CALL	CMPNUM		; Power an integer?
19F8: E1       [171]    	POP	HL		; Restore MSB of base
19F9: 7C       [175]    	LD	A,H		; but don't affect flags
19FA: 1F       [179]    	RRA			; Exponent odd or even?
19FB: E1       [10]     POWER2: POP	HL		; Restore MSB and exponent
19FC: 222B81   [26]     	LD	(FPREG+2),HL	; Save base in FPREG
19FF: E1       [36]     	POP	HL		; LSBs of base
1A00: 222981   [52]     	LD	(FPREG),HL	; Save in FPREG
1A03: DCC019   [62|69]  	CALL	C,NEGAFT	; Odd power - Negate result
1A06: CC5517   [72|79]  	CALL	Z,INVSGN	; Negative base - Negate it
1A09: D5       [83]     	PUSH	DE		; Save power
1A0A: C5       [94]     	PUSH	BC
1A0B: CDE015   [111]    	CALL	LOG		; Get LOG of base
1A0E: C1       [121]    	POP	BC		; Restore power
1A0F: D1       [131]    	POP	DE
1A10: CD2116   [148]    	CALL	FPMULT		; Multiply LOG by power
                        ;
1A13: CD5D17   [17]     EXP:	CALL	STAKFP		; Put value on stack
1A16: 013881   [27]     	LD	BC,08138H	; BCDE = 1/Ln(2)
1A19: 113BAA   [37]     	LD	DE,0AA3BH
1A1C: CD2116   [54]     	CALL	FPMULT		; Multiply value by 1/LN(2)
1A1F: 3A2C81   [67]     	LD	A,(FPEXP)	; Get exponent
1A22: FE88     [74]     	CP	80H+8		; Is it in range?
1A24: D20817   [84|84]  	JP	NC,OVTST1	; No - Test for overflow
1A27: CDFF17   [101]    	CALL	INT		; Get INT of FPREG
1A2A: C680     [108]    	ADD	A,80H		; For excess 128
1A2C: C602     [115]    	ADD	A,2		; Exponent > 126?
1A2E: DA0817   [125|125]	JP	C,OVTST1	; Yes - Test for overflow
1A31: F5       [136]    	PUSH	AF		; Save scaling factor
1A32: 21CF15   [146]    	LD	HL,UNITY	; Point to 1.
1A35: CDD714   [163]    	CALL	ADDPHL		; Add 1 to FPREG
1A38: CD1816   [180]    	CALL	MULLN2		; Multiply by LN(2)
1A3B: F1       [190]    	POP	AF		; Restore scaling factor
1A3C: C1       [200]    	POP	BC		; Restore exponent
1A3D: D1       [210]    	POP	DE
1A3E: F5       [221]    	PUSH	AF		; Save scaling factor
1A3F: CDE314   [238]    	CALL	SUBCDE		; Subtract exponent from FPREG
1A42: CD5517   [255]    	CALL	INVSGN		; Negate result
1A45: 21531A   [265]    	LD	HL,EXPTAB	; Coefficient table
1A48: CD831A   [282]    	CALL	SMSER1		; Sum the series
1A4B: 110000   [292]    	LD	DE,0		; Zero LSBs
1A4E: C1       [302]    	POP	BC		; Scaling factor
1A4F: 4A       [306]    	LD	C,D		; Zero MSB
1A50: C32116   [316]    	JP	FPMULT		; Scale result to correct value
                        ;
1A53: 08                EXPTAB: DB	8			; Table used by EXP
1A54: 402E9474          	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
1A58: 704F2E77          	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
1A5C: 6E02887A          	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
1A60: E6A02A7C          	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
1A64: 50AAAA7E          	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
1A68: FFFF7F7F          	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
1A6C: 00008081          	DB	000H,000H,080H,081H	; -1/1! (-1/1)
1A70: 00000081          	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
                        ;
1A74: CD5D17   [17]     SUMSER: CALL	STAKFP		; Put FPREG on stack
1A77: 111F16   [27]     	LD	DE,MULT		; Multiply by "X"
1A7A: D5       [38]     	PUSH	DE		; To be done after
1A7B: E5       [49]     	PUSH	HL		; Save address of table
1A7C: CD7817   [66]     	CALL	BCDEFP		; Move FPREG to BCDE
1A7F: CD2116   [83]     	CALL	FPMULT		; Square the value
1A82: E1       [93]     	POP	HL		; Restore address of table
1A83: CD5D17   [17]     SMSER1: CALL	STAKFP		; Put value on stack
1A86: 7E       [24]     	LD	A,(HL)		; Get number of coefficients
1A87: 23       [30]     	INC	HL		; Point to start of table
1A88: CD6A17   [47]     	CALL	PHLTFP		; Move coefficient to FPREG
1A8B: 06                	DB	06H		; Skip "POP AF"
1A8C: F1       [10]     SUMLP:	POP	AF		; Restore count
1A8D: C1       [20]     	POP	BC		; Restore number
1A8E: D1       [30]     	POP	DE
1A8F: 3D       [34]     	DEC	A		; Cont coefficients
1A90: C8       [39|45]  	RET	Z		; All done
1A91: D5       [50]     	PUSH	DE		; Save number
1A92: C5       [61]     	PUSH	BC
1A93: F5       [72]     	PUSH	AF		; Save count
1A94: E5       [83]     	PUSH	HL		; Save address in table
1A95: CD2116   [100]    	CALL	FPMULT		; Multiply FPREG by BCDE
1A98: E1       [110]    	POP	HL		; Restore address in table
1A99: CD7B17   [127]    	CALL	LOADFP		; Number at HL to BCDE
1A9C: E5       [138]    	PUSH	HL		; Save address in table
1A9D: CDE614   [155]    	CALL	FPADD		; Add coefficient to FPREG
1AA0: E1       [165]    	POP	HL		; Restore address in table
1AA1: C38C1A   [175]    	JP	SUMLP		; More coefficients
                        ;
1AA4: CD2C17   [17]     RND:	CALL	TSTSGN		; Test sign of FPREG
1AA7: 215E80   [27]     	LD	HL,SEED+2	; Random number seed
1AAA: FA051B   [37|37]  	JP	M,RESEED	; Negative - Re-seed
1AAD: 217F80   [47]     	LD	HL,LSTRND	; Last random number
1AB0: CD6A17   [64]     	CALL	PHLTFP		; Move last RND to FPREG
1AB3: 215E80   [74]     	LD	HL,SEED+2	; Random number seed
1AB6: C8       [79|85]  	RET	Z		; Return if RND(0)
1AB7: 86       [86]     	ADD	A,(HL)		; Add (SEED)+2)
1AB8: E607     [93]     	AND	00000111B	; 0 to 7
1ABA: 0600     [100]    	LD	B,0
1ABC: 77       [107]    	LD	(HL),A		; Re-save seed
1ABD: 23       [113]    	INC	HL		; Move to coefficient table
1ABE: 87       [117]    	ADD	A,A		; 4 bytes
1ABF: 87       [121]    	ADD	A,A		; per entry
1AC0: 4F       [125]    	LD	C,A		; BC = Offset into table
1AC1: 09       [136]    	ADD	HL,BC		; Point to coefficient
1AC2: CD7B17   [153]    	CALL	LOADFP		; Coefficient to BCDE
1AC5: CD2116   [170]    	CALL	FPMULT	;	; Multiply FPREG by coefficient
1AC8: 3A5D80   [183]    	LD	A,(SEED+1)	; Get (SEED+1)
1ACB: 3C       [187]    	INC	A		; Add 1
1ACC: E603     [194]    	AND	00000011B	; 0 to 3
1ACE: 0600     [201]    	LD	B,0
1AD0: FE01     [208]    	CP	1		; Is it zero?
1AD2: 88       [212]    	ADC	A,B		; Yes - Make it 1
1AD3: 325D80   [225]    	LD	(SEED+1),A	; Re-save seed
1AD6: 21091B   [235]    	LD	HL,RNDTAB-4	; Addition table
1AD9: 87       [239]    	ADD	A,A		; 4 bytes
1ADA: 87       [243]    	ADD	A,A		; per entry
1ADB: 4F       [247]    	LD	C,A		; BC = Offset into table
1ADC: 09       [258]    	ADD	HL,BC		; Point to value
1ADD: CDD714   [275]    	CALL	ADDPHL		; Add value to FPREG
1AE0: CD7817   [17]     RND1:	CALL	BCDEFP		; Move FPREG to BCDE
1AE3: 7B       [21]     	LD	A,E		; Get LSB
1AE4: 59       [25]     	LD	E,C		; LSB = MSB
1AE5: EE4F     [32]     	XOR	01001111B	; Fiddle around
1AE7: 4F       [36]     	LD	C,A		; New MSB
1AE8: 3680     [46]     	LD	(HL),80H	; Set exponent
1AEA: 2B       [52]     	DEC	HL		; Point to MSB
1AEB: 46       [59]     	LD	B,(HL)		; Get MSB
1AEC: 3680     [69]     	LD	(HL),80H	; Make value -0.5
1AEE: 215C80   [79]     	LD	HL,SEED		; Random number seed
1AF1: 34       [90]     	INC	(HL)		; Count seed
1AF2: 7E       [97]     	LD	A,(HL)		; Get seed
1AF3: D6AB     [104]    	SUB	171		; Do it modulo 171
1AF5: C2FC1A   [114|114]	JP	NZ,RND2		; Non-zero - Ok
1AF8: 77       [121]    	LD	(HL),A		; Zero seed
1AF9: 0C       [125]    	INC	C		; Fillde about
1AFA: 15       [129]    	DEC	D		; with the
1AFB: 1C       [133]    	INC	E		; number
1AFC: CD3715   [17]     RND2:	CALL	BNORM		; Normalise number
1AFF: 217F80   [27]     	LD	HL,LSTRND	; Save random number
1B02: C38417   [37]     	JP	FPTHL		; Move FPREG to last and return
                        ;
1B05: 77       [ 7]     RESEED: LD	(HL),A		; Re-seed random numbers
1B06: 2B       [13]     	DEC	HL
1B07: 77       [20]     	LD	(HL),A
1B08: 2B       [26]     	DEC	HL
1B09: 77       [33]     	LD	(HL),A
1B0A: C3E01A   [43]     	JP	RND1		; Return RND seed
                        ;
1B0D: 68B14668          RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
1B11: 99E99269          	DB	099H,0E9H,092H,069H
1B15: 10D17568          	DB	010H,0D1H,075H,068H
                        ;
1B19: 21631B   [10]     COS:	LD	HL,HALFPI	; Point to PI/2
1B1C: CDD714   [27]     	CALL	ADDPHL		; Add it to PPREG
1B1F: CD5D17   [17]     SIN:	CALL	STAKFP		; Put angle on stack
1B22: 014983   [27]     	LD	BC,8349H	; BCDE = 2 PI
1B25: 11DB0F   [37]     	LD	DE,0FDBH
1B28: CD6D17   [54]     	CALL	FPBCDE		; Move 2 PI to FPREG
1B2B: C1       [64]     	POP	BC		; Restore angle
1B2C: D1       [74]     	POP	DE
1B2D: CD8216   [91]     	CALL	DVBCDE		; Divide angle by 2 PI
1B30: CD5D17   [108]    	CALL	STAKFP		; Put it on stack
1B33: CDFF17   [125]    	CALL	INT		; Get INT of result
1B36: C1       [135]    	POP	BC		; Restore number
1B37: D1       [145]    	POP	DE
1B38: CDE314   [162]    	CALL	SUBCDE		; Make it 0 <= value < 1
1B3B: 21671B   [172]    	LD	HL,QUARTR	; Point to 0.25
1B3E: CDDD14   [189]    	CALL	SUBPHL		; Subtract value from 0.25
1B41: CD2C17   [206]    	CALL	TSTSGN		; Test sign of value
1B44: 37       [210]    	SCF			; Flag positive
1B45: F24F1B   [220|220]	JP	P,SIN1		; Positive - Ok
1B48: CDD414   [237]    	CALL	ROUND		; Add 0.5 to value
1B4B: CD2C17   [254]    	CALL	TSTSGN		; Test sign of value
1B4E: B7       [258]    	OR	A		; Flag negative
1B4F: F5       [11]     SIN1:	PUSH	AF		; Save sign
1B50: F45517   [21|28]  	CALL	P,INVSGN	; Negate value if positive
1B53: 21671B   [31]     	LD	HL,QUARTR	; Point to 0.25
1B56: CDD714   [48]     	CALL	ADDPHL		; Add 0.25 to value
1B59: F1       [58]     	POP	AF		; Restore sign
1B5A: D45517   [68|75]  	CALL	NC,INVSGN	; Negative - Make positive
1B5D: 216B1B   [78]     	LD	HL,SINTAB	; Coefficient table
1B60: C3741A   [88]     	JP	SUMSER		; Evaluate sum of series
                        ;
1B63: DB0F4981          HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
                        ;
1B67: 0000007F          QUARTR: DB	000H,000H,000H,07FH	; 0.25
                        ;
1B6B: 05                SINTAB: DB	5			; Table used by SIN
1B6C: BAD71E86          	DB	0BAH,0D7H,01EH,086H	; 39.711
1B70: 64269987          	DB	064H,026H,099H,087H	;-76.575
1B74: 58342387          	DB	058H,034H,023H,087H	; 81.602
1B78: E05DA586          	DB	0E0H,05DH,0A5H,086H	;-41.342
1B7C: DA0F4983          	DB	0DAH,00FH,049H,083H	; 6.2832
                        ;
1B80: CD5D17   [17]     TAN:	CALL	STAKFP		; Put angle on stack
1B83: CD1F1B   [34]     	CALL	SIN		; Get SIN of angle
1B86: C1       [44]     	POP	BC		; Restore angle
1B87: E1       [54]     	POP	HL
1B88: CD5D17   [71]     	CALL	STAKFP		; Save SIN of angle
1B8B: EB       [75]     	EX	DE,HL		; BCDE = Angle
1B8C: CD6D17   [92]     	CALL	FPBCDE		; Angle to FPREG
1B8F: CD191B   [109]    	CALL	COS		; Get COS of angle
1B92: C38016   [119]    	JP	DIV		; TAN = SIN / COS
                        ;
1B95: CD2C17   [17]     ATN:	CALL	TSTSGN		; Test sign of value
1B98: FCC019   [27|34]  	CALL	M,NEGAFT	; Negate result after if -ve
1B9B: FC5517   [37|44]  	CALL	M,INVSGN	; Negate value if -ve
1B9E: 3A2C81   [50]     	LD	A,(FPEXP)	; Get exponent
1BA1: FE81     [57]     	CP	81H		; Number less than 1?
1BA3: DAB21B   [67|67]  	JP	C,ATN1		; Yes - Get arc tangnt
1BA6: 010081   [77]     	LD	BC,8100H	; BCDE = 1
1BA9: 51       [81]     	LD	D,C
1BAA: 59       [85]     	LD	E,C
1BAB: CD8216   [102]    	CALL	DVBCDE		; Get reciprocal of number
1BAE: 21DD14   [112]    	LD	HL,SUBPHL	; Sub angle from PI/2
1BB1: E5       [123]    	PUSH	HL		; Save for angle > 1
1BB2: 21BC1B   [10]     ATN1:	LD	HL,ATNTAB	; Coefficient table
1BB5: CD741A   [27]     	CALL	SUMSER		; Evaluate sum of series
1BB8: 21631B   [37]     	LD	HL,HALFPI	; PI/2 - angle in case > 1
1BBB: C9       [47]     	RET			; Number > 1 - Sub from PI/2
                        ;
1BBC: 09                ATNTAB: DB	9			; Table used by ATN
1BBD: 4AD73B78          	DB	04AH,0D7H,03BH,078H	; 1/17
1BC1: 026E847B          	DB	002H,06EH,084H,07BH	;-1/15
1BC5: FEC12F7C          	DB	0FEH,0C1H,02FH,07CH	; 1/13
1BC9: 74319A7D          	DB	074H,031H,09AH,07DH	;-1/11
1BCD: 843D5A7D          	DB	084H,03DH,05AH,07DH	; 1/9
1BD1: C87F917E          	DB	0C8H,07FH,091H,07EH	;-1/7
1BD5: E4BB4C7E          	DB	0E4H,0BBH,04CH,07EH	; 1/5
1BD9: 6CAAAA7F          	DB	06CH,0AAH,0AAH,07FH	;-1/3
1BDD: 00000081          	DB	000H,000H,000H,081H	; 1/1
                        ;
                        
1BE1: C9       [10]     ARET:	RET			; A RETurn instruction
                        ;
1BE2: D7       [11]     GETINP: RST	10H		;input a character
1BE3: C9       [21]     	RET
                        ;
1BE4:                   CLS: 
1BE4: 3E0C     [ 7]     	LD	A,CS		; ASCII Clear screen
1BE6: C31A1D   [17]     	JP	MONOUT		; Output character
                        ;
1BE9: CDAB14   [17]     WIDTH:	CALL	GETINT		; Get integer 0-255
1BEC: 7B       [21]     	LD	A,E		; Width to A
1BED: 328780   [34]     	LD	(LWIDTH),A	; Set width
1BF0: C9       [44]     	RET
                        ;
1BF1: CD4A0D   [17]     LINES:	CALL	GETNUM		; Get a number
1BF4: CD8F09   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1BF7: ED538B80 [54]     	LD	(LINESC),DE	; Set lines counter
1BFB: ED538D80 [74]     	LD	(LINESN),DE	; Set lines number
1BFF: C9       [84]     	RET
                        ;
1C00: CD8F09   [17]     DEEK:	CALL	DEINT		; Get integer -32768 to 32767
1C03: D5       [28]     	PUSH	DE		; Save number
1C04: E1       [38]     	POP	HL		; Number to HL
1C05: 46       [45]     	LD	B,(HL)		; Get LSB of contents
1C06: 23       [51]     	INC	HL
1C07: 7E       [58]     	LD	A,(HL)		; Get MSB of contents
1C08: C30511   [68]     	JP	ABPASS		; Return integer AB
                        ;
1C0B: CD4A0D   [17]     DOKE:	CALL	GETNUM		; Get a number
1C0E: CD8F09   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1C11: D5       [45]     	PUSH	DE		; Save address
1C12: CD5307   [62]     	CALL	CHKSYN		; Make sure ',' follows
1C15: 2C                	DB	','
1C16: CD4A0D   [79]     	CALL	GETNUM		; Get a number
1C19: CD8F09   [96]     	CALL	DEINT		; Get integer -32768 to 32767
1C1C: E3       [115]    	EX	(SP),HL		; Save value,get address
1C1D: 73       [122]    	LD	(HL),E		; Save LSB of value
1C1E: 23       [128]    	INC	HL
1C1F: 72       [135]    	LD	(HL),D		; Save MSB of value
1C20: E1       [145]    	POP	HL		; Restore code string address
1C21: C9       [155]    	RET
                        ;
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        ;
1C22: CD4D0D   [17]     HEX: 	CALL	TSTNUM		; Verify it's a number
1C25: CD8F09   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1C28: C5       [45]     	PUSH	BC		; Save contents of BC
1C29: 212E81   [55]     	LD	HL,PBUFF
1C2C: 7A       [59]     	LD	A,D		; Get high order into A
1C2D: FE00     [66]     	CP	0
1C2F: 280C     [73|78]  	JR	Z,HEX2		; Skip output if both high digits are zero
1C31: CD5A1C   [90]     	CALL	BYT2ASC		; Convert D to ASCII
1C34: 78       [94]     	LD	A,B
1C35: FE30     [101]    	CP	'0'
1C37: 2802     [108|113]	JR	Z,HEX1		; Don't store high digit if zero
1C39: 70       [115]    	LD	(HL),B		; Store it to PBUFF
1C3A: 23       [121]    	INC	HL		; Next location
1C3B: 71       [ 7]     HEX1:	LD	(HL),C		; Store C to PBUFF+1
1C3C: 23       [13]     	INC	HL		; Next location
1C3D: 7B       [ 4]     HEX2:	LD	A,E		; Get lower byte
1C3E: CD5A1C   [21]     	CALL	BYT2ASC		; Convert E to ASCII
1C41: 7A       [25]     	LD	A,D
1C42: FE00     [32]     	CP	0
1C44: 2005     [39|44]  	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
1C46: 78       [43]     	LD	A,B
1C47: FE30     [50]     	CP	'0'		; If high digit of lower byte is zero then don't print
1C49: 2802     [57|62]  	JR	Z,HEX4
1C4B: 70       [ 7]     HEX3:	LD	(HL),B		; to PBUFF+2
1C4C: 23       [13]     	INC	HL		; Next location
1C4D: 71       [ 7]     HEX4:	LD	(HL),C		; to PBUFF+3
1C4E: 23       [13]     	INC	HL		; PBUFF+4 to zero
1C4F: AF       [17]     	XOR	A		; Terminating character
1C50: 77       [24]     	LD	(HL),A		; Store zero to terminate
1C51: 23       [30]     	INC	HL		; Make sure PBUFF is terminated
1C52: 77       [37]     	LD	(HL),A		; Store the double zero there
1C53: C1       [47]     	POP	BC		; Get BC back
1C54: 212E81   [57]     	LD	HL,PBUFF	; Reset to start of PBUFF
1C57: C3B311   [67]     	JP	STR1		; Convert the PBUFF to a string and return it
                        ;
1C5A: 47       [ 4]     BYT2ASC	LD	B,A		; Save original value
1C5B: E60F     [11]     	AND	0FH		; Strip off upper nybble
1C5D: FE0A     [18]     	CP	0AH		; 0-9?
1C5F: 3802     [25|30]  	JR	C,ADD30		; If A-F, add 7 more
1C61: C607     [32]     	ADD	A,07H		; Bring value up to ASCII A-F
1C63: C630     [ 7]     ADD30	ADD	A,30H		; And make ASCII
1C65: 4F       [11]     	LD	C,A		; Save converted char to C
1C66: 78       [15]     	LD	A,B		; Retrieve original value
1C67: 0F       [19]     	RRCA			; and Rotate it right
1C68: 0F       [23]     	RRCA
1C69: 0F       [27]     	RRCA
1C6A: 0F       [31]     	RRCA
1C6B: E60F     [38]     	AND	0FH		; Mask off upper nybble
1C6D: FE0A     [45]     	CP	0AH		; 0-9? < A hex?
1C6F: 3802     [52|57]  	JR	C,ADD301	; Skip Add 7
1C71: C607     [59]     	ADD	A,07H		; Bring it up to ASCII A-F
1C73: C630     [ 7]     ADD301	ADD	A,30H		; And make it full ASCII
1C75: 47       [11]     	LD	B,A		; Store high order byte
1C76: C9       [21]     	RET	
                        ;
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
1C77: EB       [ 4]     HEXTFP	EX	DE,HL		; Move code string pointer to DE
1C78: 210000   [14]     	LD	HL,0000H	; Zero out the value
1C7B: CD901C   [31]     	CALL	GETHEX		; Check the number for valid hex
1C7E: DAB01C   [41|41]  	JP	C,HXERR		; First value wasn't hex, HX error
1C81: 1805     [53]     	JR	HEXLP1		; Convert first character
1C83: CD901C   [17]     HEXLP	CALL	GETHEX		; Get second and addtional characters
1C86: 381F     [24|29]  	JR	C,HEXIT		; Exit if not a hex character
1C88: 29       [11]     HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
1C89: 29       [22]     	ADD	HL,HL
1C8A: 29       [33]     	ADD	HL,HL
1C8B: 29       [44]     	ADD	HL,HL
1C8C: B5       [48]     	OR	L		; Add in D0-D3 into L
1C8D: 6F       [52]     	LD	L,A		; Save new value
1C8E: 18F3     [64]     	JR	HEXLP		; And continue until all hex characters are in
                        ;
1C90: 13       [ 6]     GETHEX	INC	DE		; Next location
1C91: 1A       [13]     	LD	A,(DE)		; Load character at pointer
1C92: FE20     [20]     	CP	' '
1C94: CA901C   [30|30]  	JP	Z,GETHEX	; Skip spaces
1C97: D630     [37]     	SUB	30H		; Get absolute value
1C99: D8       [42|48]  	RET	C		; < "0", error
1C9A: FE0A     [49]     	CP	0AH
1C9C: 3805     [56|61]  	JR	C,NOSUB7	; Is already in the range 0-9
1C9E: D607     [63]     	SUB	07H		; Reduce to A-F
1CA0: FE0A     [70]     	CP	0AH		; Value should be $0A-$0F at this point
1CA2: D8       [75|81]  	RET	C		; CY set if was :		; < = > ? @
1CA3: FE10     [ 7]     NOSUB7	CP	10H		; > Greater than "F"?
1CA5: 3F       [11]     	CCF
1CA6: C9       [21]     	RET			; CY set if it wasn't valid hex
                        	
1CA7: EB       [ 4]     HEXIT	EX	DE,HL		; Value into DE, Code string into HL
1CA8: 7A       [ 8]     	LD	A,D		; Load DE into AC
1CA9: 4B       [12]     	LD	C,E		; For prep to 
1CAA: E5       [23]     	PUSH	HL
1CAB: CD0411   [40]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1CAE: E1       [50]     	POP	HL
1CAF: C9       [60]     	RET
                        ;
1CB0: 1E26     [ 7]     HXERR:	LD	E,HX		; ?HEX Error
1CB2: C39904   [17]     	JP	ERROR
                        ;
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
1CB5: CD4D0D   [17]     BIN:	CALL	TSTNUM		; Verify it's a number
1CB8: CD8F09   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1CBB: C5       [11]     BIN2:	PUSH	BC		; Save contents of BC
1CBC: 212E81   [21]     	LD	HL,PBUFF
1CBF: 0611     [28]     	LD	B,17		; One higher than max char count
1CC1:                   ZEROSUP:			; Suppress leading zeros
1CC1: 05       [ 4]     	DEC	B		; Max 16 chars
1CC2: 78       [ 8]     	LD	A,B
1CC3: FE01     [15]     	CP	01H
1CC5: 2808     [22|27]  	JR	Z,BITOUT	; Always output at least one character
1CC7: CB13     [30]     	RL	E
1CC9: CB12     [38]     	RL	D
1CCB: 30F4     [45|50]  	JR	NC,ZEROSUP
1CCD: 1804     [57]     	JR	BITOUT2
1CCF:                   BITOUT:	
1CCF: CB13     [ 8]     	RL	E
1CD1: CB12     [16]     	RL	D		; Top bit now in carry
1CD3:                   BITOUT2:
1CD3: 3E30     [ 7]     	LD	A,'0'		; Char for '0'
1CD5: CE00     [14]     	ADC	A,0		; If carry set then '0' --> '1'
1CD7: 77       [21]     	LD	(HL),A
1CD8: 23       [27]     	INC	HL
1CD9: 05       [31]     	DEC	B
1CDA: 20F3     [38|43]  	JR	NZ,BITOUT
1CDC: AF       [42]     	XOR	A		; Terminating character
1CDD: 77       [49]     	LD	(HL),A		; Store zero to terminate
1CDE: 23       [55]     	INC	HL		; Make sure PBUFF is terminated
1CDF: 77       [62]     	LD	(HL),A		; Store the double zero there
1CE0: C1       [72]     	POP	BC
1CE1: 212E81   [82]     	LD	HL,PBUFF
1CE4: C3B311   [92]     	JP	STR1
                        ;
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1CE7: EB       [ 4]     BINTFP: EX	DE,HL		; Move code string pointer to DE
1CE8: 210000   [14]     	LD	HL,0000H	; Zero out the value
1CEB: CD041D   [31]     	CALL	CHKBIN		; Check the number for valid bin
1CEE: DA121D   [41|41]  	JP	C,BINERR	; First value wasn't bin, HX error
1CF1: D630     [ 7]     BINIT:	SUB	'0'
1CF3: 29       [18]     	ADD	HL,HL		; Rotate HL left
1CF4: B5       [22]     	OR	L
1CF5: 6F       [26]     	LD	L,A
1CF6: CD041D   [43]     	CALL	CHKBIN		; Get second and addtional characters
1CF9: 30F6     [50|55]  	JR	NC,BINIT	; Process if a bin character
1CFB: EB       [54]     	EX	DE,HL		; Value into DE, Code string into HL
1CFC: 7A       [58]     	LD	A,D		; Load DE into AC
1CFD: 4B       [62]     	LD	C,E		; For prep to 
1CFE: E5       [73]     	PUSH	HL
1CFF: CD0411   [90]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1D02: E1       [100]    	POP	HL
1D03: C9       [110]    	RET
                        ;
                        ; Char is in A, NC if char is 0 or 1
1D04: 13       [ 6]     CHKBIN: INC	DE
1D05: 1A       [13]     	LD	A,(DE)
1D06: FE20     [20]     	CP	' '
1D08: CA041D   [30|30]  	JP	Z,CHKBIN	; Skip spaces
1D0B: FE30     [37]     	CP	'0'		; Set C if < '0'
1D0D: D8       [42|48]  	RET	C
1D0E: FE32     [49]     	CP	'2'
1D10: 3F       [53]     	CCF			; Set C if > '1'
1D11: C9       [63]     	RET
                        ;
1D12: 1E28     [ 7]     BINERR: LD	E,BN		; ?BIN Error
1D14: C39904   [17]     	JP	ERROR
                        ;
1D17: C3DE00   [10]     JJUMP1: JP	CSTART		; Go and initialise
                        ;
1D1A: C30800   [10]     MONOUT: JP	0008H		; output a char
                        ;
1D1D: C30000   [10]     MONITR: JP	0000H		; Restart (Normally Monitor Start)
                        ;
1D20: 3E00     [ 7]     INITST: LD	A,0		; Clear break flag
1D22: 329280   [20]     	LD	(BRKFLG),A
1D25: C3E500   [30]     	JP	INIT
                        ;
1D28: F5       [11]     TSTBIT: PUSH	AF		; Save bit mask
1D29: A0       [15]     	AND	B		; Get common bits
1D2A: C1       [25]     	POP	BC		; Restore bit mask
1D2B: B8       [29]     	CP	B		; Same bit set?
1D2C: 3E00     [36]     	LD	A,0		; Return 0 in A
1D2E: C9       [46]     	RET
                        ;
1D2F: CD5E07   [17]     OUTNCR: CALL	OUTC		; Output character in A
1D32: C3850B   [27]     	JP	PRCRLF		; Output CRLF
                        ;
1D35:                   RUNST: 
1D35: 21FAFF   [10]       LD HL,0FFFAH
1D38: 7E       [17]       LD A,(HL)
1D39: 21FBFF   [27]       LD HL,0FFFBH
1D3C: 46       [34]       LD B,(HL)
1D3D: 67       [38]       LD H,A
1D3E: 68       [42]       LD L,B
1D3F: E9       [46]       JP (HL)
                        ;
1D40: FFFFFFFF            ORG	0x2100
1D44: FF...             
2100:                   START1:
2100: 01FFFF   [10]       LD BC,0ffffH
2103: 3E0F     [17]       LD A,00001111B ; PIOB0
2105: D30B     [28]       OUT (PIOBC),A
2107: 1600     [35]       LD D,0
2109: 210000   [45]       LD HL,0
210C:                   LOOP1:
210C: 03       [ 6]       INC BC
210D: ED43FEFF [26]       LD (DISPD),BC ;BC
                          ; check BC is 0
2111: 78       [30]       LD A,B
2112: B1       [34]       OR C
2113: 20F7     [41|46]    JR NZ,LOOP1
                          ; BC = 0
2115: 3E01     [48]       LD A,#0x01
2117: AA       [52]       XOR D
2118: 57       [56]       LD D,A
2119: D309     [67]       OUT (PIOBD),A
211B: 22FCFF   [83]       LD (DISPA),HL ; HL
211E: 23       [89]       INC HL
211F: C30C21   [99]       JP LOOP1
                        	END


; +++ segments +++

#CODE          = $0000 =     0,  size = $2122 =  8482

; +++ global symbols +++

ABPASS  = $1105 =  4357          main.asm:2547
ABS     = $1751 =  5969          main.asm:3570
ACCSUM  = $096E =  2414          main.asm:1449 (unused)
ACPASS  = $1104 =  4356          main.asm:2546
ADD30   = $1C63 =  7267          main.asm:4318
ADD301  = $1C73 =  7283          main.asm:4329
ADDEXP  = $16EA =  5866          main.asm:3505
ADDIG   = $1890 =  6288          main.asm:3793
ADDPHL  = $14D7 =  5335          main.asm:3152
ALLFOL  = $13D3 =  5075          main.asm:2994
ALLINIT = $0000 =     0          main.asm:29 (unused)
ANTVLU  = $0C6E =  3182          main.asm:1856
ARET    = $1BE1 =  7137          main.asm:4233 (unused)
ARLDSV  = $1025 =  4133          main.asm:2402
ARREND  = $811F = 33055          main.asm:246
ARRLP   = $129E =  4766          main.asm:2785
ASC     = $13A4 =  5028          main.asm:2964
ASCTFP  = $1833 =  6195          main.asm:3739
ASPCS   = $0BD0 =  3024          main.asm:1779
ATN     = $1B95 =  7061          main.asm:4204
ATN1    = $1BB2 =  7090          main.asm:4216
ATNTAB  = $1BBC =  7100          main.asm:4221
ATOH    = $09A9 =  2473          main.asm:1482
BADINP  = $0BF5 =  3061          main.asm:1791
BAKSTK  = $042E =  1070          main.asm:657
BAKTMP  = $1384 =  4996          main.asm:2942
BASTXT  = $80A3 = 32931          main.asm:222
BCDEFP  = $1778 =  6008          main.asm:3597
BFREE   = $015E =   350          main.asm:355
BIN     = $1CB5 =  7349          main.asm:4378
BIN2    = $1CBB =  7355          main.asm:4380 (unused)
BINERR  = $1D12 =  7442          main.asm:4441
BINIT   = $1CF1 =  7409          main.asm:4416
BINTFP  = $1CE7 =  7399          main.asm:4412
BITOUT  = $1CCF =  7375          main.asm:4392
BITOUT2 = $1CD3 =  7379          main.asm:4395
BKSP    = $0008 =     8          main.asm:179
BN      = $0028 =    40          main.asm:280
BNORM   = $1537 =  5431          main.asm:3211
BNRMLP  = $153A =  5434          main.asm:3214
BRK     = $0920 =  2336          main.asm:1404
BRKFLG  = $8092 = 32914          main.asm:215
BRKLIN  = $8113 = 33043          main.asm:240
BRKMSG  = $0428 =  1064          main.asm:655
BRKRET  = $014F =   335          main.asm:348
BS      = $0010 =    16          main.asm:268
BSERR   = $1058 =  4184          main.asm:2433
BUFFER  = $80A6 = 32934          main.asm:223
BYT2ASC = $1C5A =  7258          main.asm:4313
BYTSFT  = $166F =  5743          main.asm:3422
CFEVAL  = $0FBB =  4027          main.asm:2333
CHARTY  = $0F69 =  3945          main.asm:2289
CHEKFN  = $119C =  4508          main.asm:2638
CHKBIN  = $1D04 =  7428          main.asm:4431
CHKLTR  = $097B =  2427          main.asm:1458
CHKSTK  = $0462 =  1122          main.asm:694
CHKSUM  = $808F = 32911          main.asm:213
CHKSYN  = $0753 =  1875          main.asm:1128
CHKTYP  = $0D4F =  3407          main.asm:1971
CHR     = $13B5 =  5045          main.asm:2976
CLEAR   = $09CE =  2510          main.asm:1506
CLOTST  = $0788 =  1928          main.asm:1160
CLREG   = $05B7 =  1463          main.asm:900
CLRPTR  = $0592 =  1426          main.asm:880
CLS     = $1BE4 =  7140          main.asm:4238
CMPFP   = $17C1 =  6081          main.asm:3655
CMPLG1  = $0ECF =  3791          main.asm:2195
CMPLOG  = $0ECD =  3789          main.asm:2194
CMPNUM  = $17A7 =  6055          main.asm:3638
CMPRES  = $0F11 =  3857          main.asm:2243
CMPSTR  = $0EF9 =  3833          main.asm:2223
CN      = $0020 =    32          main.asm:276
CNVNUM  = $183F =  6207          main.asm:3745
COLD    = $00D1 =   209          main.asm:282
COMMAN  = $8088 = 32904          main.asm:208
COMPL   = $1597 =  5527          main.asm:3285
CONCAT  = $1319 =  4889          main.asm:2875
CONEXP  = $186F =  6255          main.asm:3769
CONPOS  = $1534 =  5428          main.asm:3209
CONT    = $0953 =  2387          main.asm:1432
CONTAD  = $8119 = 33049          main.asm:243
CONVAR  = $0E3A =  3642          main.asm:2095
COPY    = $00ED =   237          main.asm:296
COS     = $1B19 =  6937          main.asm:4152
COUNT   = $07F8 =  2040          main.asm:1226
CPDEHL  = $074D =  1869          main.asm:1121
CPYLIT  = $0689 =  1673          main.asm:1018
CR      = $000D =    13          main.asm:26
CRARLP  = $1078 =  4216          main.asm:2453
CREARY  = $105D =  4189          main.asm:2436
CRESTR  = $0ACD =  2765          main.asm:1645
CRNCLP  = $05EA =  1514          main.asm:926
CRTMST  = $11D5 =  4565          main.asm:2671
CRTST   = $11E1 =  4577          main.asm:2682
CRTSTE  = $11F7 =  4599          main.asm:2696
CRUNCH  = $05E1 =  1505          main.asm:922
CS      = $000C =    12          main.asm:181
CSTART  = $00DE =   222          main.asm:289
CTLOFG  = $808A = 32906          main.asm:210
CTRLC   = $0003 =     3          main.asm:177
CTRLG   = $0007 =     7          main.asm:178
CTRLO   = $000F =    15          main.asm:183
CTRLQ   = $0011 =    17          main.asm:184
CTRLR   = $0012 =    18          main.asm:185
CTRLS   = $0013 =    19          main.asm:186
CTRLU   = $0015 =    21          main.asm:187
CUROPR  = $810A = 33034          main.asm:234
CURPOS  = $80F0 = 33008          main.asm:225
DATA    = $0A74 =  2676          main.asm:1597
DATFLG  = $80F3 = 33011          main.asm:228
DATLIN  = $810E = 33038          main.asm:236
DATSNR  = $047F =  1151          main.asm:714
DCBCDE  = $17F8 =  6136          main.asm:3698
DDERR   = $048E =  1166          main.asm:722
DEEK    = $1C00 =  7168          main.asm:4253
DEF     = $1119 =  4377          main.asm:2559
DEFSIZ  = $1080 =  4224          main.asm:2457
DEINT   = $098F =  2447          main.asm:1469
DEL     = $007F =   127          main.asm:189
DELCHR  = $06B9 =  1721          main.asm:1048
DEPINT  = $0989 =  2441          main.asm:1467
DETHL4  = $1787 =  6023          main.asm:3609
DETHLB  = $1789 =  6025          main.asm:3610
DIGTXT  = $1939 =  6457          main.asm:3891
DIM     = $0F3B =  3899          main.asm:2269
DIMRET  = $0F32 =  3890          main.asm:2264
DINPOS  = $0782 =  1922          main.asm:1155
DISPA   = $FFFC = 65532          main.asm:23
DISPD   = $FFFE = 65534          main.asm:24
DIV     = $1680 =  5760          main.asm:3433
DIV1    = $804F = 32847          main.asm:198
DIV10   = $1674 =  5748          main.asm:3428
DIV2    = $8053 = 32851          main.asm:199
DIV3    = $8057 = 32855          main.asm:200
DIV4    = $805A = 32858          main.asm:201
DIVLP   = $16A7 =  5799          main.asm:3457
DIVSUP  = $804E = 32846          main.asm:197
DOAGN   = $05D0 =  1488          main.asm:913
DOCOM   = $0BA1 =  2977          main.asm:1755
DODEL   = $0699 =  1689          main.asm:1032
DOEBIT  = $1979 =  6521          main.asm:3934
DOFN    = $1146 =  4422          main.asm:2587
DOKE    = $1C0B =  7179          main.asm:4261
DONULL  = $0B8F =  2959          main.asm:1744
DOSPC   = $0BCB =  3019          main.asm:1776
DOTAB   = $0BB8 =  3000          main.asm:1766
DPOINT  = $186B =  6251          main.asm:3767
DTSTR   = $11E5 =  4581          main.asm:2685
DVBCDE  = $1682 =  5762          main.asm:3435
DZ      = $0014 =    20          main.asm:270
DZERR   = $0488 =  1160          main.asm:718
ECHDEL  = $06AD =  1709          main.asm:1041
EDIGIT  = $18B2 =  6322          main.asm:3816
ENDBUF  = $0690 =  1680          main.asm:1024
ENDCON  = $187E =  6270          main.asm:3779
ENDDIM  = $10DF =  4319          main.asm:2526
ENDINP  = $0B80 =  2944          main.asm:1738
ENDNAM  = $0F5D =  3933          main.asm:2285
ENDPRG  = $092F =  2351          main.asm:1415
ENFMEM  = $046B =  1131          main.asm:700
ERRIN   = $04B9 =  1209          main.asm:743
ERRLIN  = $8117 = 33047          main.asm:242
ERRMSG  = $0416 =  1046          main.asm:651
ERROR   = $0499 =  1177          main.asm:730
ERRORS  = $038C =   908          main.asm:580
ESC     = $001B =    27          main.asm:188
EVAL    = $0D5C =  3420          main.asm:1979
EVAL1   = $0D5F =  3423          main.asm:1981
EVAL2   = $0D68 =  3432          main.asm:1985
EVAL3   = $0D6B =  3435          main.asm:1986
EVLPAR  = $0E21 =  3617          main.asm:2081
EVNOT   = $0F1B =  3867          main.asm:2251
EXCUTE  = $08BD =  2237          main.asm:1337
EXP     = $1A13 =  6675          main.asm:4021
EXPLP   = $185D =  6237          main.asm:3759
EXPTAB  = $1A53 =  6739          main.asm:4049
EXPTEN  = $198B =  6539          main.asm:3944
EXTIG   = $0CCA =  3274          main.asm:1904
FANDT   = $0CF4 =  3316          main.asm:1922
FC      = $0008 =     8          main.asm:264
FCERR   = $09A4 =  2468          main.asm:1479
FDTLP   = $0CDB =  3291          main.asm:1906
FINDEL  = $10BB =  4283          main.asm:2498
FLGBST  = $8044 = 32836          main.asm:11 (unused)
FLGDIF  = $1737 =  5943          main.asm:3553
FLGREL  = $173E =  5950          main.asm:3559
FNARG   = $8125 = 33061          main.asm:249
FNCTAB  = $01D6 =   470          main.asm:366
FNDARY  = $102B =  4139          main.asm:2406
FNDELP  = $10C0 =  4288          main.asm:2503
FNDEND  = $0565 =  1381          main.asm:843
FNDNUM  = $14A8 =  5288          main.asm:3126
FNDTOK  = $07D7 =  2007          main.asm:1206
FNDVAR  = $0FA2 =  4002          main.asm:2317
FNDWRD  = $0614 =  1556          main.asm:946
FNOFST  = $0E4B =  3659          main.asm:2105
FNRGNM  = $8123 = 33059          main.asm:248
FNTHR   = $0FB0 =  4016          main.asm:2325
FNVAL   = $0E72 =  3698          main.asm:2127
FOPRND  = $0D94 =  3476          main.asm:2007
FOR     = $0824 =  2084          main.asm:1248
FORFLG  = $8110 = 33040          main.asm:237
FORFND  = $0854 =  2132          main.asm:1276
FORSLP  = $0838 =  2104          main.asm:1257
FPADD   = $14E6 =  5350          main.asm:3160
FPBCDE  = $176D =  5997          main.asm:3589
FPEXP   = $812C = 33068          main.asm:251
FPINT   = $17D4 =  6100          main.asm:3675
FPMULT  = $1621 =  5665          main.asm:3371
FPREG   = $8129 = 33065          main.asm:250
FPROND  = $157E =  5502          main.asm:3261
FPSINT  = $0983 =  2435          main.asm:1465
FPTHL   = $1784 =  6020          main.asm:3608
FRE     = $10E3 =  4323          main.asm:2529
FRENUM  = $10FF =  4351          main.asm:2541
FRMEVL  = $0E3D =  3645          main.asm:2096
GARBGE  = $1266 =  4710          main.asm:2758
GARBLP  = $1269 =  4713          main.asm:2759
GETCHR  = $08DD =  2269          main.asm:1357
GETCMD  = $04DD =  1245          main.asm:760
GETHEX  = $1C90 =  7312          main.asm:4351
GETINP  = $1BE2 =  7138          main.asm:4235
GETINT  = $14AB =  5291          main.asm:3127
GETLEN  = $1399 =  5017          main.asm:2956
GETLIN  = $06CA =  1738          main.asm:1056
GETLN   = $09AA =  2474          main.asm:1483
GETNUM  = $0D4A =  3402          main.asm:1968
GETNXT  = $062F =  1583          main.asm:961
GETSTR  = $1363 =  4963          main.asm:2922
GETVAR  = $0F40 =  3904          main.asm:2272
GNXARY  = $129D =  4765          main.asm:2784
GOFUNC  = $0E7A =  3706          main.asm:2131
GOSUB   = $0A20 =  2592          main.asm:1548
GOTO    = $0A31 =  2609          main.asm:1560
GRBARY  = $12BD =  4797          main.asm:2803
GRBDON  = $123E =  4670          main.asm:2733
GRBLP   = $1277 =  4727          main.asm:2765
GSTRCU  = $1366 =  4966          main.asm:2923
GSTRDE  = $136A =  4970          main.asm:2925
GSTRHL  = $1369 =  4969          main.asm:2924
GTFLNM  = $13A8 =  5032          main.asm:2966 (unused)
GTFNAM  = $0F45 =  3909          main.asm:2275
GTLNLP  = $09AD =  2477          main.asm:1484
GTSIXD  = $1903 =  6403          main.asm:3860
GTVLUS  = $0C46 =  3142          main.asm:1834
HALF    = $19AA =  6570          main.asm:3965
HALFPI  = $1B63 =  7011          main.asm:4183
HEX     = $1C22 =  7202          main.asm:4278
HEX1    = $1C3B =  7227          main.asm:4291
HEX2    = $1C3D =  7229          main.asm:4293
HEX3    = $1C4B =  7243          main.asm:4301
HEX4    = $1C4D =  7245          main.asm:4303
HEXIT   = $1CA7 =  7335          main.asm:4366
HEXLP   = $1C83 =  7299          main.asm:4341
HEXLP1  = $1C88 =  7304          main.asm:4343
HEXTFP  = $1C77 =  7287          main.asm:4336
HX      = $0026 =    38          main.asm:279
HXERR   = $1CB0 =  7344          main.asm:4374
ID      = $0016 =    22          main.asm:271
IDTEST  = $118E =  4494          main.asm:2628
IF      = $0B03 =  2819          main.asm:1678
IFGO    = $0B11 =  2833          main.asm:1685
IFJMP   = $08C4 =  2244          main.asm:1340
INCHL   = $1782 =  6018          main.asm:3605
INCLEN  = $077E =  1918          main.asm:1153
INDFND  = $0448 =  1096          main.asm:676
INEWLN  = $052D =  1325          main.asm:803
INIT    = $00E5 =   229          main.asm:293
INITAB  = $03B6 =   950          main.asm:604
INITBE  = $0416 =  1046          main.asm:647
INITST  = $1D20 =  7456          main.asm:4450
INMSG   = $041D =  1053          main.asm:652
INP     = $1468 =  5224          main.asm:3095
INPBIN  = $0C98 =  3224          main.asm:1878
INPBRK  = $092C =  2348          main.asm:1413
INPORT  = $8084 = 32900          main.asm:205
INPSUB  = $8083 = 32899          main.asm:204
INPUT   = $0C06 =  3078          main.asm:1799
INRNG   = $190C =  6412          main.asm:3865
INT     = $17FF =  6143          main.asm:3706
INTEXT  = $0067 =   103          main.asm:75
INTRCV  = $003A =    58          main.asm:51
INTVAR  = $05A1 =  1441          main.asm:891
INVSGN  = $1755 =  5973          main.asm:3572
ITMSEP  = $0C89 =  3209          main.asm:1869
JJUMP1  = $1D17 =  7447          main.asm:4444 (unused)
JSTZER  = $1995 =  6549          main.asm:3950
KBHIT   = $009A =   154          main.asm:111
KILFOR  = $0D3A =  3386          main.asm:1959
KILIN   = $06C4 =  1732          main.asm:1053
LCRFLG  = $80F1 = 33009          main.asm:226
LEFT    = $13C5 =  5061          main.asm:2984
LEN     = $1395 =  5013          main.asm:2954
LET     = $0A8B =  2699          main.asm:1613
LETNUM  = $0ADE =  2782          main.asm:1655
LETSTR  = $0AA6 =  2726          main.asm:1626
LF      = $000A =    10          main.asm:27
LFRGNM  = $145E =  5214          main.asm:3086
LINEAT  = $80A1 = 32929          main.asm:221
LINEIN  = $18BE =  6334          main.asm:3826
LINES   = $1BF1 =  7153          main.asm:4247
LINESC  = $808B = 32907          main.asm:211
LINESN  = $808D = 32909          main.asm:212
LINFND  = $0516 =  1302          main.asm:789
LIST    = $0799 =  1945          main.asm:1170
LISTLP  = $07A5 =  1957          main.asm:1176
LOADFP  = $177B =  6011          main.asm:3598
LOG     = $15E0 =  5600          main.asm:3339
LOGTAB  = $15D3 =  5587          main.asm:3334
LOKFOR  = $0432 =  1074          main.asm:659
LOOP1   = $210C =  8460          main.asm:4480
LOOPST  = $810C = 33036          main.asm:235
LS      = $001C =    28          main.asm:274
LSTBIN  = $8111 = 33041          main.asm:238
LSTLP2  = $07C5 =  1989          main.asm:1197
LSTLP3  = $07C8 =  1992          main.asm:1198
LSTRAM  = $80F4 = 33012          main.asm:229
LSTRND  = $807F = 32895          main.asm:203
LTSTND  = $0CA3 =  3235          main.asm:1883
LWIDTH  = $8087 = 32903          main.asm:207
MAKINT  = $14AE =  5294          main.asm:3128
MAKNUM  = $1928 =  6440          main.asm:3880
MANLP   = $1847 =  6215          main.asm:3751
MATCH   = $0661 =  1633          main.asm:993
MEMMSG  = $01A4 =   420          main.asm:361
MID     = $13FF =  5119          main.asm:3024
MID1    = $13CB =  5067          main.asm:2988
MIDNUM  = $1463 =  5219          main.asm:3089
MINCDE  = $1526 =  5414          main.asm:3195
MINUS   = $0E29 =  3625          main.asm:2086
MKTMST  = $11D2 =  4562          main.asm:2670
MLDBLP  = $1820 =  6176          main.asm:3727
MLDEBC  = $1818 =  6168          main.asm:3722
MLOOP   = $0105 =   261          main.asm:308
MLSP10  = $1715 =  5909          main.asm:3533
MO      = $0024 =    36          main.asm:278
MONITR  = $1D1D =  7453          main.asm:4448
MONOUT  = $1D1A =  7450          main.asm:4446
MORDT   = $0CAF =  3247          main.asm:1888
MORINP  = $06D3 =  1747          main.asm:1061
MOVBUF  = $054C =  1356          main.asm:824
MOVDIR  = $0669 =  1641          main.asm:1001
MOVLP   = $0457 =  1111          main.asm:686
MOVSTR  = $0454 =  1108          main.asm:683
MOVUP   = $0451 =  1105          main.asm:682
MRPRNT  = $0B23 =  2851          main.asm:1692
MSIZE   = $0102 =   258          main.asm:307 (unused)
MUL8LP  = $164C =  5708          main.asm:3394
MULLN2  = $1618 =  5656          main.asm:3365
MULT    = $161F =  5663          main.asm:3369
MULT8   = $1643 =  5699          main.asm:3388
MULTEN  = $1889 =  6281          main.asm:3787
MULVAL  = $813B = 33083          main.asm:254
MVSTPT  = $0AD5 =  2773          main.asm:1649
NEDMOR  = $0C42 =  3138          main.asm:1832
NEGAFT  = $19C0 =  6592          main.asm:3974
NEMEM   = $0155 =   341          main.asm:351
NEW     = $0591 =  1425          main.asm:879
NEXITM  = $0BDB =  3035          main.asm:1785
NEXT    = $0CFF =  3327          main.asm:1927
NEXT1   = $0D02 =  3330          main.asm:1928
NF      = $0000 =     0          main.asm:260
NFERR   = $048B =  1163          main.asm:720
NMIFLG  = $8091 = 32913          main.asm:214 (unused)
NOCHNG  = $0659 =  1625          main.asm:988
NOENED  = $1998 =  6552          main.asm:3953
NOLIN   = $0942 =  2370          main.asm:1424
NOMADD  = $165D =  5725          main.asm:3405
NOMLAD  = $182E =  6190          main.asm:3735
NOPMPT  = $0C20 =  3104          main.asm:1811
NORMAL  = $1551 =  5457          main.asm:3230
NOSPC   = $0650 =  1616          main.asm:983
NOSUB7  = $1CA3 =  7331          main.asm:4362
NOSWAP  = $1500 =  5376          main.asm:3176
NOTAMP  = $0DFE =  3582          main.asm:2067
NOTFUL  = $004F =    79          main.asm:63
NOTSTR  = $0F78 =  3960          main.asm:2297
NOXOR   = $148E =  5262          main.asm:3112
NRWRAP  = $0080 =   128          main.asm:91
NSCFOR  = $0F88 =  3976          main.asm:2305
NULFLG  = $8089 = 32905          main.asm:209
NULL    = $0966 =  2406          main.asm:1443
NULLP   = $0B96 =  2966          main.asm:1747
NULLS   = $8086 = 32902          main.asm:206
NUMASC  = $18D1 =  6353          main.asm:3836
NWWRAP  = $005B =    91          main.asm:69
NXTARY  = $103F =  4159          main.asm:2418
NXTBYT  = $063F =  1599          main.asm:973
NXTCHR  = $0680 =  1664          main.asm:1013
NXTDAT  = $8121 = 33057          main.asm:247
NXTDTA  = $0A73 =  2675          main.asm:1595
NXTITM  = $0C3A =  3130          main.asm:1827
NXTOPR  = $8115 = 33045          main.asm:241
NXTSTL  = $0A7A =  2682          main.asm:1600
NXTSTT  = $0A7D =  2685          main.asm:1603
OD      = $0006 =     6          main.asm:263
OKMSG   = $0422 =  1058          main.asm:654
OM      = $000C =    12          main.asm:266
OMERR   = $047A =  1146          main.asm:711
ON      = $0AE5 =  2789          main.asm:1661
ONGO    = $0AF4 =  2804          main.asm:1669
ONGOLP  = $0AF5 =  2805          main.asm:1670
ONJMP   = $08C5 =  2245          main.asm:1341
OPNPAR  = $0D58 =  3416          main.asm:1977
OPRND   = $0DD3 =  3539          main.asm:2050
OS      = $001A =    26          main.asm:273
OTKLN   = $06C1 =  1729          main.asm:1052
OTPORT  = $804C = 32844          main.asm:196
OUTC    = $075E =  1886          main.asm:1136
OUTEXP  = $1989 =  6537          main.asm:3943
OUTIT   = $073F =  1855          main.asm:1114
OUTNBS  = $0745 =  1861          main.asm:1117
OUTNCR  = $1D2F =  7471          main.asm:4461
OUTSUB  = $804B = 32843          main.asm:195
OUTWRD  = $07E1 =  2017          main.asm:1212
OV      = $000A =    10          main.asm:265
OVERR   = $0494 =  1172          main.asm:726
OVTST1  = $1708 =  5896          main.asm:3525
OVTST2  = $170D =  5901          main.asm:3528
OVTST3  = $170E =  5902          main.asm:3529
PADD    = $18AD =  6317          main.asm:3812
PAND    = $0E94 =  3732          main.asm:2153
PASSA   = $1114 =  4372          main.asm:2555
PBUFF   = $812E = 33070          main.asm:253
PCTCC2  = $0012 =    18          main.asm:14
PEEK    = $14BC =  5308          main.asm:3137
PEND    = $0927 =  2343          main.asm:1410
PHLTFP  = $176A =  5994          main.asm:3588
PIOAC   = $000A =    10          main.asm:19 (unused)
PIOAD   = $0008 =     8          main.asm:18 (unused)
PIOBC   = $000B =    11          main.asm:21
PIOBD   = $0009 =     9          main.asm:20
PLUCDE  = $158B =  5515          main.asm:3272
PNORM   = $1559 =  5465          main.asm:3238
POINT   = $8096 = 32918          main.asm:217
POKE    = $14C3 =  5315          main.asm:3141
POPAF   = $1258 =  4696          main.asm:2748
POPHL   = $1382 =  4994          main.asm:2939
POPHRT  = $166D =  5741          main.asm:3419
POPNOK  = $04CF =  1231          main.asm:753
POR     = $0E93 =  3731          main.asm:2152
POR1    = $0EB6 =  3766          main.asm:2176
POS     = $1111 =  4369          main.asm:2554
POSINT  = $0986 =  2438          main.asm:1466
POUT    = $1474 =  5236          main.asm:3100
POWER   = $19CE =  6606          main.asm:3982
POWER1  = $19DE =  6622          main.asm:3990
POWER2  = $19FB =  6651          main.asm:4008
POWERS  = $19AE =  6574          main.asm:3967
PRCRLF  = $0B85 =  2949          main.asm:1740
PRINT   = $0B27 =  2855          main.asm:1694
PRITAB  = $0377 =   887          main.asm:557
PRNTHL  = $18C6 =  6342          main.asm:3830
PRNTLP  = $0B2A =  2858          main.asm:1695
PRNTNB  = $0B6D =  2925          main.asm:1727
PRNTOK  = $04D0 =  1232          main.asm:755
PRNTST  = $0B71 =  2929          main.asm:1729
PRNUMS  = $1222 =  4642          main.asm:2717
PROCES  = $06EC =  1772          main.asm:1072
PROGND  = $811B = 33051          main.asm:244
PROGST  = $813E = 33086          main.asm:255
PROMPT  = $05D4 =  1492          main.asm:916
PRS     = $1223 =  4643          main.asm:2718
PRS1    = $1226 =  4646          main.asm:2719
PRSLP   = $122D =  4653          main.asm:2722
PSET    = $8099 = 32921          main.asm:218
PSIOAC  = $0006 =     6          main.asm:16
PSIOAD  = $0004 =     4          main.asm:15
PSUB    = $14E1 =  5345          main.asm:3157
PTRLP   = $0559 =  1369          main.asm:833
PUTBUF  = $072B =  1835          main.asm:1103
PUTCTL  = $0730 =  1840          main.asm:1105
PUTFID  = $0899 =  2201          main.asm:1314
QTSTLP  = $11E8 =  4584          main.asm:2687
QTSTR   = $11E2 =  4578          main.asm:2683
QUARTR  = $1B67 =  7015          main.asm:4185
RBFCNT  = $8043 = 32835          main.asm:10
RBFLMT  = $003F =    63          main.asm:8
RBFRDP  = $8041 = 32833          main.asm:9
RBFSIZ  = $003F =    63          main.asm:5
RBFWTP  = $803F = 32831          main.asm:7
RD      = $0012 =    18          main.asm:269
READ    = $0C35 =  3125          main.asm:1824
READFG  = $8112 = 33042          main.asm:239
RECBUF  = $8000 = 32768          main.asm:6
REDO    = $0BE2 =  3042          main.asm:1789
REM     = $0A76 =  2678          main.asm:1598
RESDIV  = $16BA =  5818          main.asm:3470
RESEED  = $1B05 =  6917          main.asm:4141
RESET   = $809C = 32924          main.asm:219
RESTNL  = $0902 =  2306          main.asm:1380
RESTOR  = $08ED =  2285          main.asm:1369
RESZER  = $154C =  5452          main.asm:3226
RETADR  = $0FEF =  4079          main.asm:2365
RETINT  = $1743 =  5955          main.asm:3561
RETLIN  = $0A6E =  2670          main.asm:1592
RETNAD  = $0665 =  1637          main.asm:997
RETNUL  = $0FF2 =  4082          main.asm:2369
RETNUM  = $0E35 =  3637          main.asm:2091
RETREL  = $1735 =  5941          main.asm:3551
RETURN  = $0A4F =  2639          main.asm:1576
RG      = $0004 =     4          main.asm:262
RIGHT   = $13F5 =  5109          main.asm:3017
RIGHT1  = $13C9 =  5065          main.asm:2986
RINPUT  = $8093 = 32915          main.asm:216
RLTLP   = $0D78 =  3448          main.asm:1993
RND     = $1AA4 =  6820          main.asm:4088
RND1    = $1AE0 =  6880          main.asm:4119
RND2    = $1AFC =  6908          main.asm:4137
RNDTAB  = $1B0D =  6925          main.asm:4148
RNGTST  = $199B =  6555          main.asm:3957
RONDB   = $156D =  5485          main.asm:3250
RONDUP  = $156C =  5484          main.asm:3249
ROUND   = $14D4 =  5332          main.asm:3151
RSCALE  = $18A7 =  6311          main.asm:3810
RSLNBK  = $081B =  2075          main.asm:1244
RST00   = $0003 =     3          main.asm:35
RST08   = $0008 =     8          main.asm:40 (unused)
RST10   = $0010 =    16          main.asm:42 (unused)
RST18   = $0018 =    24          main.asm:44 (unused)
RST38   = $0038 =    56          main.asm:48 (unused)
RSTSTR  = $1418 =  5144          main.asm:3037
RUN     = $0A14 =  2580          main.asm:1543
RUNCNT  = $089D =  2205          main.asm:1318
RUNFST  = $059D =  1437          main.asm:888
RUNLIN  = $0A30 =  2608          main.asm:1559
RUNST   = $1D35 =  7477          main.asm:4464
RXA     = $006C =   108          main.asm:81
SAVEXP  = $154D =  5453          main.asm:3227
SAVSTP  = $0890 =  2192          main.asm:1307
SAVSTR  = $11BD =  4541          main.asm:2654
SBSCPT  = $0FFD =  4093          main.asm:2375
SCALE   = $15AB =  5547          main.asm:3304
SCALLP  = $15AD =  5549          main.asm:3305
SCALMI  = $1872 =  6258          main.asm:3772
SCALPL  = $1888 =  6280          main.asm:3786
SCNEND  = $12F4 =  4852          main.asm:2844
SCPTLP  = $1003 =  4099          main.asm:2379
SEARCH  = $062D =  1581          main.asm:959
SEED    = $805C = 32860          main.asm:202
SETIO   = $1498 =  5272          main.asm:3119
SETLIN  = $07EF =  2031          main.asm:1220
SETLIT  = $0677 =  1655          main.asm:1009
SETPTR  = $0554 =  1364          main.asm:830
SETTOP  = $0114 =   276          main.asm:320
SFTPRG  = $051E =  1310          main.asm:793
SGN     = $173B =  5947          main.asm:3558
SGNEXP  = $0E83 =  3715          main.asm:2139
SGNRES  = $812D = 33069          main.asm:252
SHRITE  = $15BA =  5562          main.asm:3313
SHRLP   = $15BD =  5565          main.asm:3315
SHRT1   = $15C1 =  5569          main.asm:3319
SIGNON  = $016D =   365          main.asm:357
SIGNS   = $1792 =  6034          main.asm:3618
SIN     = $1B1F =  6943          main.asm:4154
SIN1    = $1B4F =  6991          main.asm:4174
SINIT   = $00AA =   170          main.asm:125
SINTAB  = $1B6B =  7019          main.asm:4187
SIOCMD  = $00A0 =   160          main.asm:116
SIOCML  = $000A =    10          main.asm:122
SIXDIG  = $18EE =  6382          main.asm:3850
SMPVAR  = $1288 =  4744          main.asm:2772
SMSER1  = $1A83 =  6787          main.asm:4066
SN      = $0002 =     2          main.asm:261
SNERR   = $0485 =  1157          main.asm:716
SPCFST  = $18DF =  6367          main.asm:3842
SPCLP   = $0BD4 =  3028          main.asm:1782
SQR     = $19C5 =  6597          main.asm:3978
SRCHLN  = $0571 =  1393          main.asm:852
SRCHLP  = $0574 =  1396          main.asm:853
SSTSA   = $1350 =  4944          main.asm:2904
ST      = $001E =    30          main.asm:275
STACK   = $80AB = 32939          main.asm:224
STAKFP  = $175D =  5981          main.asm:3578
STALL   = $0916 =  2326          main.asm:1397
START1  = $2100 =  8448          main.asm:4474 (unused)
STARTB  = $00D7 =   215          main.asm:284
STKTHS  = $0DBC =  3516          main.asm:2034
STLOOK  = $81A2 = 33186          main.asm:256
STOP    = $0925 =  2341          main.asm:1408
STORED  = $09F1 =  2545          main.asm:1523
STPOOL  = $12CB =  4811          main.asm:2809
STR     = $11AD =  4525          main.asm:2647
STR1    = $11B3 =  4531          main.asm:2649
STRADD  = $12CE =  4814          main.asm:2811
STRBOT  = $8108 = 33032          main.asm:233
STRENT  = $0C8C =  3212          main.asm:1871
STRSPC  = $809F = 32927          main.asm:220
STTLIN  = $0B78 =  2936          main.asm:1733
SUBCDE  = $14E3 =  5347          main.asm:3159
SUBPHL  = $14DD =  5341          main.asm:3155
SUMLP   = $1A8C =  6796          main.asm:4071
SUMSER  = $1A74 =  6772          main.asm:4059
SUPTLZ  = $196D =  6509          main.asm:3927
SVNAM2  = $0F5C =  3932          main.asm:2284
SVSTAD  = $11DB =  4571          main.asm:2675
TAN     = $1B80 =  7040          main.asm:4194
TESTOS  = $125A =  4698          main.asm:2751
TESTR   = $123C =  4668          main.asm:2731
TM      = $0018 =    24          main.asm:272
TMERR   = $0497 =  1175          main.asm:728
TMPSTR  = $8104 = 33028          main.asm:232
TMSTPL  = $80F8 = 33016          main.asm:231
TMSTPT  = $80F6 = 33014          main.asm:230
TOPOOL  = $13C1 =  5057          main.asm:2981
TOSTRA  = $1359 =  4953          main.asm:2913
TRYAGN  = $1948 =  6472          main.asm:3900
TSALP   = $135A =  4954          main.asm:2914
TSTACK  = $80ED = 33005          main.asm:12
TSTBIT  = $1D28 =  7464          main.asm:4454 (unused)
TSTBRK  = $0908 =  2312          main.asm:1386
TSTNUM  = $0D4D =  3405          main.asm:1969
TSTOPL  = $1203 =  4611          main.asm:2703
TSTRED  = $0EBB =  3771          main.asm:2182
TSTREM  = $067A =  1658          main.asm:1010
TSTSGN  = $172C =  5932          main.asm:3546
TSTSTR  = $0D4E =  3406          main.asm:1970
TTYLIN  = $06CA =  1738          main.asm:1057
TXA     = $008F =   143          main.asm:102
TXLOOP  = $0090 =   144          main.asm:103
TYPE    = $80F2 = 33010          main.asm:227
UF      = $0022 =    34          main.asm:277
UFERR   = $0491 =  1169          main.asm:724
UL      = $000E =    14          main.asm:267
ULERR   = $0A4A =  2634          main.asm:1573
UNITY   = $15CF =  5583          main.asm:3332
UPDATA  = $0903 =  2307          main.asm:1381
USR     = $8048 = 32840          main.asm:194
VAL     = $142F =  5167          main.asm:3056
VAL1    = $144D =  5197          main.asm:3076
VAL2    = $1457 =  5207          main.asm:3080
VAL3    = $145A =  5210          main.asm:3081
VAREND  = $811D = 33053          main.asm:245
WAIT    = $147A =  5242          main.asm:3103
WAITLP  = $148F =  5263          main.asm:3113
WARM    = $00D4 =   212          main.asm:283 (unused)
WARMST  = $014C =   332          main.asm:347
WIDTH   = $1BE9 =  7145          main.asm:4242
WORDS   = $020E =   526          main.asm:397
WORDTB  = $032D =   813          main.asm:486
WRKSPC  = $8045 = 32837          main.asm:193
XXXXX   = $015B =   347          main.asm:353
ZDATA   = $0083 =   131          main.asm:528
ZDIV    = $00AF =   175          main.asm:546 (unused)
ZEND    = $0080 =   128          main.asm:526
ZEQUAL  = $00B4 =   180          main.asm:549
ZERARY  = $109E =  4254          main.asm:2478
ZERBYT  = $0421 =  1057          main.asm:653
ZEROLP  = $0FE1 =  4065          main.asm:2356
ZEROSUP = $1CC1 =  7361          main.asm:4383
ZFN     = $00A7 =   167          main.asm:537
ZFOR    = $0081 =   129          main.asm:527
ZGOSUB  = $008C =   140          main.asm:530
ZGOTO   = $0088 =   136          main.asm:529
ZGTR    = $00B3 =   179          main.asm:548
ZLEFT   = $00CF =   207          main.asm:553
ZLTH    = $00B5 =   181          main.asm:550
ZMINUS  = $00AD =   173          main.asm:544
ZNEW    = $00A4 =   164          main.asm:533
ZNOT    = $00AA =   170          main.asm:540
ZONELP  = $0BAF =  2991          main.asm:1761
ZOR     = $00B2 =   178          main.asm:547
ZPLUS   = $00AC =   172          main.asm:543
ZPOINT  = $00C7 =   199          main.asm:552 (unused)
ZPRINT  = $009E =   158          main.asm:532
ZREM    = $008E =   142          main.asm:531
ZSGN    = $00B6 =   182          main.asm:551
ZSPC    = $00A8 =   168          main.asm:538
ZSTEP   = $00AB =   171          main.asm:541
ZTAB    = $00A5 =   165          main.asm:535
ZTHEN   = $00A9 =   169          main.asm:539
ZTIMES  = $00AE =   174          main.asm:545 (unused)
ZTO     = $00A6 =   166          main.asm:536
_end    = $2122 =  8482          main.asm:28 (unused)
_size   = $2122 =  8482          main.asm:28 (unused)


total time: 3.0086 sec.
no errors
